From tmtest-commits at berlios.de  Tue Feb 28 00:00:36 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 00:00:36 +0100
Subject: [Tmtest-commits] [84] TRUNK: Added --no-trailing-newline, cleaned some things up
Message-ID: <200602272300.k1RN0aQ3007636@sheep.berlios.de>

Revision: 84
Author:   bronson
Date:     2006-02-28 00:00:34 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Added --no-trailing-newline, cleaned some things up

Modified Paths:
--------------
    TRUNK/BUGS
    TRUNK/CHANGES
    TRUNK/Makefile
    TRUNK/TODO
    TRUNK/compare.c
    TRUNK/compare.h
    TRUNK/matchval.h
    TRUNK/re2c/read.c
    TRUNK/re2c/scan.h
    TRUNK/test/01-testfile/10-DumpScript.test
    TRUNK/test/02-running/00-Empty.test
    TRUNK/test/02-running/11-Assert.test
    TRUNK/test/02-running/13-DisabledDir.test
    TRUNK/test/02-running/14-AbortConf.test
    TRUNK/test/02-running/15-DisabledDir.test
    TRUNK/test/02-running/16-ConfigError.test
    TRUNK/test/02-running/18-TestError.test
    TRUNK/test/02-running/21-QuoteFile.test
    TRUNK/test/03-results/02-Nstdout.test
    TRUNK/test/03-results/09-NoNL.test
    TRUNK/test/03-results/20-Modify.test
    TRUNK/test/03-results/21-Modify.test
    TRUNK/test/04-diff/00-NoDiff.test
    TRUNK/test/04-diff/02-MultiDiff.test
    TRUNK/test/04-diff/09-MultiLevelDiff.test
    TRUNK/test/04-diff/10-Patch.test
    TRUNK/test/04-diff/11-MultiPatch.test
    TRUNK/test/04-diff/12-MultiLevelPatch.test
    TRUNK/test/04-diff/13-MultiLevelPatch.test
    TRUNK/test.c
    TRUNK/tfscan.c
    TRUNK/tfscan.h
    TRUNK/tmtest.conf

Added Paths:
-----------
    TRUNK/examples/
    TRUNK/examples/README
    TRUNK/examples/docs/
    TRUNK/examples/docs/Modify1.test
    TRUNK/examples/docs/Modify2.test
    TRUNK/examples/docs/Modify3.test
    TRUNK/examples/tutorial/
    TRUNK/examples/tutorial/20-ArgSuppressNL.test
    TRUNK/test/01-testfile/08-GarbageInStdout.test
    TRUNK/test/01-testfile/09-GarbageInStderr.test
    TRUNK/test/03-results/01-Ystderr.test
    TRUNK/test/03-results/02-Nstderr.test
    TRUNK/test/03-results/03-Nstderr.test
    TRUNK/test/03-results/04-Nstderr.test
    TRUNK/test/03-results/09-NoNLMod.test
    TRUNK/test/03-results/09-NoNLStderr.test
    TRUNK/test/03-results/10-NoNLErrFail.test
    TRUNK/test/03-results/10-NoNLFFail.test
    TRUNK/test/03-results/10-NoNLFail.test
    TRUNK/test/03-results/11-NoNLOutput.test
    TRUNK/test/03-results/11-NoNLOutput2.test
    TRUNK/test/03-results/12-0pre.test
    TRUNK/test/03-results/12-NoNLTwice.test
    TRUNK/test/03-results/12-NoNLTwiceErr.test
    TRUNK/test/03-results/13-MultiNL.test
    TRUNK/test/03-results/13-MultiNL2.test
    TRUNK/test/03-results/13-MultiNL2Err.test
    TRUNK/test/03-results/13-MultiNLErr.test
    TRUNK/test/README

Removed Paths:
-------------
    TRUNK/tfscan.re
    TRUNK/tutorial/
Modified: TRUNK/BUGS
===================================================================
--- TRUNK/BUGS	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/BUGS	2006-02-27 23:00:34 UTC (rev 84)
@@ -2,16 +2,18 @@
 word "Disabled" in its stderr.  If you blindly pipe this diff to patch,
 it will destroy the output section of your test file.  This is easy enough
 to fix -- just re-enable the test and patch it again.  This will be
-fixed in tmtest 2.2 when we parse the status file asynchronously.
+fixed in tmtest 1.2 when we parse the status file asynchronously.  We
+will notice that the test is disabled and refuse to produce the diff.
 
 
-Bash Bugs:
+Bash Gotchas:
 
+
 Bash3 has removed the ability to set LINENO, so you may see the
-wrong line number be printed if there's an error.  The workaround
-suggested by the Bash author is far too large and complex.
-Downgrading to Bash2 works much better.  I don't understand why
-this functionality was removed in the first place!
+wrong line number be printed if there's an error.  If you want to
+see the correct line numbers, use Bash2.  It's an unfortunate
+regression but since it only affects tests scripts being piped
+on stdin it won't affect many people.
 
 
 The <<-EOL operator strips ALL tabs from the front of each line.
@@ -24,13 +26,16 @@
 	EOL
 
 The first heredoc flattens everything and then the EOLs get mixed up.
-What bash SHOULD do is discover the whitespace sequence indenting the
-first line of a heredoc, then remove that sequence from all subsequent
-lines.  If a line doesn't begin with exactly that sequence, then
-it is unchanged.  This would be much safer and more useful than just
-blowing away all tabs wholesale!
+What bash *SHOULD* do (and what tmtest did before it was integrated
+with Bash) is discover the whitespace sequence indenting the
+first line of a heredoc, then remove exactly that sequence from all
+subsequent lines.  If a line doesn't begin with that sequence, then
+it is unchanged.  This is safer and more useful than just blowing away
+all tabs wholesale!
 
 
+Bashisms:
+
 Why does &> redirect both stdout and stderr to a file, but &| doesn't
 redirect both stdout and stderr to a pipe?
 

Modified: TRUNK/CHANGES
===================================================================
--- TRUNK/CHANGES	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/CHANGES	2006-02-27 23:00:34 UTC (rev 84)
@@ -1,4 +1,14 @@
-- Get rid of all AUTHOR and DATE automation.  Too heavyhanded.
+- rename TRUNK to trunk
+- write some tests to ensure diff works with files that don't end in CR.
+- Fix 99-Misc.
+- move INDENT from 04-diff into the stdlib.  Add to docs.
+- Eradicate the MODIFY clause from the documentation.  Mark it deprecated.
+----
+- Bash3 has made it so that the RE can no longer appear on the same line as
+  the MODIFY command.  I updated all tests and accelerated MODIFY deprecation.
+- Added -n (--no-trailing-newline) capability to STDOUT and STDERR sections.
+- Rewrote the re2c parser in C so we should now be totally binary transparent.
+- Got rid of all AUTHOR and DATE automation.  Too heavyhanded.
 - Standardized licensing: everything under my control is MIT, package is LGPL.
 - When installing locally, it's ~/.tmlib.sh instead of ~/share/tmtest/tmlib.sh
 - Bump to 0.92

Modified: TRUNK/Makefile
===================================================================
--- TRUNK/Makefile	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/Makefile	2006-02-27 23:00:34 UTC (rev 84)
@@ -55,9 +55,9 @@
 %.o: %.c
 	$(CC) -g -c $< -o $@
 
-
+.PHONY: test
 test: tmtest
-	tmtest --config=./tmtest.conf test
+	./tmtest test
 
 run: tmtest
 	./tmtest

Modified: TRUNK/TODO
===================================================================
--- TRUNK/TODO	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/TODO	2006-02-27 23:00:34 UTC (rev 84)
@@ -1,29 +1,13 @@
-1.0:
-- Add to faq: limitation on line length when using MODIFY clause.
-  (MODIFY is memory-based, so a single line must fit into memory).
-  If you're working with big testfiles, don't use MODIFY.
-  - No, we fucking line buffer everything thanks to the scanner.
-  - I'd say it's time to hand-code the scanners so they don't
-    have to be line-buffered.  There's nothing we can do about MODIFY
-	of course.
-- Why is compare_continue not called??
-	Somehow we abandon the newline on the input buffer.
-	The problem is that the scanner REQUIRES a newline on the end.
-	    Shit, I wonder if it's time to just junk the scanner entirely.
-- what do we do when stdout is missing a newline at the end?
-  Test that both raw and modified work when stdout doesn't have a newline.
-  Check that diff works too.
-- Make "make test" work.
+0.94:
+- An empty test with a STDOUT clause should fail without the -n right?
+  I mean, there's no newline in the actual output, but there is in the
+  expected...
+- Add tests for binary transparency.
 - write tests for nesting testfiles with --config.
         // If the user specifies a config file, we only check directories
         // not above the given config file.  i.e. if user specifies
         // "tmtest -c /a/b/cc /a/t/u/t.test", we will look for config files
         // in /a/t/tmtest.conf and /a/t/u/tmtest.conf.
-- merge tmtestlib and tmtestrc.  They're now basically the same file.
-- get rid of all the exit(10) calls in test.c.  We need a better way to
-  abort the test.
-  should get rid of a whole bunch in main.c as well.
-  this should prevent us from dropping turds in /tmp all the time too.
 - Add the ability to specify test arguments on the command line.
   I'm picturing something where VAR=val on the command line would be
   inserted without change into the template.  That way you can use the
@@ -31,65 +15,74 @@
   - This would allow us to test almost every test to ensure it
     supports the --config argument (make them DISABLED or something).
 
-1.2:
+0.96:
 - stdin is all buggered up.  why is it that "cat" with no args will print
   the rest of the test script?  And why is it that if you fork, diff freezes?
   They're related problems I suspect.
-- Could take tests from tarfiles.  We would decompress the tarfile into
-  a temporary directory, run the test, and delete the tarfile.  This will
-  make it easier to maintain tests that all need to be run in a certain
-  directory hierarchy.
+    Is it because I'm forgetting to close all open filehandles before forking?
 - Tighten up printing a folder name when there are no testfiles in it.
   No need for double spacing.
-- Change the I/O scheme to be event based.  Get rid of the tempfiles.
-  Convert to using the async io library.  Don't use temporary files.
-  This would allow us to recognize that the test is disabled before
-  producing a partial diff, blowing away output sections.
-  - I'd say it's time to hand-code the scanners so they don't
-    have to be line-buffered.  There's nothing we can do about MODIFY
-	of course.  But don't line-buffer if we don't have to.  Should
-	simplify things quite a bit to get rid of re2c.
 - Add the ability to run multiple tests from one testfile.
   See tmtest 0.8 for a potential implementation of this.
   All we'd need to add is a framework to notify the user that multiple
   tests are in progress; bash can take care of the rest.
-- add the ability to run valgrind over each test and print success/failure
-  of that.  (gives deep valgrind coverage)
-  - One problem with this will be all the false warnings.
-- add gcov support so you can see what sort of coverage your tests provide.
 - Shouldn't run every test in a dir if the DISABLED directive is in a config
   file.
   Should discover what dir the DISABLED directive came from and refuse
   to run anything below that.
   - Yes, if a config file returns DISABLED, then that folder and all its
-    subfolders are skipped.  Just make the test itself return the DISABLED
+    subfolders are skipped.  Just make the test itself call the DISABLED
 	command if you want testing to continue in that subfolder.
 
+0.98:
+- Change the I/O scheme to be event based.  Get rid of the tempfiles.
+  Convert to using the async io library.  Don't use temporary files.
+  This would allow us to recognize that the test is disabled before
+  producing a partial diff, blowing away output sections.
+- Use i/o lib for everything.  No need for temp files.
+  This means that we stream everything EXCEPT stderr, which we memory
+  buffer.  If your stderr is more than 100K or so in size, just redirect
+  it to stdout.
+
+2.0:
+- get rid of all the exit(10) calls in test.c.  We need a better way to
+  abort the test.
+  should get rid of a whole bunch in main.c as well.
+  this should prevent us from dropping turds in /tmp all the time too.
+- Get rid of MODIFY clauses.  It's unnecessary complexity.
+  And it's a LOT.  First remove it from the tests, then from the code.
+
 ?:
-- should probably indent stdout and stderr clauses two spaces.  otherwise
-  we might misinterpret STDOUT: and STDERR: in a stdout or stderr clause.
-  - True, but this is easy enough to mock with a MODIFY clause.  The
-    downside to this is that 
-- Provide some sort of automatable XML output.
+- add gcov support so you can see what sort of coverage your tests provide.
+- Provide some sort of automatable XML output?
+- Could take tests from tarfiles.  We would decompress the tarfile into
+  a temporary directory, run the test, and delete the tarfile.  This will
+  make it easier to maintain tests that all need to be run in a certain
+  directory hierarchy.
+- add the ability to run valgrind over each test and print success/failure
+  of that.  (gives deep valgrind coverage)
+  - One problem with this will be all the false warnings.
+
+No longer a problem when we dump pcrs:
 - allow multiple s/// expressions on a single line.  will probably require
   modifications to pcrs_compile_command, so make it support buf/len at the
   same time.  These might be non-trivial changes...
 - it's stupid to dup the str just to null-terminate it so it can be passed
   to pcrs.  Modify pcrs to compile buffers too.
+- Unify the line modifier in compare.c and test.c.  It's hackish now.
+- Wow, the pcrs error messages truly suck.  Is there any way to improve them?
+  "(pcrs:) Syntax error while parsing command (-11)."
+- add a CLEAR_EACHLINE or CLEAR_MODIFY option to to turn off all substitutions.
+  It would be easy to do.  I'm just not convinced that anyone would find it
+  useful.
 
 ????:
-- Unify the line modifier in compare.c and test.c.  It's hackish now.
 - There should be a way to repeatedly run a single test with only tiny
   differences.  i.e. test all permeutations of DISABLE DISABLE:
   DISABLED DISABLED:  Hopefully that will clean up 05-08-Disable/Abort.test
-- Add a timeout that will terminate stalled tests.  You can set the timeout in the config file.
+- Add a timeout that will terminate stalled tests.  You can set the timeout
+  in the config file or the test itself.
 
-
-
-- Wow, the pcrs error messages suck.  Is there any way to improve them?
-  "(pcrs:) Syntax error while parsing command (-11)."
-
-
 maybe never:
 - Add STDOUT: trimws and STDERR: trimws - to trim whitespace from
   the front of each output line.
@@ -98,6 +91,8 @@
   realize that this problem is pretty much solved from the other direction.
   Instead of removing indentation from the heredoc, simply add indentation
   using a MODIFY section (as detailed in the FAQ).
-- add a CLEAR_EACHLINE or CLEAR_MODIFY option to to turn off all substitutions.
-  It would be easy to do.  I'm just not convinced that anyone would find it useful.
-
+- Add a "FAILURE-OK" flag for when failure IS an option.  This would print
+  that the test failed, but would not highlight it, and would not count
+  either positively or negatively toward the test results.  That way you
+  can include experimental tests in a production test stack (say you're
+  developing a test and want to know if it's a good idea...)

Modified: TRUNK/compare.c
===================================================================
--- TRUNK/compare.c	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/compare.c	2006-02-27 23:00:34 UTC (rev 84)
@@ -41,6 +41,8 @@
 	const char *pbuf;
 	int pcursor;
 	int plimit;
+    int no_trailing_newline;
+    int nl_suppressed;
 } compare_state;
 
 
@@ -60,7 +62,7 @@
 }
 
 
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *jobs)
+void compare_attach(scanstate *ss, matchval *mv, pcrs_job *jobs, int nonl)
 {
 	compare_state *cmp = malloc(sizeof(compare_state));
 	if(cmp == NULL) {
@@ -73,10 +75,13 @@
 
 	cmp->output = mv;
 	cmp->jobs = jobs;
-	ss->scanref = cmp;
+    cmp->no_trailing_newline = nonl;
+    cmp->nl_suppressed = 0;;
+    ss->scanref = cmp;
 }
 
 
+
 static void compare_continue_bytes(scanstate *ss, const char *ptr, int len)
 {
     int n;
@@ -92,7 +97,6 @@
                 exit(10);
             }
             if(n == 0) {
-				// there's more input data but we're at eof.
                 compare_halt(ss, match_no);
                 return;
             }
@@ -195,9 +199,8 @@
 				exit(10);
 			}
 			if(n == 0) {
-				// there's more input data but we're at eof.
-				compare_halt(ss, match_no);
-				return;
+                compare_halt(ss, match_no);
+                return;
 			}
 
 			p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
@@ -237,6 +240,25 @@
         return;
     }
 
+    assert(len >= 0);
+
+    if(cmp->no_trailing_newline) {
+        // If the incoming buffer ends in a nl, we need to suppress it
+        // for the comparison.  Note that this won't work well for
+        // MODIFY clauses but I don't care because MODIFY will never
+        // work with -n and, anyway, MODIFY is about to disappear.
+
+        if(cmp->nl_suppressed) {
+            compare_continue_bytes(ss, "\n", 1);
+            cmp->nl_suppressed = 0;
+        }
+
+        if(ptr[len-1] == '\n') {
+            cmp->nl_suppressed = 1;
+            len -= 1;
+        }
+    }
+
 	if(cmp->jobs) {
 		compare_continue_lines(ss, cmp, ptr, len);
 	} else {
@@ -267,7 +289,7 @@
 	}
 
 	// if we have no data left in the scan buffer
-	if(ss->limit - ss->cursor == 0) {
+	if(ss->cursor == ss->limit) {
 		// and our input file is at eof
 		if(compare_fill(ss) == 0) {
 			// then the two data streams match

Modified: TRUNK/compare.h
===================================================================
--- TRUNK/compare.h	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/compare.h	2006-02-27 23:00:34 UTC (rev 84)
@@ -18,7 +18,7 @@
 #define compare_in_progress(ss) ((ss)->scanref)
 
 
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *joblist);
+void compare_attach(scanstate *ss, matchval *mv, pcrs_job *joblist, int nonl);
 void compare_continue(scanstate *ss, const char *ptr, int len);
 void compare_end(scanstate *cmp);
 

Added: TRUNK/examples/README
===================================================================
--- TRUNK/examples/README	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/examples/README	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,5 @@
+This directory contains many examples of testfiles.
+
+docs -- testfiles used as examples in the tmtest documentation.
+tutorial -- testfiles used as examples in the tmtest tutorial.
+

Added: TRUNK/examples/docs/Modify1.test
===================================================================
--- TRUNK/examples/docs/Modify1.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/examples/docs/Modify1.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,5 @@
+echo RESULT
+MODIFY:
+   s/^(.)/   $1/
+STDOUT:
+   RESULT

Added: TRUNK/examples/docs/Modify2.test
===================================================================
--- TRUNK/examples/docs/Modify2.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/examples/docs/Modify2.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,7 @@
+# This is from http://tmtest.berlios.de/wiki/index.php/MODIFY
+
+echo RESULT
+MODIFY:
+   s/^RESULT/xRESULT/
+STDOUT:
+xRESULT

Added: TRUNK/examples/docs/Modify3.test
===================================================================
--- TRUNK/examples/docs/Modify3.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/examples/docs/Modify3.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,7 @@
+# This is from http://tmtest.berlios.de/wiki/index.php/MODIFY
+
+date
+MODIFY:
+  s/... +... +[0-9][0-9] +[0-9]?[0-9]:[0-9][0-9]:[0-9][0-9] +... +20[0-9][0-9]/date date date/
+STDOUT:
+date date date

Copied: TRUNK/examples/tutorial (from rev 81, TRUNK/tutorial)

Added: TRUNK/examples/tutorial/20-ArgSuppressNL.test
===================================================================
--- TRUNK/tutorial/20-ArgSuppressNL.test	2005-12-21 01:42:47 UTC (rev 81)
+++ TRUNK/examples/tutorial/20-ArgSuppressNL.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,3 @@
+echo -n "No newline"
+STDOUT:
+No newline
\ No newline at end of file

Modified: TRUNK/matchval.h
===================================================================
--- TRUNK/matchval.h	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/matchval.h	2006-02-27 23:00:34 UTC (rev 84)
@@ -9,7 +9,7 @@
 
 
 /**
- * Simply a tristate that tells whether something
+ * a tristate that tells whether something
  *    - matches
  *    - doesn't match
  *    - hasn't been checked yet.

Modified: TRUNK/re2c/read.c
===================================================================
--- TRUNK/re2c/read.c	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/re2c/read.c	2006-02-27 23:00:34 UTC (rev 84)
@@ -22,6 +22,17 @@
  * Returns the number of bytes available to read in the buffer.
  */
 
+/* TODO: could optimize for the fast case (no data that needs
+ * to be shifted).  However, there's no burning need -- it wouldn't
+ * offer much speedup  Bigger buffers would help a lot more.
+ * NOTE: the middle line of this macro is incomplete!  Don't use!
+
+#define read_shiftbuf(ss) (ss->token == ss->limit ? \
+    (ss->token = ss->cursor = ss->bufptr, 0) : \
+    _read_shiftbuf(ss)) 
+
+ */
+
 int read_shiftbuf(scanstate *ss)
 {
     int cnt = ss->token - ss->bufptr;

Modified: TRUNK/re2c/scan.h
===================================================================
--- TRUNK/re2c/scan.h	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/re2c/scan.h	2006-02-27 23:00:34 UTC (rev 84)
@@ -3,6 +3,12 @@
  * 27 Dec 2004
  *
  * This part of support code to make writing re2c scanners much easier.
+ *
+ * TODO: probably want to split the re2c-specific code from the general
+ * code.  This file is overall very useful, but it's got a few limitations
+ * imposed by re2c that should probably be placed in its own layer.
+ * That way, future versions of re2c won't have to suffer the same
+ * limitations.
  */
 
 /** @file scan.h
@@ -53,21 +59,32 @@
 #define YYLIMIT     (ss->limit)
 #define YYMARKER    (ss->marker)
 
-// This routine needs to force a return if 0 bytes were read because
-// otherwise we might end up scanning garbage waaay off the end of
-// the buffer.  We ignore n because there can be cases where there
-// are less than n bytes left in the file, but it's perfectly valid
-// data and one or more tokens will match.  n is useless (right?).
-// We also don't want to return prematurely.  If there's still data
-// in the buffer, even if the read returned 0, we'll continue parsing.
-// But, if read is at eof and there's no data left in the buffer, then
-// there's nothing to do BUT return 0.
+/** Fills the scan buffer with more data.
+ *
+ * This routine needs to force a return if 0 bytes were read because
+ * otherwise the re2c scanner will end up scanning garbage way off
+ * the end of the buffer.  There's no (good) way to tell the scanner
+ * "the file is at eof so just finish the token that you're on" (right?).
+ * It will always lose the token at the end of the file unless the file
+ * ends in a token delimiter (usually a newline).
+ *
+ * We ignore n because there can be less than n bytes left in the file,
+ * yet one or more tokens will still match.  Therefore, we should always
+ * read as much data as we can, and we should return success even if we
+ * have less than n bytes in the buffer.  N is totally useless.
+ *
+ * The last line is the limitation.  If it weren't there, YYFILL would
+ * return with an empty buffer so re2c would know it's at EOF and
+ * shut down gracefully.  But re2c can't handle that.
+ *
+ * If you're using the re2c lib but writing your own re2c scanners,
+ * call ss->read directly.
+ */
 
 #define YYFILL(n)   do { \
 		int r = (*ss->read)(ss); \
-		if(r <= 0 && (ss)->cursor >= (ss)->limit) { \
-			return r; \
-		} \
+		if(r < 0) return r; \
+		if((ss)->cursor >= (ss)->limit) return 0; \
 	} while(0);
 
 
@@ -83,6 +100,14 @@
  * first shift the pointers in ss to make room (see read_shiftbuffer())
  * then load new data into the unused bytes at the end of the buffer.
  *
+ * I chose the shift technique over a ringbuffer because we should rarely
+ * have to shift data.  If you find that your file has gigantic tokens
+ * and you're burning a lot of cpu shifting partial tokens from the end
+ * of the buffer to the start, you might want to use a ring buffer instead
+ * of a shift buffer.  However, re2c itself can't handle ringbuffers or
+ * split tokens (nor can most scanners that I'm aware of), so shift
+ * buffers are the best we can do.
+ *
  * This routine returns 0 when there's no more data (EOF).
  * If it returns a value less than 0, that value will be returned
  * to the caller instead of a token.  This can indicate an error
@@ -97,8 +122,17 @@
  * ensure that you don't
  * accidentally end up modifying the buffer as it's being scanned.
  * This means that your read routine must cast them to be mutable
- * (char*) before reading them.  Only the readproc may modify the
+ * (char*) before reading them.  Only the readproc should modify the
  * data that's in the scan buffer.
+ *
+ * The caller assumes that the read routine will always fill the buffer
+ * up as much as possible.  Therefore, if the buffer isn't entirely full,
+ * then it knows that the EOF is probably at the end of the data.  This
+ * is a fine assumption for files but not so good for pipes, network
+ * sockets, anything that is packetized or works in realtime.  It would
+ * take a rewrite of re2c to remove this limitation. So, yes, your
+ * scanner can assume that the read routine will always fill the buffer
+ * up as much as it possibly can.
  */
 
 typedef int (*readproc)(struct scanstate *ss);
@@ -134,7 +168,7 @@
  * to cast the pointers to be nonconst.
  */
 
-typedef struct scanstate {
+struct scanstate {
     const char *cursor; ///< The current character being looked at by the scanner
     const char *limit;  ///< The last valid character in the current buffer.  If the previous read was short, then this will not point to the end of the actual buffer (bufptr + bufsiz).
     const char *marker; ///< Used internally by re2c engine to handle backtracking.
@@ -151,11 +185,12 @@
     readproc read;      ///< The routine the scanner calls when the buffer needs to be reread.
 
     void *scanref;      ///< Data specific to the scanner
-    scanproc state;     ///< some scanners are made up of multiple individual scan routines.  They store their state here.
+    scanproc state;     ///< The entrypoint for the scanning routine.  The name is now anachronistic but might still fit (some scanners are made up of multiple individual scan routines -- they store their state here).
 
     void *userref;      ///< Never touched by any of our routines (except scanstate_init, which clears both fields).  This can be used to associate a parser with this scanner.
     void *userproc;     ///< That's just a suggestion though.  These fields are totally under your control.
-} scanstate;
+};
+typedef struct scanstate scanstate;
 
 
 void scanstate_init(scanstate *ss, const char *bufptr, int bufsiz);
@@ -166,11 +201,11 @@
  *
  * How what this macro does:
  *
- * If the reader has already marked the stream at eof, then we're finished.
- * Otherwise, if there's still more data in the buffer, then we're not
- * finished.  Finally, if there's no data in the buffer but we're not at
- * eof, then we need te execute a read to determine.  If the read doesn't
- * return any data, then we're finished.
+ * If there's still more data in the buffer, then we're not finished.
+ * If there's no data in the buffer and we're at EOF, then we're finished.
+ * If there's no data in the buffer but we're not at eof, then we need
+ * to execute a read to see if there's more data available.  If so, we're
+ * not finished.  Otherwise, we're all done.
  */
 
 #define scan_finished(ss) \
@@ -183,6 +218,7 @@
  */
 
 #define scan_token(ss) ((*((ss)->state))(ss))
+#define scan_next_token(ss) ((*((ss)->state))(ss))
 
 
 /** Returns a pointer to the first character of the
@@ -190,6 +226,7 @@
  */
 
 #define token_start(ss) ((ss)->token)
+#define current_token_start(ss) ((ss)->token)
 
 /** Returns a pointer to one past the last character of the
  *  most recently scanned token.
@@ -198,13 +235,22 @@
  */
 
 #define token_end(ss) ((ss)->cursor)
+#define current_token_end(ss) ((ss)->cursor)
 
 /** Returns the length of the most recently scanned token.
  */
 
 #define token_length(ss) ((ss)->cursor - (ss)->token)
+#define current_token_length(ss) ((ss)->cursor - (ss)->token)
 
+/** Returns the current token in a malloc'd buffer.
+ * (just calls strdup(3) internally).
+ */
 
+#define token_dup(ss) strndup(token_start(ss), token_length(ss))
+#define current_token_dup(ss) token_dup(ss)
+
+
 /** Pushes the current token back onto the stream
  *
  * Calling scan_pushback returns the scanner to the state it had
@@ -215,15 +261,28 @@
  * Note that this only works once.  You cannot push multiple tokens back
  * into the scanner.  Also, the scanner may have internal state of its
  * own that does not get reset.  If so, the scanner may or may not provide
- * a routine to back its state up as well.
+ * a routine to back its internal state up as well.  Beware!!
  *
  * Finally, this doesn't back the line number up.  If you're pushing
  * a token back and you care about having the correct line nubmer,
- * then you'll have to restore the line number to what it was before
- * you scanned the token that you're pushing back.
+ * then you'll have to manually restore the line number to what it
+ * was before you scanned the token that you're pushing back.
  *
- * Yes, it takes some pretty serious research to call this function safely.
- * However, when you need to, it can be amazingly useful.
+ * i.e.
+ *
+ *     // First ensure that the scanner you're using doesn't
+ *     // have internal state that will be screwed up if you
+ *     // re-scan the current token!
+ *
+ *     oldline = ss->line;
+ *     tok = scan_token(ss);
+ *     if(tok == push_me_back) {
+ *         scan_pushback(ss);
+ *         ss->line = oldline;
+ *     }
+ *
+ * Yes, it takes some effort to call this function safely.
+ * But it can be worth it when you need it.
  */
 
 #define scan_pushback(ss) ((ss)->cursor = (ss)->token)
@@ -232,18 +291,18 @@
 /** Sets the current line number in the scanner to the given value.
  */
 
-#define set_line(ss,n) (ss->line=(n));
+#define scan_set_line(ss,n) (ss->line=(n));
 
 
 /** Increments the current line number by 1.
  */
 
-#define inc_line(ss)   (ss->line++);
+#define scan_inc_line(ss)   (ss->line++);
 
 
-/** This should be called by ever scanproc
- *
- * This prepares the scanstate to scan a new token.
+/**
+ * Prepares the scanner to scan a new token.
+ * This should be called at the beginning of every scanproc.
  */
 
 #define scanner_enter(ss) ((ss)->token = (ss)->cursor)

Added: TRUNK/test/01-testfile/08-GarbageInStdout.test
===================================================================
--- TRUNK/test/01-testfile/08-GarbageInStdout.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/01-testfile/08-GarbageInStdout.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,16 @@
+# Scott Bronson
+# 26 Feb 2006
+#
+# Ensures that we recognize when the stdout clause contains garbage.
+
+tmtest -q - <<-EOL
+    echo crapola
+	STDOUT: crapola
+    crapola
+EOL
+STDERR:
+(STDIN) line 2: unknown arguments "crapola"
+STDOUT:
+FAIL (STDIN)                   O..  stdout differed
+
+1 test run, 0 successes, 1 failure.

Added: TRUNK/test/01-testfile/09-GarbageInStderr.test
===================================================================
--- TRUNK/test/01-testfile/09-GarbageInStderr.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/01-testfile/09-GarbageInStderr.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,18 @@
+# Scott Bronson
+# 26 Feb 2006
+#
+# Ensures that we recognize when the stdout clause contains garbage.
+
+tmtest -q - <<-EOL
+    echo crapola
+    echo crapola
+    echo crapola
+	STDERR: crapola
+    crapola
+EOL
+STDERR:
+(STDIN) line 4: unknown arguments "crapola"
+STDOUT:
+FAIL (STDIN)                   OE.  stdout and stderr differed
+
+1 test run, 0 successes, 1 failure.

Modified: TRUNK/test/01-testfile/10-DumpScript.test
===================================================================
--- TRUNK/test/01-testfile/10-DumpScript.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/01-testfile/10-DumpScript.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -1,6 +1,6 @@
 # Ensures that the dumpscript is what we expect.
 # This is just so we don't surprise ourselves...  Any time you modify
-# template.sh, you should expect test to fial.
+# template.sh, you should expect test to fail.
 
 tmtest $args --dump-script - <<-EOL
 THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
@@ -9,8 +9,9 @@
 THE-SCRIPT THE-SCRIPT THE-SCRIPT 4
 EOL
 
-MODIFY: s/DATE='.*'/Date='BLAH BLAH'/
-        s/^(.)/	$1/
+MODIFY:
+  s/DATE='.*'/Date='BLAH BLAH'/
+  s/^(.)/	$1/
 
 STDOUT:
 	echo START >&7

Modified: TRUNK/test/02-running/00-Empty.test
===================================================================
--- TRUNK/test/02-running/00-Empty.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/02-running/00-Empty.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -1,4 +1,4 @@
-# What happens when we run an empty test file?
+# What happens when we run an empty (totally blank) test file?
 
 # It should succeed since all the defaults are met: no stdout,
 # no stderr, and an exit code of 0.

Modified: TRUNK/test/02-running/11-Assert.test
===================================================================
--- TRUNK/test/02-running/11-Assert.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/02-running/11-Assert.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -11,7 +11,8 @@
 # Furthermore, the filename and line are never even displayed
 # on bash2.  Therefore, just wipe the filename and line nuber out
 # completely and this test should pass everywhere.
-MODIFY: s/ on.*line \d+//
+MODIFY:
+  s/ on.*line \d+//
 
 STDOUT:
 ABRT (STDIN)                   assertion failed: "-1 -eq 1"

Modified: TRUNK/test/02-running/13-DisabledDir.test
===================================================================
--- TRUNK/test/02-running/13-DisabledDir.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/02-running/13-DisabledDir.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -23,7 +23,8 @@
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY: s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
+MODIFY:
+  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
 STDOUT:
 
 Processing .

Modified: TRUNK/test/02-running/14-AbortConf.test
===================================================================
--- TRUNK/test/02-running/14-AbortConf.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/02-running/14-AbortConf.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -26,7 +26,8 @@
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY: s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
+MODIFY:
+  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
 STDOUT:
 
 Processing .

Modified: TRUNK/test/02-running/15-DisabledDir.test
===================================================================
--- TRUNK/test/02-running/15-DisabledDir.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/02-running/15-DisabledDir.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -24,7 +24,8 @@
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY: s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
+MODIFY:
+  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
 STDOUT:
 
 Processing .

Modified: TRUNK/test/02-running/16-ConfigError.test
===================================================================
--- TRUNK/test/02-running/16-ConfigError.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/02-running/16-ConfigError.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -25,7 +25,8 @@
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY: s/^\/.*\/tmtest.conf/TMTEST.CONF/
+MODIFY:
+  s/^\/.*\/tmtest.conf/TMTEST.CONF/
 STDOUT:
 
 Processing .

Modified: TRUNK/test/02-running/18-TestError.test
===================================================================
--- TRUNK/test/02-running/18-TestError.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/02-running/18-TestError.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -10,8 +10,9 @@
 EOL
 
 # stupid bash3 won't allow LINENO=0 to set the proper lineno.
-MODIFY: s/: line \d+:/: line BLAH:/
-MODIFY: s/^(\S)/  $1/
+MODIFY:
+  s/: line \d+:/: line BLAH:/
+  s/^(\S)/  $1/
 
 STDOUT:
   set -e

Modified: TRUNK/test/02-running/21-QuoteFile.test
===================================================================
--- TRUNK/test/02-running/21-QuoteFile.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/02-running/21-QuoteFile.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -19,7 +19,8 @@
 rm "vl'hurg.test" '12".test'
 
 
-MODIFY: s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
+MODIFY:
+  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
 STDOUT:
 
 Processing .

Added: TRUNK/test/03-results/01-Ystderr.test
===================================================================
--- TRUNK/test/03-results/01-Ystderr.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/01-Ystderr.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,9 @@
+tmtest -q - <<-EOL
+	echo Howdy 1>&2
+	STDERR :
+	Howdy
+EOL
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: TRUNK/test/03-results/02-Nstderr.test
===================================================================
--- TRUNK/test/03-results/02-Nstderr.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/02-Nstderr.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,16 @@
+#!/usr/bin/tmtest
+
+# This test ensures we fail a test whose stderr doesn't match.
+# (Howdy vs. howdy).
+
+
+tmtest -q - <<-EOL
+	echo Howdy 1>&2
+	STDERR:
+	howdy
+EOL
+STDOUT:
+FAIL (STDIN)                   .E.  stderr differed
+
+1 test run, 0 successes, 1 failure.
+RESULT: 0

Modified: TRUNK/test/03-results/02-Nstdout.test
===================================================================
--- TRUNK/test/03-results/02-Nstdout.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/02-Nstdout.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -6,7 +6,6 @@
 
 tmtest -q - <<-EOL
 	echo Howdy
-
 	STDOUT :
 	howdy
 EOL

Added: TRUNK/test/03-results/03-Nstderr.test
===================================================================
--- TRUNK/test/03-results/03-Nstderr.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/03-Nstderr.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,16 @@
+#!/usr/bin/tmtest
+
+# This test ensures we fail a test whose stderr doesn't match.
+# there's an extra space after the Howdy in the stderr.
+
+
+tmtest -q - <<-EOL
+	echo Howdy 1>&2
+	STDERR:
+	Howdy 
+EOL
+STDOUT:
+FAIL (STDIN)                   .E.  stderr differed
+
+1 test run, 0 successes, 1 failure.
+RESULT: 0

Added: TRUNK/test/03-results/04-Nstderr.test
===================================================================
--- TRUNK/test/03-results/04-Nstderr.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/04-Nstderr.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,17 @@
+#!/usr/bin/tmtest
+
+# This test ensures we fail a test whose stdout doesn't match.
+# there's an extra newline in the expected stdout.
+
+
+tmtest -q - <<-EOL
+	echo Howdy 1>&2
+	STDERR:
+	Howdy
+
+EOL
+STDOUT:
+FAIL (STDIN)                   .E.  stderr differed
+
+1 test run, 0 successes, 1 failure.
+RESULT: 0

Modified: TRUNK/test/03-results/09-NoNL.test
===================================================================
--- TRUNK/test/03-results/09-NoNL.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/09-NoNL.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -1,4 +1,13 @@
-DISABLED: need the STDOUT -n feature
+# Scott Bronson
+# 26 Feb 2006
+#
+# Ensures that a test's stdout need not end in "\n" for the test
+# to pass (see --no-trailing-newline in testfile(5).
+#
+# Also see: 09-NoNL.test
+#
+# (back when we were parsing tests using re2c, lines needed to be
+# less than BUFSIZ and the results always had to end in a newline).
 
 tmtest -q - <<-EOL
 	echo -n Howdy
@@ -6,6 +15,6 @@
 	Howdy
 EOL
 STDOUT : 
-ok   (STDIN)
+ok   (STDIN) 
 
 1 test run, 1 success, 0 failures.

Added: TRUNK/test/03-results/09-NoNLMod.test
===================================================================
--- TRUNK/test/03-results/09-NoNLMod.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/09-NoNLMod.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,27 @@
+# Scott Bronson
+# 26 Feb 2006
+#
+# Ensures that a test's stdout need not end in "\n" for the test
+# to pass (see --no-trailing-newline in testfile(5).  This adds a
+# modify clause because, alas, using a modify clause changes the
+# code path for the comparison.  This is one reason why modify
+# clauses are evil...
+#
+# Also see: 09-NoNL.test
+#
+# (back when we were parsing tests using re2c, lines needed to be
+# less than BUFSIZ and the results always had to end in a newline).
+
+DISABLED "MODIFY won't work here."
+
+tmtest -q - <<-EOL
+    echo -n Howdy
+    MODIFY:
+      s/How/Wen/
+    STDOUT: -n
+    Wendy
+EOL
+STDOUT: 
+ok   (STDIN)
+
+1 test run, 1 success, 0 failures.

Added: TRUNK/test/03-results/09-NoNLStderr.test
===================================================================
--- TRUNK/test/03-results/09-NoNLStderr.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/09-NoNLStderr.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,20 @@
+# Scott Bronson
+# 26 Feb 2006
+#
+# Ensures that a test's stderr need not end in "\n".
+#
+# Also see: 09-NoNL.test
+#
+# (back when we were parsing tests using re2c, lines needed to be
+# less than BUFSIZ and the results always had to end in a newline).
+
+
+tmtest -q - <<-EOL
+	echo -n Howdy 1>&2
+	STDERR: --no-trailing-newline
+	Howdy
+EOL
+STDOUT: 
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: TRUNK/test/03-results/10-NoNLErrFail.test
===================================================================
--- TRUNK/test/03-results/10-NoNLErrFail.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/10-NoNLErrFail.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,17 @@
+# Scott Bronson
+# 26 Feb 2006
+#
+# Ensures that if we specify -n in the STDERR section, but the test
+# DOES produce a trailing newline on its stderr, we fail the test.
+#
+# Also see: 09-NoNL.test
+
+tmtest -q - <<-EOL
+	echo Howdy 1>&2
+	STDERR: -n
+	Howdy
+EOL
+STDOUT : 
+FAIL (STDIN)                   .E.  stderr differed
+
+1 test run, 0 successes, 1 failure.

Added: TRUNK/test/03-results/10-NoNLFFail.test
===================================================================
--- TRUNK/test/03-results/10-NoNLFFail.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/10-NoNLFFail.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,14 @@
+# This is kind of an interesting test...  There are two newlines after
+# Howdy.  The test clearly only produces one.  However, because we
+# suppress one, the test succeeds.
+
+tmtest -q - <<-EOL
+	echo Howdy
+	STDOUT: -n
+	Howdy
+
+EOL
+STDOUT : 
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: TRUNK/test/03-results/10-NoNLFail.test
===================================================================
--- TRUNK/test/03-results/10-NoNLFail.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/10-NoNLFail.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,21 @@
+# Scott Bronson
+# 26 Feb 2006
+#
+# Ensures that if we specify -n in the STDOUT section, but the test
+# DOES produce a trailing newline on its stderr, we fail the test.
+#
+# Also see: 09-NoNL.test
+#
+# (back when we were parsing tests using re2c, lines needed to be
+# less than BUFSIZ and the results always had to end in a newline).
+
+
+tmtest -q - <<-EOL
+	echo Howdy
+	STDOUT: -n
+	Howdy
+EOL
+STDOUT : 
+FAIL (STDIN)                   O..  stdout differed
+
+1 test run, 0 successes, 1 failure.

Added: TRUNK/test/03-results/11-NoNLOutput.test
===================================================================
--- TRUNK/test/03-results/11-NoNLOutput.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/11-NoNLOutput.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,24 @@
+# Scott Bronson
+# 26 Feb 2006
+#
+# Ensures that we correctly add the trailing newline when outputting
+# the test.
+#
+# Also see: 09-NoNL.test
+#
+# (back when we were parsing tests using re2c, lines needed to be
+# less than BUFSIZ and the results always had to end in a newline).
+
+tmtest -o -q - <<-EOL
+	echo -n Howdy
+	STDOUT: -n
+	Howdy
+EOL
+
+MODIFY:
+   s/^(.)/   $1/
+
+STDOUT:
+   echo -n Howdy
+   STDOUT: -n
+   Howdy

Added: TRUNK/test/03-results/11-NoNLOutput2.test
===================================================================
--- TRUNK/test/03-results/11-NoNLOutput2.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/11-NoNLOutput2.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,24 @@
+# Scott Bronson
+# 26 Feb 2006
+#
+# Ensures that we correctly add the trailing newline when outputting
+# the test.
+#
+# Also see: 09-NoNL.test
+#
+# (back when we were parsing tests using re2c, lines needed to be
+# less than BUFSIZ and the results always had to end in a newline).
+
+tmtest -o -q - <<-EOL
+	echo -n Howdy
+	STDOUT: --no-trailing-newline
+	Howdy
+EOL
+
+MODIFY:
+   s/^(.)/   $1/
+
+STDOUT:
+   echo -n Howdy
+   STDOUT: --no-trailing-newline
+   Howdy

Added: TRUNK/test/03-results/12-0pre.test
===================================================================
--- TRUNK/test/03-results/12-0pre.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/12-0pre.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,16 @@
+# Ensure that we can use head to trim the final newline from
+# the testfile.
+
+DISABLED
+
+head -c -1 <<-EOL
+    echo -n Howdy
+    STDOUT:
+    Howdy
+
+EOL
+
+STDOUT:
+echo -n Howdy
+STDOUT:
+Howdy

Added: TRUNK/test/03-results/12-NoNLTwice.test
===================================================================
--- TRUNK/test/03-results/12-NoNLTwice.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/12-NoNLTwice.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,23 @@
+# This test verifies that if we specify -n AND the file doesn't end in a
+# newline that the test will still succeed.
+
+# This file does not end in a newline!  If there's a newline at the end of
+# this file then some editor or version control program messed it up.
+
+# NOTE: it is unfortunate that we're testing the currently installed
+# tmtest, not the tmtest that we SHOULD be testing.
+
+# Uses the head command to trim the final \r from the testfile.
+
+DISABLED
+
+head -c -1 <<-EOL | tmtest -d -q -
+    echo -n Howdy
+    STDOUT:
+    Howdy
+EOL
+
+STDOUT:
+FAIL (STDIN)                   O..  stdout differed
+
+1 test run, 0 successes, 1 failure.

Added: TRUNK/test/03-results/12-NoNLTwiceErr.test
===================================================================
--- TRUNK/test/03-results/12-NoNLTwiceErr.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/12-NoNLTwiceErr.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,11 @@
+# This test verifies that if we specify -n AND the file doesn't end in a
+# newline that the test will still succeed.
+#
+# This file does not end in a newline!  If there's a newline at the end of
+# this file then some editor or version control program messed it up.
+
+DISABLED
+
+echo Howdy 1>&2
+STDERR: -n
+Howdy

Added: TRUNK/test/03-results/13-MultiNL.test
===================================================================
--- TRUNK/test/03-results/13-MultiNL.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/13-MultiNL.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,14 @@
+# If you specify -n, we only suppress ONE newline.  Therefore, if the
+# test produces one newline, and the expected results end in two newlines,
+# one of the two newlines will match and the test will succeed.
+
+tmtest -q - <<-EOL
+	echo Howdy
+	STDOUT: -n
+	Howdy
+
+EOL
+STDOUT: 
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: TRUNK/test/03-results/13-MultiNL2.test
===================================================================
--- TRUNK/test/03-results/13-MultiNL2.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/13-MultiNL2.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,16 @@
+# This is like MultiNL.test except that we include 3 newlines!
+# Since the test is only expecting a single newline, and only
+# one will be suppressed, this test will fail.
+
+tmtest -q - <<-EOL
+	echo Howdy
+	STDOUT: -n
+	Howdy
+
+
+EOL
+
+STDOUT: 
+FAIL (STDIN)                   O..  stdout differed
+
+1 test run, 0 successes, 1 failure.

Added: TRUNK/test/03-results/13-MultiNL2Err.test
===================================================================
--- TRUNK/test/03-results/13-MultiNL2Err.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/13-MultiNL2Err.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,16 @@
+# This is like MultiNL.test except that we include 3 newlines!
+# Since the test is only expecting a single newline, and only
+# one will be suppressed, this test will fail.
+
+tmtest -q - <<-EOL
+	echo Howdy 1>&2
+	STDERR: -n
+	Howdy
+
+
+EOL
+
+STDOUT:
+FAIL (STDIN)                   .E.  stderr differed
+
+1 test run, 0 successes, 1 failure.

Added: TRUNK/test/03-results/13-MultiNLErr.test
===================================================================
--- TRUNK/test/03-results/13-MultiNLErr.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/13-MultiNLErr.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,14 @@
+# If you specify -n, we only suppress ONE newline.  Therefore, if the
+# test produces one newline, and the expected results end in two newlines,
+# one of the two newlines will match and the test will succeed.
+
+tmtest -q - <<-EOL
+	echo Howdy 1>&2
+	STDERR: -n
+	Howdy
+
+EOL
+STDOUT: 
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Modified: TRUNK/test/03-results/20-Modify.test
===================================================================
--- TRUNK/test/03-results/20-Modify.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/20-Modify.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -3,7 +3,8 @@
 
 tmtest -q - <<-EOL
 	echo Howdy
-	MODIFY : s/Howdy/HOWDY/
+	MODIFY:
+      s/Howdy/HOWDY/
 	STDOUT :
 	HOWDY
 EOL

Modified: TRUNK/test/03-results/21-Modify.test
===================================================================
--- TRUNK/test/03-results/21-Modify.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/03-results/21-Modify.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -3,9 +3,9 @@
 
 tmtest -q - <<-EOL
 	echo Howdy
-	MODIFY :
+	MODIFY:
 		s/Howdy/HOWDY/
-	STDOUT :
+	STDOUT:
 	HOWDY
 EOL
 STDOUT:

Modified: TRUNK/test/04-diff/00-NoDiff.test
===================================================================
--- TRUNK/test/04-diff/00-NoDiff.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/04-diff/00-NoDiff.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -12,10 +12,4 @@
 	right output
 EOL
 
-
-MODIFY:
-    s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-    s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
 STDOUT:

Modified: TRUNK/test/04-diff/02-MultiDiff.test
===================================================================
--- TRUNK/test/04-diff/02-MultiDiff.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/04-diff/02-MultiDiff.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -21,8 +21,9 @@
 tmtest --all-files -d "$t1" "$t2"
 
 
-MODIFY:   s/^\-\-\-.*\/tmp\/tmtest.*/--- \/tmp\/testfile DATE TIME TZ/,
-          s/^\+\+\+.*/+++ - DATE TIME TZ/
+MODIFY:
+  s/^\-\-\-.*\/tmp\/tmtest.*/--- \/tmp\/testfile DATE TIME TZ/,
+  s/^\+\+\+.*/+++ - DATE TIME TZ/
 
 STDOUT:
 --- /tmp/testfile DATE TIME TZ

Modified: TRUNK/test/04-diff/09-MultiLevelDiff.test
===================================================================
--- TRUNK/test/04-diff/09-MultiLevelDiff.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/04-diff/09-MultiLevelDiff.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -59,8 +59,9 @@
 rm -rf t.test one two
 
 
-MODIFY:   s/^\-\-\- .*/--- TESTFILE DATE TIME TZ/,
-          s/^\+\+\+.*/+++ - DATE TIME TZ/
+MODIFY:
+  s/^\-\-\- .*/--- TESTFILE DATE TIME TZ/,
+  s/^\+\+\+.*/+++ - DATE TIME TZ/
 
 STDOUT:
 --- TESTFILE DATE TIME TZ

Modified: TRUNK/test/04-diff/10-Patch.test
===================================================================
--- TRUNK/test/04-diff/10-Patch.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/04-diff/10-Patch.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -22,7 +22,8 @@
 echo
 INDENT < "$tt"
 
-MODIFY: s/^patching .*/patching FILE/
+MODIFY:
+  s/^patching .*/patching FILE/
 
 STDOUT:
 patching FILE

Modified: TRUNK/test/04-diff/11-MultiPatch.test
===================================================================
--- TRUNK/test/04-diff/11-MultiPatch.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/04-diff/11-MultiPatch.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -36,7 +36,8 @@
 echo
 INDENT < "$tt3"
 
-MODIFY: s/^patching .*/patching FILE/
+MODIFY:
+  s/^patching .*/patching FILE/
 
 STDOUT:
 patching FILE

Modified: TRUNK/test/04-diff/12-MultiLevelPatch.test
===================================================================
--- TRUNK/test/04-diff/12-MultiLevelPatch.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/04-diff/12-MultiLevelPatch.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -69,7 +69,8 @@
 rm -rf t.test one two
 
 
-MODIFY: s/^patching .*/patching FILE/
+MODIFY:
+  s/^patching .*/patching FILE/
 
 STDOUT:
 patching FILE

Modified: TRUNK/test/04-diff/13-MultiLevelPatch.test
===================================================================
--- TRUNK/test/04-diff/13-MultiLevelPatch.test	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/04-diff/13-MultiLevelPatch.test	2006-02-27 23:00:34 UTC (rev 84)
@@ -70,7 +70,8 @@
 rm -rf ../t.test ../one ../two
 
 
-MODIFY: s/^patching .*/patching FILE/
+MODIFY:
+  s/^patching .*/patching FILE/
 
 STDOUT:
 patching FILE

Added: TRUNK/test/README
===================================================================
--- TRUNK/test/README	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test/README	2006-02-27 23:00:34 UTC (rev 84)
@@ -0,0 +1,30 @@
+NOTE: If you are looking for examples of testfiles, this is NOT the
+directory for you!  Due to the recursive nature of tmtest testing
+itself, many of these testfiles are very difficult to understand.
+
+See the examples directory instead.
+
+
+These are the test subcategories:
+
+00-cmdline: tests parsing command-line arguments
+    Mostly tests illegal command-line arguments.
+
+01-testfile: tests the parsing of test files.
+    Mostly tests illegal testfiles and ensures proper errors are printed.
+
+02-running: tests running the actual tests
+    Ensures that the test environment is set up properly.
+    For instance, checks that disabled tests are not run, the tmlib
+    calls are performed properly, etc.
+
+03-results: tests the results
+    Ensures that we compare the test results properly.
+    For instance, verifies that we handle results that don't
+    end in newlines, binary characters, etc. properly.
+
+04-diff: ensures diffing and patching works
+
+09-docs: tests that appear in our documentation.
+    This ensures that tmtest behaves exactly like our docs say it will.
+

Modified: TRUNK/test.c
===================================================================
--- TRUNK/test.c	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/test.c	2006-02-27 23:00:34 UTC (rev 84)
@@ -249,11 +249,22 @@
 }
 
 
-/** Prints the command section of the test suitable for how the test is being run.
+/**
+ * Prints the command section of the test suitable for how the test
+ * is being run.
  *
  * If the user is just running the test, nothing is printed.  If the
  * user is diffing or dumping the test, however, the modified command
  * section needs to be printed to the appropriate command.
+ *
+ * @param test The test being run.
+ * @param tok The type of data this is (from tfscan.h).  If 0 then 
+ *            this is the EOF and this routine won't be called anymore.
+ * @param ptr The data to write.  If tok==0 then ptr is undefined.
+ * @param len The amount of data to write.  If tok==0 then len==0.
+ *
+ * Hm, a year later it ooks like rewriting is a feature that will
+ * never need to be implemented...?
  */
 
 void rewrite_command_section(struct test *test, int tok, const char *ptr, int len)
@@ -306,6 +317,9 @@
             // the new SECTION token it marks it NEW.  Reattaching resets
             // the state to a command state, so we can just do that.
             tfscan_attach(&test->testfile);
+            // Now we're done dumping the command and the scanner
+            // is poised to return the correct section start to the
+            // next client.
             break;
         }
 
@@ -329,7 +343,7 @@
  */
 
 void compare_section_start(scanstate *cmpscan, int fd, pcrs_job *joblist,
-		matchval *mv, const char *filename, const char *sectionname)
+		matchval *mv, const char *filename, const char *sectionname, int nonl)
 {
     assert(!compare_in_progress(cmpscan));
 
@@ -348,7 +362,7 @@
 
     scanstate_reset(cmpscan);
     readfd_attach(cmpscan, fd);
-	compare_attach(cmpscan, mv, joblist);
+	compare_attach(cmpscan, mv, joblist, nonl);
 
     // we may want to check the token to see if there are any
     // special requests (like detabbing).
@@ -427,7 +441,8 @@
 
 	char buf[128];	// holds the pcrs command.  We will dynamically
 		// allocate a buffer if the entire substitution doesn't fit
-		// into this buffer.  The vast majority will be <30 chars.
+		// into this buffer.  The vast majority of substitutions will
+		// be less than 40 chars.
 
 	// skip any leading whitespace
 	while(isspace(*cp) && cp < ce) cp++;
@@ -482,6 +497,114 @@
 }
 
 
+/**
+ * Calls the given callback routine for each argument found.
+ *
+ * For now, we just split on whitespace.  In the future, if needed,
+ * this routine could be modified to handle \, ", ', etc just like bash.
+ */
+
+int parse_section_args(const char *tok, int toklen, const char *file, int line,
+        int (*argproc)(int index, const char *buf, const char *end, 
+            const char *file, int line, void *refcon),
+        void *refcon)
+{
+    const char *end = tok + toklen;
+    const char *cb, *ce;
+    int index = 0;
+    int val = 0;
+
+    ce = tok;
+    while(ce < end) {
+        cb = ce;
+        while(!isspace(*ce) && ce < end) {
+            ce++;
+        }
+
+        val = (*argproc)(index, cb, ce, file, line, refcon);
+        if(val) {
+            break;
+        }
+        index += 1;
+
+        while(isspace(*ce) && ce < end) {
+            ce++;
+        }
+    }
+
+    return val;
+}
+
+
+int constreq(const char *cp, const char *ce, const char *str)
+{
+    int len = strlen(str);
+
+    if(ce - cp != len) {
+        return 0;
+    }
+
+    if(memcmp(cp, str, len) != 0) {
+        return 0;
+    }
+
+    return 1;
+}
+
+
+int start_output_section_argproc(int i, const char *cp, const char *ce,
+        const char *file, int line, void *refcon)
+{
+    if(i == 0) {
+        // index == 0 is the name of this section
+        return 0;
+    }
+
+    // trim colons from arguments...  they can appear anywhere you want.
+    while(*cp == ':' && cp < ce) {
+        cp++;
+    }
+    while(ce[-1] == ':' && ce > cp) {
+        ce--;
+    }
+
+    if(constreq(cp,ce,"-n") || constreq(cp,ce,"--no-trailing-newline")) {
+        *(int*)refcon = 1;
+    } else if(cp < ce) {
+        fprintf(stderr, "%s line %d: unknown arguments \"%.*s\"\n",
+                file, line, ce-cp, cp);
+    }
+
+    return 0;
+}
+
+
+void start_output_section(struct test *test, const char *tok,
+        int toklen, scanstate *cmpscan, int fd, matchval *val,
+        const char *secname)
+{
+    int suppress_trailing_newline = 0;
+
+    parse_section_args(tok, toklen,
+            get_testfile_name(test), test->testfile.line,
+            start_output_section_argproc, 
+            (void*)&suppress_trailing_newline);
+
+    if(*val != match_unknown) {
+        // we've already obtained a value for this section!
+        fprintf(stderr, "%s line %d Error: duplicate %s "
+                "section.  Ignored.\n", get_testfile_name(test),
+                test->testfile.line, secname);
+        // as long as scanref == null, no comparison will happen.
+        assert(!cmpscan->scanref);
+        return;
+    }
+
+    compare_section_start(cmpscan, fd, test->eachline, val,
+        get_testfile_name(test), secname, suppress_trailing_newline);
+}
+
+
 /** This routine parses the tokens returned by scan_sections() and
  * compares them against the actual test results.  It stores the
  * results in test->match_stdout, match_stderr, and match_result.
@@ -489,6 +612,7 @@
  * The refcon needs to be an allocated scanner.  It need not be
  * attached to anything -- this routine will take care of attaching
  * and detaching it as needed.
+ *
  */
 
 void parse_section_compare(struct test *test, int sec,
@@ -497,7 +621,11 @@
     #define get_cur_state(ss)    ((int)(ss)->userref)
     #define set_cur_state(ss,x)  ((ss)->userref=(void*)(x))
 
+    // compscan is the comparison scanner -- it is used to diff the
+    // current output section (either stdout or stderr).
     scanstate *cmpscan = refcon;
+
+    // the section that we're entering (without the NEW flag attached)
     int newsec = EX_TOKEN(sec);
 
     if(get_cur_state(cmpscan) == 0) {
@@ -526,35 +654,26 @@
         set_cur_state(cmpscan, newsec);
         switch(get_cur_state(cmpscan)) {
             case exSTDOUT:
-				if(test->stdout_match == match_unknown) {
-					compare_section_start(cmpscan, test->outfd, test->eachline,
-							&test->stdout_match, get_testfile_name(test), "STDOUT");
-				} else {
-					fprintf(stderr, "%s line %d Error: duplicate STDOUT section.  Ignored.\n",
-							get_testfile_name(test), test->testfile.line);
-					// as long as scanref == null, no comparison will happen.
-					assert(!cmpscan->scanref);
-				}
+                start_output_section(test, datap, len, cmpscan,
+                        test->outfd, &test->stdout_match, "STDOUT");
                 break;
             case exSTDERR:
-				if(test->stderr_match == match_unknown) {
-					compare_section_start(cmpscan, test->errfd, test->eachline,
-							&test->stderr_match, get_testfile_name(test), "STDERR");
-				} else {
-					fprintf(stderr, "%s line %d Error: duplicate STDERR section.  Ignored.\n",
-							get_testfile_name(test), test->testfile.line);
-					// as long as scanref == null, no comparison will happen.
-					assert(!cmpscan->scanref);
-				}
+                start_output_section(test, datap, len, cmpscan,
+                        test->errfd, &test->stderr_match, "STDERR");
                 break;
             case exRESULT:
 				parse_exit_clause(test, datap, len);
                 break;
             case exMODIFY:
-				parse_modify_clause(test, skip_section_name(datap,len), datap+len);
+				parse_modify_clause(test, skip_section_name(datap,len),
+                        datap+len);
                 break;
             case exCOMMAND:
-                assert(!"Well, this is impossible.  How did you start a new command section??");
+                fprintf(stderr, "%s line %d Error: Well, this is impossible.  "
+                        "How did you start a new command section??\n",
+                        get_testfile_name(test), test->testfile.line);
+                // it should be harmless to continue but this definitely
+                // indicates a bug in the scanner.
                 break;
         }
     } else {
@@ -568,9 +687,10 @@
                 break;
             case exRESULT:
 				if(contains_nws(datap, len)) {
-					fprintf(stderr, "%s line %d Error: RESULT clause contains garbage.\n",
+					fprintf(stderr, "%s line %d Error: RESULT clause "
+                            "contains garbage.\n",
 							get_testfile_name(test), test->testfile.line);
-					//exit(10);
+                    // Harmless to continue.  The testfile needs to be fixed.
 				}
                 break;
             case exMODIFY:
@@ -839,26 +959,46 @@
 void parse_section_output(struct test *test, int sec,
         const char *datap, int len, void *refcon)
 {
+    int *needs_nl = (int*)refcon;
+
     assert(sec >= 0);
 
+    if(sec & exNEW) {
+        // check to see if previous section needs a newline appended.
+        if(*needs_nl) {
+            write_strconst(test->rewritefd, "\n");
+        }
+
+        *needs_nl = 0;
+    }
+
     switch(sec) {
         case 0:
-            // don't need to worry about eof
+            if(*needs_nl) {
+                write_strconst(test->rewritefd, "\n");
+            }
             break;
 
         case exSTDOUT|exNEW:
+            parse_section_args(datap, len,
+                    get_testfile_name(test), test->testfile.line,
+                    start_output_section_argproc, needs_nl);
+            write(test->rewritefd, datap, len);
+            write_file(test->rewritefd, test->outfd, test->eachline);
             test->stdout_match = match_yes;
-			write_strconst(test->rewritefd, "STDOUT:\n");
-            write_file(test->rewritefd, test->outfd, test->eachline);
             break;
         case exSTDOUT:
             // ignore all data in the expected stdout.
             break;
 
         case exSTDERR|exNEW:
+            parse_section_args(datap, len,
+                    get_testfile_name(test), test->testfile.line,
+                    start_output_section_argproc, needs_nl);
+            write(test->rewritefd, datap, len);
+            write_file(test->rewritefd, test->errfd, test->eachline);
             test->stderr_match = match_yes;
-			write_strconst(test->rewritefd, "STDERR:\n");
-            write_file(test->rewritefd, test->errfd, test->eachline);
+            break;
         case exSTDERR:
             // ignore all data in the expected stderr
             break;
@@ -867,7 +1007,6 @@
             test->exitno_match = match_yes;
             write_exit_no(test->rewritefd, test->exitno);
             break;
-
         case exRESULT:
             // allow random garbage in result section to pass
             write(test->rewritefd, datap, len);
@@ -877,7 +1016,6 @@
             parse_modify_clause(test, skip_section_name(datap,len), datap+len);
             write(test->rewritefd, datap, len);
             break;
-
         case exMODIFY:
             // parse modify sections and still print them.
             parse_modify_clause(test, datap, datap+len);
@@ -912,6 +1050,8 @@
 
 void dump_results(struct test *test)
 {
+    int tempref = 0;
+
 	if(was_aborted(test->status)) {
 		dump_reason(test, "was aborted");
 		test->aborted = 1;
@@ -943,7 +1083,7 @@
     // ensure that we haven't yet parsed any modify sections.
     assert(!test->eachline);
 
-    scan_sections(test, &test->testfile, parse_section_output, NULL);
+    scan_sections(test, &test->testfile, parse_section_output, &tempref);
 
     // if any sections haven't been output, but they differ from
     // the default, then they need to be output here at the end.

Modified: TRUNK/tfscan.c
===================================================================
--- TRUNK/tfscan.c	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/tfscan.c	2006-02-27 23:00:34 UTC (rev 84)
@@ -1,243 +1,205 @@
-/* Generated by re2c 0.5 on Sun Dec 18 12:25:00 2005 */
-
-/* tfscan.re
+/* tfscan.c
  * Scott Bronson
  * 30 Dec 2004
  *
- * Scanner for test files.
- * This file needs to be processed by re2c, http://re2c.org
+ * Scanner for test files.  This used to be a re2c scanner but
+ * I couldn't get it to work with no LF at the end of file.
  *
  * This file is covered by the MIT License.
  */
 
+// TOTEST: >8K token not containing a cr
+// STDOUT:, STDERR:, etc at the EOF with no data.
+// STDOUT at the beginning of the file.
+// keyword without a colon
+// 		NO NO NO keyword without a colon is still the keyword.
+// 		And a keyword without a NL is still the keyword.
+// 		But it must always start at the beginning of a new line.
+// exit clauses with invalid numbers
+// What happens with a MODIFY larger than BUFSIZ.
+// DOS/Mac/Unix line endings.
+// 		What happes when platform doesn't match the testfile?
+// 	Get rid of rewrite_command_section
+
+// NOTE: because we linebuffer the MODIFY clause, a single MODIFY
+// may not be larger than the BUFSIZ on your system (usually 8192 bytes).
+// Technically this is true of RESULT as well but when are you ever going
+// to run into an 8K result code?
+
 #include "tfscan.h"
 
 
 #define START(x) (ss->scanref=(void*)(x))
 
+#ifndef NULL
+#define NULL ((void*)0)
+#endif
 
-/* This scanner scans lines.  When it finds a line that begins
+
+int tfscan_tok_start(scanstate *ss);
+int tfscan_nontok_start(scanstate *ss);
+
+
+/*!re2c
+ 
+  // This is almost the scanner that this file implements, except that
+  // this file handles data at EOF correctly.
+
+WS      = [ \t];
+ANYN    = [\000-\377]\[\n];
+
+"STDOUT" WS* ":" ANYN* "\n"  { START(exSTDOUT); return exNEW|exSTDOUT; }
+"STDERR" WS* ":" ANYN* "\n"  { START(exSTDERR); return exNEW|exSTDERR; }
+"RESULT" WS* ":" ANYN* "\n"  { START(exRESULT); return exNEW|exRESULT; }
+"MODIFY" WS* ":" ANYN* "\n"  { START(exMODIFY); return exNEW|exMODIFY; }
+
+ANYN* "\n"                  { return (int)ss->scanref; }
+
+
+// What it does:
+// Returns exCOMMAND for all data chunks.
+// When it sees the start of a section, it returns exNEW|TOK
+// (i.e. (exNEW|exSTDOUT).  This tells you that the old section
+// has ended and a new one is starting.  Then it continues
+// returning exSTDOUT without the exNEW flag until another
+// seciton starts.
+
+*/
+
+
+
+static int scan_to_end_of_keyword(scanstate *ss, int tok)
+{
+	// We assume that we're immediately at the end of a keyword
+	// section.  The first six bytes just guarantees the keyword.
+
+	// skip all characters up to the final nl.
+
+	while(*YYCURSOR != '\r' && *YYCURSOR != '\n') {
+		YYCURSOR++;
+		if(YYCURSOR >= YYLIMIT) {
+			break;
+		}
+	}
+
+	if(*YYCURSOR == '\r') YYCURSOR++;
+	if(*YYCURSOR == '\n') YYCURSOR++;
+
+    ss->line += 1;
+
+	START(tok);
+	return exNEW|tok;
+}
+
+
+/* When it finds a line that begins
  * with a new section, it returns the token name of that section
  * with the exNEW flag turned on.  After that, it returns each
  * line in the section with the token's identifier.  Then, when it
  * finds a new section, you get a exNEW+TOKEN of the new section.
  */
 
-int tfscan_start(scanstate *ss)
+int tfscan_tok_start(scanstate *ss)
 {
     scanner_enter(ss);
-    inc_line(ss);
 
-{
-	YYCTYPE yych;
-	unsigned int yyaccept;
-	goto yy0;
-yy1:	++YYCURSOR;
-yy0:
-	if((YYLIMIT - YYCURSOR) < 6) YYFILL(6);
-	yych = *YYCURSOR;
-	switch(yych){
-	case '\n':	goto yy7;
-	case 'M':	goto yy4;
-	case 'R':	goto yy3;
-	case 'S':	goto yy2;
-	default:	goto yy5;
+    // if we can read at least 8 more bytes from the current buffer,
+    // we won't bother reloading it.  This should cut down drastically
+    // on the number of small reads we make.
+	if(YYCURSOR+8 >= YYLIMIT) {
+		int r = (*ss->read)(ss);
+		// if there was an error, return an error token.
+		if(r < 0) return r;
+		// Only if we're _completely_ out of data, return eof.
+		// (this is why we can't use re2c for this scanner)
+		if(ss->token >= ss->limit) return 0;
 	}
-yy2:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy29;
-	default:	goto yy6;
-	}
-yy3:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy19;
-	default:	goto yy6;
-	}
-yy4:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy9;
-	default:	goto yy6;
-	}
-yy5:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy6;
-yy6:	switch(yych){
-	case '\n':	goto yy7;
-	default:	goto yy5;
-	}
-yy7:	yych = *++YYCURSOR;
-	goto yy8;
-yy8:
 
-	{ return (int)ss->scanref; }
-yy9:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy10;
-	default:	goto yy6;
-	}
-yy10:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy11;
-	default:	goto yy6;
-	}
-yy11:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'F':	goto yy12;
-	default:	goto yy6;
-	}
-yy12:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'Y':	goto yy13;
-	default:	goto yy6;
-	}
-yy13:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy14;
-yy14:	switch(yych){
-	case '\t':	case ' ':	goto yy13;
-	case '\n':	goto yy7;
-	case ':':	goto yy15;
-	default:	goto yy5;
-	}
-yy15:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy16;
-yy16:	switch(yych){
-	case '\n':	goto yy17;
-	default:	goto yy15;
-	}
-yy17:	yych = *++YYCURSOR;
-	goto yy18;
-yy18:
+	// At this point in the scanner, we know that we are at the beginning
+    // of a line (previous character was either start-of-file or \n).
+	// So check to see if there's a token.
 
-	{ START(exMODIFY); return exNEW|exMODIFY; }
-yy19:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'S':	goto yy20;
-	default:	goto yy6;
+	if(YYCURSOR + 8 < YYLIMIT) {
+		// There's enough data in this buffer to contain a keyword.
+		// If there are less than 8 bytes in the buffer then it means
+		// that we're 7 bytes from the EOF and there's no chance that
+		// there's another keyword to scan.  (6 bytes for the keyword,
+		// 1 byte for the colon, one byte for the newline).
+		switch(*YYCURSOR) {
+			case 'S':
+				if(YYCURSOR[1] == 'T' && YYCURSOR[2] == 'D') {
+					if(YYCURSOR[3]=='O' && YYCURSOR[4]=='U' && YYCURSOR[5]=='T') {
+						return scan_to_end_of_keyword(ss, exSTDOUT);
+					}
+					if(YYCURSOR[3]=='E' && YYCURSOR[4]=='R' && YYCURSOR[5]=='R') {
+						return scan_to_end_of_keyword(ss, exSTDERR);
+					}
+				}
+				// else it wasn't a token so we can just keep scanning.
+				break;
+			case 'R':
+				if(YYCURSOR[1]=='E' && YYCURSOR[2]=='S' &&
+					YYCURSOR[3]=='U' && YYCURSOR[4]=='L' && YYCURSOR[5]=='T')
+				{
+					return scan_to_end_of_keyword(ss, exRESULT);
+				}
+				break;
+			case 'M':
+				if(YYCURSOR[1]=='O' && YYCURSOR[2]=='D' &&
+					YYCURSOR[3]=='I' && YYCURSOR[4]=='F' && YYCURSOR[5]=='Y')
+				{
+					return scan_to_end_of_keyword(ss, exMODIFY);
+				}
+				break;
+			default:
+				break;
+		}
 	}
-yy20:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy21;
-	default:	goto yy6;
-	}
-yy21:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'L':	goto yy22;
-	default:	goto yy6;
-	}
-yy22:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy23;
-	default:	goto yy6;
-	}
-yy23:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy24;
-yy24:	switch(yych){
-	case '\t':	case ' ':	goto yy23;
-	case '\n':	goto yy7;
-	case ':':	goto yy25;
-	default:	goto yy5;
-	}
-yy25:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy26;
-yy26:	switch(yych){
-	case '\n':	goto yy27;
-	default:	goto yy25;
-	}
-yy27:	yych = *++YYCURSOR;
-	goto yy28;
-yy28:
 
-	{ START(exRESULT); return exNEW|exRESULT; }
-yy29:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy30;
-	default:	goto yy6;
+	// So there wasn't a keyword at this point in the buffer.
+	// We just treat it as random data.  Since we haven't moved the
+    // cursor we can just call straight into the nontok routine.
+	ss->state = tfscan_nontok_start;
+	return tfscan_nontok_start(ss);
+}
+
+
+int tfscan_nontok_start(scanstate *ss)
+{
+	scanner_enter(ss);
+
+	if(YYCURSOR >= YYLIMIT) {
+		int r = (*ss->read)(ss);
+		// if there was an error, return an error token.
+		if(r < 0) return r;
+		// if we're completely out of data, return eof.
+		// (this is why we can't use re2c for this scanner)
+		if(ss->token >= ss->limit) return 0;
 	}
-yy30:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy31;
-	case 'O':	goto yy32;
-	default:	goto yy6;
-	}
-yy31:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy40;
-	default:	goto yy6;
-	}
-yy32:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy33;
-	default:	goto yy6;
-	}
-yy33:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy34;
-	default:	goto yy6;
-	}
-yy34:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy35;
-yy35:	switch(yych){
-	case '\t':	case ' ':	goto yy34;
-	case '\n':	goto yy7;
-	case ':':	goto yy36;
-	default:	goto yy5;
-	}
-yy36:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy37;
-yy37:	switch(yych){
-	case '\n':	goto yy38;
-	default:	goto yy36;
-	}
-yy38:	yych = *++YYCURSOR;
-	goto yy39;
-yy39:
 
-	{ START(exSTDOUT); return exNEW|exSTDOUT; }
-yy40:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy41;
-	default:	goto yy6;
+	// Since it's impossible to have a token at this point so we
+	// scan forward to the next CR/LF.
+	while(YYCURSOR < YYLIMIT) {
+		if(*YYCURSOR == '\r' || *YYCURSOR == '\n') break;
+		YYCURSOR++;
 	}
-yy41:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy42;
-yy42:	switch(yych){
-	case '\t':	case ' ':	goto yy41;
-	case '\n':	goto yy7;
-	case ':':	goto yy43;
-	default:	goto yy5;
+	if(YYCURSOR >= YYLIMIT) {
+		// We have to assume that we previously read as much data as
+		// possible.  So the entire buffer is just data with no tokens
+		// and no CR/LF.
+		return (int)ss->scanref;
 	}
-yy43:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy44;
-yy44:	switch(yych){
-	case '\n':	goto yy45;
-	default:	goto yy43;
-	}
-yy45:	yych = *++YYCURSOR;
-	goto yy46;
-yy46:
 
-	{ START(exSTDERR); return exNEW|exSTDERR; }
-}
+	if(*YYCURSOR == '\r') YYCURSOR++;
+	if(*YYCURSOR == '\n') YYCURSOR++;
 
+    ss->line += 1;
 
+	// We have potential for finding a token at this point.
+	ss->state = tfscan_tok_start;
+	return (int)ss->scanref;
 }
+	
 
 
 /** Prepares the given scanner to scan a testfile.
@@ -250,9 +212,50 @@
 {
     if(ss) {
         START(exCOMMAND);
-        ss->state = tfscan_start;
+        ss->state = tfscan_tok_start;
     }
 
     return ss;
 }
 
+/*
+
+SOME MORE THOUGHTS ON SCANNING:
+
+
+We know we're at the beginning of the buffer or immediately
+after a newline.
+	Do we have enough data for a keyword?
+		No: fill buffer with more data.
+	We know we have enough data for a keyword.  Use strstr.
+	
+See if a keyword is here.
+If 
+
+
+So what's the problem?
+	Read might return:
+		error, just return error code as negative number.
+		0, eof.
+			If we have more data in the buffer, we need to make sure
+			to return that data.
+			(actaully, with re2c, that's not the case.  It screws up the
+			last token in the file unless the file ends on a token delimiter).
+			- If there's no more data in the buffer then we just return 0.
+		positive number: we read data.
+
+So the problem is that re2c scanners can't handle it if the file doesn't
+end on a token delim.  We can't return if we hit eol and haven't scanned
+more data even if there's more data in the buffer.  The stupid re2c
+scanner will just start scanning in the garbage past the end of the buffer.
+Sigh.
+
+That means I can't use it for the testfile scanner.
+
+That furthermore means that I can't use YYFILL on the non-broken scanner.
+I should probably add a different macro that can be used everywhere,
+zero-length reads (as in a network packet), file ending with a non-delim
+character, etc.
+
+*/
+

Modified: TRUNK/tfscan.h
===================================================================
--- TRUNK/tfscan.h	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/tfscan.h	2006-02-27 23:00:34 UTC (rev 84)
@@ -1,4 +1,4 @@
-/* tfscan.h
+/* tfscan.h (testfile scanner)
  * Scott Bronson
  */
 
@@ -33,7 +33,7 @@
 
 #define EX_TOKEN(x) ((x)&0xFF)
 #define EX_ISNEW(x) ((x)&exNEW)
-#define is_command_token(x) (EX_TOKEN(x)>=exCOMMAND && EX_TOKEN(x)<ex_COMMAND_TOKEN_END)
+#define is_command_token(x) (EX_TOKEN(x)>=exCOMMAND && EX_TOKEN(x)<exCOMMAND_TOKEN_END)
 #define is_section_token(x) (EX_TOKEN(x)>=exSTDOUT && EX_TOKEN(x)<exRESULT_TOKEN_END)
 
 scanstate* tfscan_attach(scanstate *ss);

Deleted: TRUNK/tfscan.re
===================================================================
--- TRUNK/tfscan.re	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/tfscan.re	2006-02-27 23:00:34 UTC (rev 84)
@@ -1,60 +0,0 @@
-/* tfscan.re
- * Scott Bronson
- * 30 Dec 2004
- *
- * Scanner for test files.
- * This file needs to be processed by re2c, http://re2c.org
- *
- * This file is covered by the MIT License.
- */
-
-#include "tfscan.h"
-
-
-#define START(x) (ss->scanref=(void*)(x))
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a new section, it returns the token name of that section
- * with the exNEW flag turned on.  After that, it returns each
- * line in the section with the token's identifier.  Then, when it
- * finds a new section, you get a exNEW+TOKEN of the new section.
- */
-
-int tfscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    inc_line(ss);
-
-/*!re2c
-
-WS      = [ \t];
-ANYN    = [\000-\377]\[\n];
-
-"STDOUT" WS* ":" ANYN* "\n"  { START(exSTDOUT); return exNEW|exSTDOUT; }
-"STDERR" WS* ":" ANYN* "\n"  { START(exSTDERR); return exNEW|exSTDERR; }
-"RESULT" WS* ":" ANYN* "\n"  { START(exRESULT); return exNEW|exRESULT; }
-"MODIFY" WS* ":" ANYN* "\n"  { START(exMODIFY); return exNEW|exMODIFY; }
-
-ANYN* "\n"                  { return (int)ss->scanref; }
-
-*/
-}
-
-
-/** Prepares the given scanner to scan a testfile.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* tfscan_attach(scanstate *ss)
-{
-    if(ss) {
-        START(exCOMMAND);
-        ss->state = tfscan_start;
-    }
-
-    return ss;
-}
-

Modified: TRUNK/tmtest.conf
===================================================================
--- TRUNK/tmtest.conf	2005-12-21 02:17:48 UTC (rev 83)
+++ TRUNK/tmtest.conf	2006-02-27 23:00:34 UTC (rev 84)
@@ -38,7 +38,7 @@
 # This means that while the test is running, any executables in this
 # directory will take priority over similarly-named executables anywhere
 # else (like /usr/bin or ~/bin).  This ensures that we lauch the unstable
-# copy of tmtest to handle each test.
+# copy of tmtest to handle each subtest.
 
 PATH="$MYDIR:$PATH";
 
@@ -54,3 +54,10 @@
 
 args="--config=$MYPATH/test/tmtest.sub.conf"
 
+
+# This allows us to run tests without installing tmtest first.
+# (todo: will this cause problems if you DO have a currently-installed
+# tmtest?)
+
+. tmlib.sh
+





From tmtest-commits at berlios.de  Tue Feb 28 00:07:52 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 00:07:52 +0100
Subject: [Tmtest-commits] [85] TRUNK: Make a simple rename, break the build.
Message-ID: <200602272307.k1RN7qBj008552@sheep.berlios.de>

Revision: 85
Author:   bronson
Date:     2006-02-28 00:07:50 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Make a simple rename, break the build.  Typical.
Also check in the scanner generated by a much newer re2c.

Modified Paths:
--------------
    TRUNK/stscan.c
    TRUNK/stscan.re
Modified: TRUNK/stscan.c
===================================================================
--- TRUNK/stscan.c	2006-02-27 23:00:34 UTC (rev 84)
+++ TRUNK/stscan.c	2006-02-27 23:07:50 UTC (rev 85)
@@ -1,4 +1,4 @@
-/* Generated by re2c 0.5 on Sun Dec 18 12:25:01 2005 */
+/* Generated by re2c 0.9.10 on Mon Feb 27 18:07:08 2006 */
 
 /* stscan.re
  * Scott Bronson
@@ -24,18 +24,19 @@
 int stscan_start(scanstate *ss)
 {
     scanner_enter(ss);
-    inc_line(ss);
+    scan_inc_line(ss);
 
+
+
 {
 	YYCTYPE yych;
-	unsigned int yyaccept;
 	goto yy0;
-yy1:	++YYCURSOR;
+	++YYCURSOR;
 yy0:
 	if((YYLIMIT - YYCURSOR) < 8) YYFILL(8);
 	yych = *YYCURSOR;
 	switch(yych){
-	case '\n':	goto yy10;
+	case 0x0A:	goto yy10;
 	case 'A':	goto yy7;
 	case 'C':	goto yy3;
 	case 'D':	goto yy6;
@@ -80,14 +81,15 @@
 	yych = *YYCURSOR;
 	goto yy9;
 yy9:	switch(yych){
-	case '\n':	goto yy10;
+	case 0x0A:	goto yy10;
 	default:	goto yy8;
 	}
-yy10:	yych = *++YYCURSOR;
+yy10:	++YYCURSOR;
 	goto yy11;
 yy11:
 
-	{ return stGARBAGE; }
+{ return stGARBAGE; }
+
 yy12:	yych = *++YYCURSOR;
 	switch(yych){
 	case 'O':	goto yy13;
@@ -118,8 +120,8 @@
 	yych = *YYCURSOR;
 	goto yy18;
 yy18:	switch(yych){
-	case '\t':	case ' ':	goto yy17;
-	case '\n':	goto yy10;
+	case 0x09:	case ' ':	goto yy17;
+	case 0x0A:	goto yy10;
 	case ':':	goto yy19;
 	default:	goto yy8;
 	}
@@ -128,14 +130,15 @@
 	yych = *YYCURSOR;
 	goto yy20;
 yy20:	switch(yych){
-	case '\n':	goto yy21;
+	case 0x0A:	goto yy21;
 	default:	goto yy19;
 	}
-yy21:	yych = *++YYCURSOR;
+yy21:	++YYCURSOR;
 	goto yy22;
 yy22:
 
-	{ return stABORTED; }
+{ return stABORTED; }
+
 yy23:	yych = *++YYCURSOR;
 	switch(yych){
 	case 'S':	goto yy33;
@@ -153,22 +156,23 @@
 	}
 yy26:	yych = *++YYCURSOR;
 	switch(yych){
-	case '\t':	case ' ':	goto yy29;
-	case '\n':	goto yy27;
+	case 0x09:	case ' ':	goto yy29;
+	case 0x0A:	goto yy27;
 	default:	goto yy8;
 	}
-yy27:	yych = *++YYCURSOR;
+yy27:	++YYCURSOR;
 	goto yy28;
 yy28:
 
-	{ return stDONE; }
+{ return stDONE; }
+
 yy29:	++YYCURSOR;
 	if(YYLIMIT == YYCURSOR) YYFILL(1);
 	yych = *YYCURSOR;
 	goto yy30;
 yy30:	switch(yych){
-	case '\t':	case ' ':	goto yy29;
-	case '\n':	goto yy27;
+	case 0x09:	case ' ':	goto yy29;
+	case 0x0A:	goto yy27;
 	default:	goto yy31;
 	}
 yy31:	++YYCURSOR;
@@ -176,7 +180,7 @@
 	yych = *YYCURSOR;
 	goto yy32;
 yy32:	switch(yych){
-	case '\n':	goto yy27;
+	case 0x0A:	goto yy27;
 	default:	goto yy31;
 	}
 yy33:	yych = *++YYCURSOR;
@@ -209,8 +213,8 @@
 	yych = *YYCURSOR;
 	goto yy39;
 yy39:	switch(yych){
-	case '\t':	case ' ':	goto yy38;
-	case '\n':	goto yy10;
+	case 0x09:	case ' ':	goto yy38;
+	case 0x0A:	goto yy10;
 	case ':':	goto yy40;
 	default:	goto yy8;
 	}
@@ -219,14 +223,15 @@
 	yych = *YYCURSOR;
 	goto yy41;
 yy41:	switch(yych){
-	case '\n':	goto yy42;
+	case 0x0A:	goto yy42;
 	default:	goto yy40;
 	}
-yy42:	yych = *++YYCURSOR;
+yy42:	++YYCURSOR;
 	goto yy43;
 yy43:
 
-	{ return stDISABLED; }
+{ return stDISABLED; }
+
 yy44:	yych = *++YYCURSOR;
 	switch(yych){
 	case 'N':	goto yy45;
@@ -257,8 +262,8 @@
 	yych = *YYCURSOR;
 	goto yy50;
 yy50:	switch(yych){
-	case '\t':	case ' ':	goto yy49;
-	case '\n':	goto yy10;
+	case 0x09:	case ' ':	goto yy49;
+	case 0x0A:	goto yy10;
 	case ':':	goto yy51;
 	default:	goto yy8;
 	}
@@ -267,14 +272,15 @@
 	yych = *YYCURSOR;
 	goto yy52;
 yy52:	switch(yych){
-	case '\n':	goto yy53;
+	case 0x0A:	goto yy53;
 	default:	goto yy51;
 	}
-yy53:	yych = *++YYCURSOR;
+yy53:	++YYCURSOR;
 	goto yy54;
 yy54:
 
-	{ return stRUNNING; }
+{ return stRUNNING; }
+
 yy55:	yych = *++YYCURSOR;
 	switch(yych){
 	case 'E':	goto yy56;
@@ -302,22 +308,23 @@
 	}
 yy60:	yych = *++YYCURSOR;
 	switch(yych){
-	case '\t':	case ' ':	goto yy63;
-	case '\n':	goto yy61;
+	case 0x09:	case ' ':	goto yy63;
+	case 0x0A:	goto yy61;
 	default:	goto yy8;
 	}
-yy61:	yych = *++YYCURSOR;
+yy61:	++YYCURSOR;
 	goto yy62;
 yy62:
 
-	{ return stPREPARE; }
+{ return stPREPARE; }
+
 yy63:	++YYCURSOR;
 	if(YYLIMIT == YYCURSOR) YYFILL(1);
 	yych = *YYCURSOR;
 	goto yy64;
 yy64:	switch(yych){
-	case '\t':	case ' ':	goto yy63;
-	case '\n':	goto yy61;
+	case 0x09:	case ' ':	goto yy63;
+	case 0x0A:	goto yy61;
 	default:	goto yy65;
 	}
 yy65:	++YYCURSOR;
@@ -325,7 +332,7 @@
 	yych = *YYCURSOR;
 	goto yy66;
 yy66:	switch(yych){
-	case '\n':	goto yy61;
+	case 0x0A:	goto yy61;
 	default:	goto yy65;
 	}
 yy67:	yych = *++YYCURSOR;
@@ -353,8 +360,8 @@
 	yych = *YYCURSOR;
 	goto yy72;
 yy72:	switch(yych){
-	case '\t':	case ' ':	goto yy71;
-	case '\n':	goto yy10;
+	case 0x09:	case ' ':	goto yy71;
+	case 0x0A:	goto yy10;
 	case ':':	goto yy73;
 	default:	goto yy8;
 	}
@@ -363,14 +370,15 @@
 	yych = *YYCURSOR;
 	goto yy74;
 yy74:	switch(yych){
-	case '\n':	goto yy75;
+	case 0x0A:	goto yy75;
 	default:	goto yy73;
 	}
-yy75:	yych = *++YYCURSOR;
+yy75:	++YYCURSOR;
 	goto yy76;
 yy76:
 
-	{ return stCONFIG; }
+{ return stCONFIG; }
+
 yy77:	yych = *++YYCURSOR;
 	switch(yych){
 	case 'A':	goto yy78;
@@ -388,22 +396,23 @@
 	}
 yy80:	yych = *++YYCURSOR;
 	switch(yych){
-	case '\t':	case ' ':	goto yy83;
-	case '\n':	goto yy81;
+	case 0x09:	case ' ':	goto yy83;
+	case 0x0A:	goto yy81;
 	default:	goto yy8;
 	}
-yy81:	yych = *++YYCURSOR;
+yy81:	++YYCURSOR;
 	goto yy82;
 yy82:
 
-	{ return stSTART; }
+{ return stSTART; }
+
 yy83:	++YYCURSOR;
 	if(YYLIMIT == YYCURSOR) YYFILL(1);
 	yych = *YYCURSOR;
 	goto yy84;
 yy84:	switch(yych){
-	case '\t':	case ' ':	goto yy83;
-	case '\n':	goto yy81;
+	case 0x09:	case ' ':	goto yy83;
+	case 0x0A:	goto yy81;
 	default:	goto yy85;
 	}
 yy85:	++YYCURSOR;
@@ -411,7 +420,7 @@
 	yych = *YYCURSOR;
 	goto yy86;
 yy86:	switch(yych){
-	case '\n':	goto yy81;
+	case 0x0A:	goto yy81;
 	default:	goto yy85;
 	}
 }

Modified: TRUNK/stscan.re
===================================================================
--- TRUNK/stscan.re	2006-02-27 23:00:34 UTC (rev 84)
+++ TRUNK/stscan.re	2006-02-27 23:07:50 UTC (rev 85)
@@ -22,7 +22,7 @@
 int stscan_start(scanstate *ss)
 {
     scanner_enter(ss);
-    inc_line(ss);
+    scan_inc_line(ss);
 
 /*!re2c
 





From tmtest-commits at berlios.de  Tue Feb 28 00:10:09 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 00:10:09 +0100
Subject: [Tmtest-commits] [86] "trunk" is the standard trunk, not "TRUNK"
Message-ID: <200602272310.k1RNA9YA008870@sheep.berlios.de>

Revision: 86
Author:   bronson
Date:     2006-02-28 00:10:08 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
"trunk" is the standard trunk, not "TRUNK"

Added Paths:
-----------
    trunk/
    trunk/BUGS
    trunk/CHANGES
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/compare.h
    trunk/examples/
    trunk/matchval.h
    trunk/re2c/
    trunk/stscan.c
    trunk/stscan.re
    trunk/test/
    trunk/test.c
    trunk/tfscan.c
    trunk/tfscan.h
    trunk/tmtest.conf

Removed Paths:
-------------
    TRUNK/
    trunk/BUGS
    trunk/CHANGES
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/compare.h
    trunk/matchval.h
    trunk/re2c/
    trunk/stscan.c
    trunk/stscan.re
    trunk/test/
    trunk/test.c
    trunk/tfscan.c
    trunk/tfscan.h
    trunk/tfscan.re
    trunk/tmtest.conf
    trunk/tutorial/
Copied: trunk (from rev 83, TRUNK)

Deleted: trunk/BUGS
===================================================================
--- TRUNK/BUGS	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/BUGS	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,38 +0,0 @@
-If you run tmtest -d on a disabled test, it produces a tiny diff with the
-word "Disabled" in its stderr.  If you blindly pipe this diff to patch,
-it will destroy the output section of your test file.  This is easy enough
-to fix -- just re-enable the test and patch it again.  This will be
-fixed in tmtest 2.2 when we parse the status file asynchronously.
-
-
-Bash Bugs:
-
-Bash3 has removed the ability to set LINENO, so you may see the
-wrong line number be printed if there's an error.  The workaround
-suggested by the Bash author is far too large and complex.
-Downgrading to Bash2 works much better.  I don't understand why
-this functionality was removed in the first place!
-
-
-The <<-EOL operator strips ALL tabs from the front of each line.
-This is bad because it means you can't nest heredocs:
-
-	cmd1 <<-EOL
-		cmd2 <<-EOL
-			cmd3
-		EOL
-	EOL
-
-The first heredoc flattens everything and then the EOLs get mixed up.
-What bash SHOULD do is discover the whitespace sequence indenting the
-first line of a heredoc, then remove that sequence from all subsequent
-lines.  If a line doesn't begin with exactly that sequence, then
-it is unchanged.  This would be much safer and more useful than just
-blowing away all tabs wholesale!
-
-
-Why does &> redirect both stdout and stderr to a file, but &| doesn't
-redirect both stdout and stderr to a pipe?
-
-Why is the unset command totally unrelated to the set command?
-

Copied: trunk/BUGS (from rev 85, TRUNK/BUGS)

Deleted: trunk/CHANGES
===================================================================
--- TRUNK/CHANGES	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/CHANGES	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,12 +0,0 @@
-- Get rid of all AUTHOR and DATE automation.  Too heavyhanded.
-- Standardized licensing: everything under my control is MIT, package is LGPL.
-- When installing locally, it's ~/.tmlib.sh instead of ~/share/tmtest/tmlib.sh
-- Bump to 0.92
-- install now installs config files too.
-- Added the --config option to override default config files.
-- Added timing information to test summary.  Disable with new -q option.
-- Created tmlib, a "standard library" for tests.
-- We now stop running all tests if any test aborts.  DISABLE stops the current
-  test but lets all other tests finish; ABORT stops testing altogether.
-- Tests now start with /tmp as the cwd, not the testdir.
-  The testdir is supplied in $TESTDIR (or $MYDIR inside the testfile)

Copied: trunk/CHANGES (from rev 85, TRUNK/CHANGES)

Deleted: trunk/Makefile
===================================================================
--- TRUNK/Makefile	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/Makefile	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,114 +0,0 @@
-# tmtest Makefile
-# Scott Bronson
-# 28 Dec 2004
-#
-# This software is distributed under the LGPL.  See COPYING for more.
-
-
-VERSION=0.92
-
-# override this when installing: "make install prefix=/usr/local"
-#prefix=/usr
-prefix=$(HOME)
-
-
-bindir=$(prefix)/bin
-lib_src=tmlib.sh
-
-ifeq ($(prefix), $(HOME))
-	libdir=$(prefix)
-	stdlib=$(libdir)/.tmlib.sh
-	conf_dst=$(HOME)/.tmtestrc
-else
-	libdir=$(prefix)/share/tmtest
-	stdlib=$(libdir)/tmlib.sh
-	conf_dst=/etc/tmtest.conf
-endif
-
-
-COPTS=-g -Wall -Werror
-
-# utilities:
-CSRC+=curdir.c qscandir.c pcrs.c rel2abs.c
-CHDR+=curdir.h qscandir.h pcrs.h rel2abs.h
-# scanner files
-CSRC+=re2c/read.c re2c/read-fd.c re2c/scan.c
-CHDR+=re2c/read.h re2c/read-fd.h re2c/scan.h
-# program files:
-CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c
-CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h matchval.h
-
-# It makes it rather hard to debug when Make deletes the intermediate files.
-INTERMED=stscan.c
-
-
-tmtest: $(CSRC) $(CHDR) template.c Makefile $(INTERMED)
-	$(CC) $(COPTS) $(CSRC) -lpcre template.c -o tmtest "-DVERSION=$(VERSION)"
-
-template.c: template.sh cstrfy Makefile
-	./cstrfy -n exec_template < template.sh > template.c
-
-%.c: %.re
-	re2c $(REOPTS) $< > $@
-	perl -pi -e 's/^\#line.*$$//' $@
-
-%.o: %.c
-	$(CC) -g -c $< -o $@
-
-
-test: tmtest
-	tmtest --config=./tmtest.conf test
-
-run: tmtest
-	./tmtest
-
-install: tmtest
-	install -d -m755 $(bindir)
-	install tmtest $(bindir)
-	install -d -m755 $(libdir)
-	install tmlib.sh $(stdlib)
-ifeq ($(wildcard $(conf_dst)),$(conf_dst))
-	# configuration already exists, don't overwrite it.
-	@echo "---> Not installing new config file over '$(conf_dst).'"
-	@echo "---> Please merge changes in 'sample.conf' by hand or run 'make uninstall' first."
-else
-	# global configuration file doesn't exist so install it
-	install sample.conf $(conf_dst)
-	@perl -pi -e 's/USER/$(shell whoami)/g' $(conf_dst)
-	@perl -pi -e 's:STDLIB:$(stdlib):g' $(conf_dst)
-endif
-
-# NOTE: This will remove the configuration file too!
-uninstall: tmtest
-	rm $(bindir)/tmtest
-	rm $(stdlib)
-ifeq ($(prefix), $(HOME))
-	rm $(HOME)/.tmtestrc
-else
-	rm /etc/tmtest.conf
-endif
-
-clean:
-	rm -f tmtest template.c tags
-
-# Ensure re2c is installed to regenerate the scanners before making distclean
-distclean: clean
-	rm -f stscan.[co]
-
-tags: $(CSRC) $(CHDR) $(INTERMED)
-	ctags -R
-
-doc:
-	doxygen
-	which pods2html > /dev/null || echo "You must install Pod::Tree off CPAN"
-	pods2html . docs/html
-	$(MAKE) graphs
-
-%.png: %.dot
-	dot -Tpng $< -o $@
-
-rediff:
-	diff ../oe/re2c/ re2c
-	
-reupdate:
-	ls re2c/*.[ch] | (ODIR=`pwd`; cd ../oe; xargs cp --target-directory $$ODIR/re2c)

Copied: trunk/Makefile (from rev 85, TRUNK/Makefile)

Deleted: trunk/TODO
===================================================================
--- TRUNK/TODO	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/TODO	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,103 +0,0 @@
-1.0:
-- Add to faq: limitation on line length when using MODIFY clause.
-  (MODIFY is memory-based, so a single line must fit into memory).
-  If you're working with big testfiles, don't use MODIFY.
-  - No, we fucking line buffer everything thanks to the scanner.
-  - I'd say it's time to hand-code the scanners so they don't
-    have to be line-buffered.  There's nothing we can do about MODIFY
-	of course.
-- Why is compare_continue not called??
-	Somehow we abandon the newline on the input buffer.
-	The problem is that the scanner REQUIRES a newline on the end.
-	    Shit, I wonder if it's time to just junk the scanner entirely.
-- what do we do when stdout is missing a newline at the end?
-  Test that both raw and modified work when stdout doesn't have a newline.
-  Check that diff works too.
-- Make "make test" work.
-- write tests for nesting testfiles with --config.
-        // If the user specifies a config file, we only check directories
-        // not above the given config file.  i.e. if user specifies
-        // "tmtest -c /a/b/cc /a/t/u/t.test", we will look for config files
-        // in /a/t/tmtest.conf and /a/t/u/tmtest.conf.
-- merge tmtestlib and tmtestrc.  They're now basically the same file.
-- get rid of all the exit(10) calls in test.c.  We need a better way to
-  abort the test.
-  should get rid of a whole bunch in main.c as well.
-  this should prevent us from dropping turds in /tmp all the time too.
-- Add the ability to specify test arguments on the command line.
-  I'm picturing something where VAR=val on the command line would be
-  inserted without change into the template.  That way you can use the
-  command line to override default settings in the testfile.
-  - This would allow us to test almost every test to ensure it
-    supports the --config argument (make them DISABLED or something).
-
-1.2:
-- stdin is all buggered up.  why is it that "cat" with no args will print
-  the rest of the test script?  And why is it that if you fork, diff freezes?
-  They're related problems I suspect.
-- Could take tests from tarfiles.  We would decompress the tarfile into
-  a temporary directory, run the test, and delete the tarfile.  This will
-  make it easier to maintain tests that all need to be run in a certain
-  directory hierarchy.
-- Tighten up printing a folder name when there are no testfiles in it.
-  No need for double spacing.
-- Change the I/O scheme to be event based.  Get rid of the tempfiles.
-  Convert to using the async io library.  Don't use temporary files.
-  This would allow us to recognize that the test is disabled before
-  producing a partial diff, blowing away output sections.
-  - I'd say it's time to hand-code the scanners so they don't
-    have to be line-buffered.  There's nothing we can do about MODIFY
-	of course.  But don't line-buffer if we don't have to.  Should
-	simplify things quite a bit to get rid of re2c.
-- Add the ability to run multiple tests from one testfile.
-  See tmtest 0.8 for a potential implementation of this.
-  All we'd need to add is a framework to notify the user that multiple
-  tests are in progress; bash can take care of the rest.
-- add the ability to run valgrind over each test and print success/failure
-  of that.  (gives deep valgrind coverage)
-  - One problem with this will be all the false warnings.
-- add gcov support so you can see what sort of coverage your tests provide.
-- Shouldn't run every test in a dir if the DISABLED directive is in a config
-  file.
-  Should discover what dir the DISABLED directive came from and refuse
-  to run anything below that.
-  - Yes, if a config file returns DISABLED, then that folder and all its
-    subfolders are skipped.  Just make the test itself return the DISABLED
-	command if you want testing to continue in that subfolder.
-
-?:
-- should probably indent stdout and stderr clauses two spaces.  otherwise
-  we might misinterpret STDOUT: and STDERR: in a stdout or stderr clause.
-  - True, but this is easy enough to mock with a MODIFY clause.  The
-    downside to this is that 
-- Provide some sort of automatable XML output.
-- allow multiple s/// expressions on a single line.  will probably require
-  modifications to pcrs_compile_command, so make it support buf/len at the
-  same time.  These might be non-trivial changes...
-- it's stupid to dup the str just to null-terminate it so it can be passed
-  to pcrs.  Modify pcrs to compile buffers too.
-
-????:
-- Unify the line modifier in compare.c and test.c.  It's hackish now.
-- There should be a way to repeatedly run a single test with only tiny
-  differences.  i.e. test all permeutations of DISABLE DISABLE:
-  DISABLED DISABLED:  Hopefully that will clean up 05-08-Disable/Abort.test
-- Add a timeout that will terminate stalled tests.  You can set the timeout in the config file.
-
-
-
-- Wow, the pcrs error messages suck.  Is there any way to improve them?
-  "(pcrs:) Syntax error while parsing command (-11)."
-
-
-maybe never:
-- Add STDOUT: trimws and STDERR: trimws - to trim whitespace from
-  the front of each output line.
-  I wanted to add this to simulate the "STDOUT=<<-EOL" heredoc sequence
-  of the original tests (that is nestable, unlinke Bash's.  But now I
-  realize that this problem is pretty much solved from the other direction.
-  Instead of removing indentation from the heredoc, simply add indentation
-  using a MODIFY section (as detailed in the FAQ).
-- add a CLEAR_EACHLINE or CLEAR_MODIFY option to to turn off all substitutions.
-  It would be easy to do.  I'm just not convinced that anyone would find it useful.
-

Copied: trunk/TODO (from rev 85, TRUNK/TODO)

Deleted: trunk/compare.c
===================================================================
--- TRUNK/compare.c	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/compare.c	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,283 +0,0 @@
-/* compare.c
- * Scott Bronson
- * 31 Dec 2004
- *
- * This file is distrubuted under the MIT License
- * See http://en.wikipedia.org/wiki/MIT_License for more.
- *
- *
- * File comparison.
- *
- * This uses all re2c's mechanisms for creating buffers and loading
- * them with data, but it's not an re2c scanner.
- *
- * Here's what you do:
- * - Create a scanstate that reads from one of the files (or
- *   whatever) that you want to compare and pass it to compare_start.
- * - Call compare_continue with any size data block from the other
- *   file you want to compare.  Keep calling until you're out of
- *   data.  Check compare_in_progress to see if it failed prematurely.
- * - Finally, when you're out of data in the other file, call
- *   compare_end.  It will verify that it's at eof on the first
- *   file.
- * - Read the final result from the matchval.
- *
- * Well, the line buffering for the pcrs library has utterly destroyed
- * the simplicity of this file.
- *
- */
-
-#include <string.h>
-#include "compare.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-
-
-typedef struct {
-	matchval *output;
-	pcrs_job *jobs;
-	const char *pbuf;
-	int pcursor;
-	int plimit;
-} compare_state;
-
-
-static int compare_fill(scanstate *ss)
-{
-    return (*ss->read)(ss);
-}
-
-
-static void compare_halt(scanstate *ss, matchval newval)
-{
-	compare_state *cmp = (compare_state*)ss->scanref;
-    *cmp->output = newval;
-	if(cmp->pbuf) free((char*)cmp->pbuf);
-	free(cmp);
-    ss->scanref = NULL;
-}
-
-
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *jobs)
-{
-	compare_state *cmp = malloc(sizeof(compare_state));
-	if(cmp == NULL) {
-		perror("compare_attach");
-		exit(10);
-	}
-	memset(cmp, 0, sizeof(compare_state));
-
-    *mv = match_inprogress;
-
-	cmp->output = mv;
-	cmp->jobs = jobs;
-	ss->scanref = cmp;
-}
-
-
-static void compare_continue_bytes(scanstate *ss, const char *ptr, int len)
-{
-    int n;
-
-    while(len > 0) {
-        n = ss->limit - ss->cursor;
-        if(!n) {
-            n = compare_fill(ss);
-            if(n < 0) {
-                // there was an error while trying to fill the buffer
-                // TODO: this should be propagated to the client somehow.
-                perror("compare_continue_bytes");
-                exit(10);
-            }
-            if(n == 0) {
-				// there's more input data but we're at eof.
-                compare_halt(ss, match_no);
-                return;
-            }
-        }
-
-        if(len < n) {
-            n = len;
-        }
-
-        // compare
-        if(memcmp(ptr, ss->cursor, n) != 0) {
-            compare_halt(ss, match_no);
-            return;
-        }
-        ptr += n;
-        ss->cursor += n;
-        len -= n;
-    }
-}
-
-
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize)
-{
-	char *old, *new;
-	int nsubs;
-	int cnt;
-
-	cnt = 0;
-	old = (char*)cp;
-	*newsize = ce - cp;
-
-	while(job) {
-		// Now, run the line through the substitutions.
-		nsubs = pcrs_execute(job, old, *newsize, &new, newsize);
-		if(nsubs < 0) {
-			fprintf(stderr, "error while substituting expr %d: %s (%d).\n",
-					cnt, pcrs_strerror(nsubs), nsubs);
-            if(new) {
-                free(new);
-                new = NULL;
-            }
-			break;
-		}
-
-		assert(strlen(new) == *newsize);
-
-		if(old != cp) {
-			// free the intermediate result.
-			free(old);
-		}
-		old = new;
-		job = job->next;
-		cnt += 1;
-	}
-
-    return new;
-}
-
-
-// This routine is hellish because neither stream is line buffered.
-// Therefore, we line buffer the file and compare in chunks against
-// the input.  "pbuf" is the substitution-modified buffer allocated
-// by the pcre library.
-
-static void compare_continue_lines(scanstate *ss, compare_state *cmp,
-		const char *ptr, size_t len)
-{
-	int n;
-	const char *p;
-    char *new;
-    size_t newsize;
-
-	while(len > 0) {
-		n = cmp->plimit - cmp->pcursor;
-		assert(n >= 0);
-		if(n) {
-			// there's more data in the pbuf.  use it for comparison.
-			if(len < n) n = len;
-			if(memcmp(ptr, cmp->pbuf+cmp->pcursor, n) != 0) {
-				compare_halt(ss, match_no);
-				return;
-			}
-			cmp->pcursor += n;
-			ptr += n;
-			len -= n;
-			assert(len >= 0);
-			if(!len) break;
-		}
-
-		// we've emptied the pbuf so we need to regenerate it.
-		// first see if there's anther line in the line buffer.
-		p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-		if(!p) {
-			// there's no newline in the buffer.  try to refill.
-			n = compare_fill(ss);
-			if(n < 0) {
-				// there was an error while trying to fill the buffer
-				// TODO: this should be propagated to the client somehow.
-				perror("compare_continue_lines");
-				exit(10);
-			}
-			if(n == 0) {
-				// there's more input data but we're at eof.
-				compare_halt(ss, match_no);
-				return;
-			}
-
-			p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-			if(!p) {
-				// we'll just have to treat the entire buffer as a full
-				// line and hope for the best.  Subtract one because
-				// the very next line will add one.
-				p = ss->limit - 1;
-			}
-		}
-
-		// move p past the newline so it's at the end of the current line.
-		p += 1;
-		new = substitute_string(cmp->jobs, ss->cursor, p, &newsize);
-        if(!new) {
-            // there must have been an error
-            compare_halt(ss, match_no);
-            return;
-        }
-
-        if(cmp->pbuf) free((char*)cmp->pbuf);
-        cmp->pbuf = new;
-        cmp->pcursor = 0;
-        cmp->plimit = newsize;
-		ss->cursor = p;
-	}
-}
-
-
-void compare_continue(scanstate *ss, const char *ptr, int len)
-{
-	compare_state *cmp = (compare_state*)ss->scanref;
-
-    if(!ss->scanref) {
-        // we already decided the files don't match
-        // so don't waste time comparing more.
-        return;
-    }
-
-	if(cmp->jobs) {
-		compare_continue_lines(ss, cmp, ptr, len);
-	} else {
-		compare_continue_bytes(ss, ptr, len);
-	}
-}
-
-
-void compare_end(scanstate *ss)
-{
-	compare_state *cmp = (compare_state*)ss->scanref;
-
-    if(!ss->scanref) {
-        // we already decided the files don't match
-        // so don't waste time comparing more.
-        return;
-    }
-
-	assert(cmp->pcursor <= cmp->plimit);
-	assert(ss->cursor <= ss->limit);
-
-	if(cmp->jobs) {
-		// if there's more data in the pbuf then fail.
-		if(cmp->plimit - cmp->pcursor != 0) {
-			compare_halt(ss, match_no);
-			return;
-		}
-	}
-
-	// if we have no data left in the scan buffer
-	if(ss->limit - ss->cursor == 0) {
-		// and our input file is at eof
-		if(compare_fill(ss) == 0) {
-			// then the two data streams match
-			compare_halt(ss, match_yes);
-			return;
-		}
-	}
-
-    // otherwise, they don't.
-    compare_halt(ss, match_no);
-}
-
-

Copied: trunk/compare.c (from rev 85, TRUNK/compare.c)

Deleted: trunk/compare.h
===================================================================
--- TRUNK/compare.h	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/compare.h	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,27 +0,0 @@
-/* compare.h
- * Scott Bronson
- * 31 Dec 2004
- *
- * File comparison prototypes.
- *
- * See compare.c for license.
- */
-
-#include "pcrs.h"
-#include "matchval.h"
-#include "re2c/scan.h"
-
-
-/** Returns zero if the compare has stopped (i.e. the files differed).
- */
-
-#define compare_in_progress(ss) ((ss)->scanref)
-
-
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *joblist);
-void compare_continue(scanstate *ss, const char *ptr, int len);
-void compare_end(scanstate *cmp);
-
-// no better place to put this for now...
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize);
-

Copied: trunk/compare.h (from rev 85, TRUNK/compare.h)

Copied: trunk/examples (from rev 85, TRUNK/examples)

Deleted: trunk/matchval.h
===================================================================
--- TRUNK/matchval.h	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/matchval.h	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,27 +0,0 @@
-/* matchval.h
- * Scott Bronson
- * 31 Dec 2004
- *
- */
-
-#ifndef MATCHVAL_H
-#define MATCHVAL_H
-
-
-/**
- * Simply a tristate that tells whether something
- *    - matches
- *    - doesn't match
- *    - hasn't been checked yet.
- */
-
-typedef enum {
-    match_inprogress = -2,
-    match_unknown = -1,
-    match_no = 0,
-    match_yes = 1,
-} matchval;
-
-
-#endif
-

Copied: trunk/matchval.h (from rev 85, TRUNK/matchval.h)

Copied: trunk/re2c (from rev 85, TRUNK/re2c)

Deleted: trunk/stscan.c
===================================================================
--- TRUNK/stscan.c	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/stscan.c	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,437 +0,0 @@
-/* Generated by re2c 0.5 on Sun Dec 18 12:25:01 2005 */
-
-/* stscan.re
- * Scott Bronson
- *
- * This file is covered by the MIT license.
- *
- * Scanner for status files files.
- * This file needs to be processed by re2c, http://re2c.org
- */
-
-#include "stscan.h"
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a recognized token, it returns that token with the text
- * of the entire line.  Otherwise, it returns stGARBAGE.
- *
- * Note that this scanner only returns complete lines.  If the file
- * doesn't end with a newline, then the last line will be lost.
- * I think.
- */
-
-int stscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    inc_line(ss);
-
-{
-	YYCTYPE yych;
-	unsigned int yyaccept;
-	goto yy0;
-yy1:	++YYCURSOR;
-yy0:
-	if((YYLIMIT - YYCURSOR) < 8) YYFILL(8);
-	yych = *YYCURSOR;
-	switch(yych){
-	case '\n':	goto yy10;
-	case 'A':	goto yy7;
-	case 'C':	goto yy3;
-	case 'D':	goto yy6;
-	case 'P':	goto yy4;
-	case 'R':	goto yy5;
-	case 'S':	goto yy2;
-	default:	goto yy8;
-	}
-yy2:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy77;
-	default:	goto yy9;
-	}
-yy3:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy67;
-	default:	goto yy9;
-	}
-yy4:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy55;
-	default:	goto yy9;
-	}
-yy5:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy44;
-	default:	goto yy9;
-	}
-yy6:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy23;
-	case 'O':	goto yy24;
-	default:	goto yy9;
-	}
-yy7:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'B':	goto yy12;
-	default:	goto yy9;
-	}
-yy8:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy9;
-yy9:	switch(yych){
-	case '\n':	goto yy10;
-	default:	goto yy8;
-	}
-yy10:	yych = *++YYCURSOR;
-	goto yy11;
-yy11:
-
-	{ return stGARBAGE; }
-yy12:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy13;
-	default:	goto yy9;
-	}
-yy13:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy14;
-	default:	goto yy9;
-	}
-yy14:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy15;
-	default:	goto yy9;
-	}
-yy15:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy16;
-	default:	goto yy9;
-	}
-yy16:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy17;
-	default:	goto yy9;
-	}
-yy17:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy18;
-yy18:	switch(yych){
-	case '\t':	case ' ':	goto yy17;
-	case '\n':	goto yy10;
-	case ':':	goto yy19;
-	default:	goto yy8;
-	}
-yy19:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy20;
-yy20:	switch(yych){
-	case '\n':	goto yy21;
-	default:	goto yy19;
-	}
-yy21:	yych = *++YYCURSOR;
-	goto yy22;
-yy22:
-
-	{ return stABORTED; }
-yy23:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'S':	goto yy33;
-	default:	goto yy9;
-	}
-yy24:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy25;
-	default:	goto yy9;
-	}
-yy25:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy26;
-	default:	goto yy9;
-	}
-yy26:	yych = *++YYCURSOR;
-	switch(yych){
-	case '\t':	case ' ':	goto yy29;
-	case '\n':	goto yy27;
-	default:	goto yy8;
-	}
-yy27:	yych = *++YYCURSOR;
-	goto yy28;
-yy28:
-
-	{ return stDONE; }
-yy29:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy30;
-yy30:	switch(yych){
-	case '\t':	case ' ':	goto yy29;
-	case '\n':	goto yy27;
-	default:	goto yy31;
-	}
-yy31:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy32;
-yy32:	switch(yych){
-	case '\n':	goto yy27;
-	default:	goto yy31;
-	}
-yy33:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy34;
-	default:	goto yy9;
-	}
-yy34:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'B':	goto yy35;
-	default:	goto yy9;
-	}
-yy35:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'L':	goto yy36;
-	default:	goto yy9;
-	}
-yy36:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy37;
-	default:	goto yy9;
-	}
-yy37:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy38;
-	default:	goto yy9;
-	}
-yy38:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy39;
-yy39:	switch(yych){
-	case '\t':	case ' ':	goto yy38;
-	case '\n':	goto yy10;
-	case ':':	goto yy40;
-	default:	goto yy8;
-	}
-yy40:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy41;
-yy41:	switch(yych){
-	case '\n':	goto yy42;
-	default:	goto yy40;
-	}
-yy42:	yych = *++YYCURSOR;
-	goto yy43;
-yy43:
-
-	{ return stDISABLED; }
-yy44:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy45;
-	default:	goto yy9;
-	}
-yy45:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy46;
-	default:	goto yy9;
-	}
-yy46:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy47;
-	default:	goto yy9;
-	}
-yy47:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy48;
-	default:	goto yy9;
-	}
-yy48:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'G':	goto yy49;
-	default:	goto yy9;
-	}
-yy49:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy50;
-yy50:	switch(yych){
-	case '\t':	case ' ':	goto yy49;
-	case '\n':	goto yy10;
-	case ':':	goto yy51;
-	default:	goto yy8;
-	}
-yy51:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy52;
-yy52:	switch(yych){
-	case '\n':	goto yy53;
-	default:	goto yy51;
-	}
-yy53:	yych = *++YYCURSOR;
-	goto yy54;
-yy54:
-
-	{ return stRUNNING; }
-yy55:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy56;
-	default:	goto yy9;
-	}
-yy56:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'P':	goto yy57;
-	default:	goto yy9;
-	}
-yy57:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy58;
-	default:	goto yy9;
-	}
-yy58:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy59;
-	default:	goto yy9;
-	}
-yy59:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy60;
-	default:	goto yy9;
-	}
-yy60:	yych = *++YYCURSOR;
-	switch(yych){
-	case '\t':	case ' ':	goto yy63;
-	case '\n':	goto yy61;
-	default:	goto yy8;
-	}
-yy61:	yych = *++YYCURSOR;
-	goto yy62;
-yy62:
-
-	{ return stPREPARE; }
-yy63:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy64;
-yy64:	switch(yych){
-	case '\t':	case ' ':	goto yy63;
-	case '\n':	goto yy61;
-	default:	goto yy65;
-	}
-yy65:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy66;
-yy66:	switch(yych){
-	case '\n':	goto yy61;
-	default:	goto yy65;
-	}
-yy67:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy68;
-	default:	goto yy9;
-	}
-yy68:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'F':	goto yy69;
-	default:	goto yy9;
-	}
-yy69:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy70;
-	default:	goto yy9;
-	}
-yy70:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'G':	goto yy71;
-	default:	goto yy9;
-	}
-yy71:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy72;
-yy72:	switch(yych){
-	case '\t':	case ' ':	goto yy71;
-	case '\n':	goto yy10;
-	case ':':	goto yy73;
-	default:	goto yy8;
-	}
-yy73:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy74;
-yy74:	switch(yych){
-	case '\n':	goto yy75;
-	default:	goto yy73;
-	}
-yy75:	yych = *++YYCURSOR;
-	goto yy76;
-yy76:
-
-	{ return stCONFIG; }
-yy77:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy78;
-	default:	goto yy9;
-	}
-yy78:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy79;
-	default:	goto yy9;
-	}
-yy79:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy80;
-	default:	goto yy9;
-	}
-yy80:	yych = *++YYCURSOR;
-	switch(yych){
-	case '\t':	case ' ':	goto yy83;
-	case '\n':	goto yy81;
-	default:	goto yy8;
-	}
-yy81:	yych = *++YYCURSOR;
-	goto yy82;
-yy82:
-
-	{ return stSTART; }
-yy83:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy84;
-yy84:	switch(yych){
-	case '\t':	case ' ':	goto yy83;
-	case '\n':	goto yy81;
-	default:	goto yy85;
-	}
-yy85:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy86;
-yy86:	switch(yych){
-	case '\n':	goto yy81;
-	default:	goto yy85;
-	}
-}
-
-
-}
-
-
-/** Prepares the given scanner to scan a status file.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* stscan_attach(scanstate *ss)
-{
-    if(ss) {
-        ss->state = stscan_start;
-    }
-
-    return ss;
-}
-

Copied: trunk/stscan.c (from rev 85, TRUNK/stscan.c)

Deleted: trunk/stscan.re
===================================================================
--- TRUNK/stscan.re	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/stscan.re	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,63 +0,0 @@
-/* stscan.re
- * Scott Bronson
- *
- * This file is covered by the MIT license.
- *
- * Scanner for status files files.
- * This file needs to be processed by re2c, http://re2c.org
- */
-
-#include "stscan.h"
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a recognized token, it returns that token with the text
- * of the entire line.  Otherwise, it returns stGARBAGE.
- *
- * Note that this scanner only returns complete lines.  If the file
- * doesn't end with a newline, then the last line will be lost.
- * I think.
- */
-
-int stscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    inc_line(ss);
-
-/*!re2c
-
-WS      = [ \t];
-ANYN    = [\000-\377]\[\n];
-NOARG   = "\n"|(WS+ ANYN* "\n");
-HASARG  = WS* ":" ANYN* "\n";
-
-"START"   NOARG     { return stSTART; }
-"CONFIG"  HASARG    { return stCONFIG; }
-"PREPARE" NOARG     { return stPREPARE; }
-"RUNNING" HASARG    { return stRUNNING; }
-"DONE"    NOARG     { return stDONE; }
-
-"ABORTED"  HASARG   { return stABORTED; }
-"DISABLED" HASARG   { return stDISABLED; }
-
-ANYN* "\n"          { return stGARBAGE; }
-
-*/
-}
-
-
-/** Prepares the given scanner to scan a status file.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* stscan_attach(scanstate *ss)
-{
-    if(ss) {
-        ss->state = stscan_start;
-    }
-
-    return ss;
-}
-

Copied: trunk/stscan.re (from rev 85, TRUNK/stscan.re)

Copied: trunk/test (from rev 85, TRUNK/test)

Deleted: trunk/test.c
===================================================================
--- TRUNK/test.c	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/test.c	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,1019 +0,0 @@
-/* test.c
- * 30 Dec 2004
- * Copyright (C) 2004 Scott Bronson
- * 
- * Contains the routines to check/diff/etc test output.
- *
- * This file is covered by the MIT license.
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <errno.h>
-
-// to get PATH_MAX:
-#include <dirent.h>
-
-#include "re2c/read-fd.h"
-
-#include "test.h"
-#include "stscan.h"
-#include "tfscan.h"
-#include "compare.h"
-#include "rusage.h"
-
-
-// This is the maximum line length for the eachline substitution.
-// Lines longer than this will be parsed as 2 separate lines.
-#define MAX_LINE_LENGTH BUFSIZ
-
-// utility function so you can say i.e. write_strconst(fd, "/");
-#define write_strconst(fd, str) write((fd), (str), sizeof(str)-1)
-
-static int test_runs = 0;
-static int test_successes = 0;
-static int test_failures = 0;
-
-
-const char *convert_testfile_name(const char *fn)
-{
-    if(fn[0] == '-' && fn[1] == '\0') {
-        return "(STDIN)";
-    }
-
-	return fn;
-}
-
-
-const char* get_testfile_name(struct test *test)
-{
-    return convert_testfile_name(test->testfilename);
-}
-
-
-/** Tells if the given file descriptor has a nonzero length.
- * NOTE: it changes the file offset to the end of the file.
- *
- * Returns nonzero if file has data, zero if it doesn't.
- * Actually, it just returns the file's length.
- */
-
-int fd_has_data(int fd)
-{
-    off_t pos = lseek(fd, 0, SEEK_END);
-    if(pos < 0) {
-        perror("lseek in fd_has_data");
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    return pos;
-}
-
-
-/** Tries to find the argument in the status line given.
- *
- * @return  nonzero if the argument could be found, zero if not.
- * If the argument was found, then incp and ince are updated to
- * point to its beginning and end.
- */
-
-static int locate_status_arg(const char **incp, const char **ince)
-{
-	const char *cp = *incp;
-	const char *ce = *ince;
-
-	// trim the newline from the end
-	if(ce[-1] == '\n') ce--;
-
-	// skip to colon separating name from arg
-	while(*cp != ':' && *cp != '\n' && cp < ce) cp++;
-	if(*cp == ':') {
-		cp++;					// skip the colon
-		if(*cp == ' ') cp++;	// skip the optional space after it
-		if(cp < ce) {
-			*incp = cp;
-			*ince = ce;
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-
-static char* dup_status_arg(const char *cp, const char *ce)
-{
-	char *ret = NULL;
-
-	if(locate_status_arg(&cp, &ce)) {
-		ret = malloc(ce - cp + 1);
-		if(ret) {
-			memcpy(ret, cp, ce-cp);
-			// replace the NL on the end with the null terminator.
-			ret[ce-cp] = '\0';
-		}
-	}
-
-	return ret;
-}
-
-
-static int copy_status_arg(const char *cp, const char *ce, char *buf, int size)
-{
-	if(locate_status_arg(&cp, &ce)) {
-		int len = ce - cp;
-		if(size-1 < len) len = size-1;
-		memcpy(buf, cp, len);
-		buf[len] = '\0';
-		return 1;
-	}
-
-	return 0;
-}
-
-
-/** Looks through the status file and stores the items of interest
- * in the test structure.
- */
-
-void scan_status_file(struct test *test)
-{
-	char lastfile[PATH_MAX];
-	int lastfile_good = 0;
-    char buf[BUFSIZ];
-    scanstate ss;
-    int tok;
-	int state = 0;
-
-    // first rewind the status file
-    if(lseek(test->statusfd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "read_file lseek for status file: %s\n", strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // then create our scanner
-    scanstate_init(&ss, buf, sizeof(buf));
-    readfd_attach(&ss, test->statusfd);
-    stscan_attach(&ss);
-
-    // now, if we see the token "CBRUNNING" in the token stream,
-    // it means that we attempted to start the test.  If not,
-    // then the test bailed early.
-    do {
-        tok = scan_token(&ss);
-
-		// look for errors...
-        if(tok < 0) {
-            fprintf(stderr, "Error %d pulling status tokens: %s\n", 
-                    tok, strerror(errno));
-            exit(10);
-        } else if(tok == stGARBAGE) {
-			fprintf(stderr, "Garbage on line %d in the status file: '%.*s'\n",
-					ss.line, token_length(&ss)-1, token_start(&ss));
-		} else {
-			state = tok;
-		}
-
-		switch(tok) {
-			case stSTART:
-				// nothing to do
-				break;
-
-			case stCONFIG:
-				if(test->status == test_pending) {
-					test->num_config_files += 1;
-					if(copy_status_arg(token_start(&ss), token_end(&ss), lastfile, sizeof(lastfile))) {
-						lastfile_good = 1;
-					} else {
-						fprintf(stderr, "CONFIG needs arg on line %d of the status file: '%.*s'\n",
-								ss.line, token_length(&ss)-1, token_start(&ss));
-					}
-				} else {
-					fprintf(stderr, "CONFIG but status (%d) wasn't pending on line %d of the status file: '%.*s'\n",
-							test->status, ss.line, token_length(&ss)-1, token_start(&ss));
-				}
-				break;
-
-			case stPREPARE:
-				// nothing to do
-				break;
-
-			case stRUNNING:
-				if(test->status == test_pending) {
-					test->status = test_was_started;
-					if(copy_status_arg(token_start(&ss), token_end(&ss), lastfile, sizeof(lastfile))) {
-						lastfile_good = 1;
-					} else {
-						fprintf(stderr, "RUNNING needs arg on line %d of the status file: '%.*s'\n",
-								ss.line, token_length(&ss)-1, token_start(&ss));
-					}
-				} else {
-					fprintf(stderr, "RUNNING but status (%d) wasn't pending on line %d of the status file: '%.*s'\n",
-							test->status, ss.line, token_length(&ss)-1, token_start(&ss));
-				}
-				break;
-
-			case stDONE:
-				if(test->status == test_was_started) {
-					test->status = test_was_completed;
-				} else {
-					fprintf(stderr, "DONE but status (%d) wasn't RUNNING on line %d of the status file: '%.*s'\n",
-							test->status, ss.line, token_length(&ss)-1, token_start(&ss));
-				}
-				break;
-			
-			case stABORTED:
-				test->status = (test->status >= test_was_started ? test_was_aborted : config_was_aborted);
-				test->status_reason = dup_status_arg(token_start(&ss), token_end(&ss));
-				break;
-
-			case stDISABLED:
-				test->status = (test->status >= test_was_started ? test_was_disabled : config_was_disabled);
-				test->status_reason = dup_status_arg(token_start(&ss), token_end(&ss));
-				break;
-
-			default:
-				fprintf(stderr, "Unknown token (%d) on line %d of the status file: '%.*s'\n",
-						tok, ss.line, token_length(&ss)-1, token_start(&ss));
-		}
-    } while(!scan_finished(&ss));
-
-	if(lastfile_good) {
-		test->last_file_processed = strdup(lastfile);
-	}
-}
-
-
-/** Prints the command section of the test suitable for how the test is being run.
- *
- * If the user is just running the test, nothing is printed.  If the
- * user is diffing or dumping the test, however, the modified command
- * section needs to be printed to the appropriate command.
- */
-
-void rewrite_command_section(struct test *test, int tok, const char *ptr, int len)
-{
-    // only dump if we're asked to.
-    if(test->rewritefd < 0) {
-        return;
-    }
-
-    // for now we don't modify it at all.
-    write(test->rewritefd, ptr, len);
-}
-
-
-/** Copies the command section of the test to the given fileptr and
- * also supplies it to the dump_command_section() routine.
- *
- * If you don't want to dump to a fileptr (i.e. if you're running
- * the test from a file) just pass NULL for fp.
- *
- * This routine is a whole lot like scan_sections except that it stops
- * at the end of the command section.  It leaves the result sections
- * on the stream to be parsed later.
- */
-
-void test_command_copy(struct test *test, FILE *fp)
-{
-    int oldline;
-
-    do {
-        oldline = test->testfile.line;
-        int tokno = scan_token(&test->testfile);
-        if(tokno < 0) {
-            fprintf(stderr, "Error %d pulling status tokens: %s\n", 
-                    tokno, strerror(errno));
-            exit(10);
-        } else if(tokno == 0) {
-			// if the test file is totally empty.
-			break;
-		}
-
-
-        if(tokno != exCOMMAND) {
-            // now we attempt to push the token back on the stream...
-            scan_pushback(&test->testfile);
-            test->testfile.line = oldline;
-            // The pushback reset the stream, and I restored the line number,
-            // but the scanner is still in a different state.
-            // We need it to be in a COMMAND state, so that when it feeds
-            // the new SECTION token it marks it NEW.  Reattaching resets
-            // the state to a command state, so we can just do that.
-            tfscan_attach(&test->testfile);
-            break;
-        }
-
-        // print the modified data to the output stream.
-        rewrite_command_section(test, tokno, token_start(&test->testfile), token_length(&test->testfile));
-
-        if(fp) {
-            // print the unmodified data to the command script.
-            fwrite(token_start(&test->testfile), token_length(&test->testfile), 1, fp);
-        }
-    } while(!scan_finished(&test->testfile));
-
-    rewrite_command_section(test, 0, NULL, 0);
-}
-
-
-/** Prepares a test section for comparison against actual results.
- *
- * The comparison is handled by compare.c/h.  We just need to set
- * it up.
- */
-
-void compare_section_start(scanstate *cmpscan, int fd, pcrs_job *joblist,
-		matchval *mv, const char *filename, const char *sectionname)
-{
-    assert(!compare_in_progress(cmpscan));
-
-    // associates the scanstate with the fd and prepares to compare.
-    if(*mv != match_unknown) {
-        fprintf(stderr, "'%s' has multiple %s sections!\n",
-                filename, sectionname);
-        exit(10);
-    }
-
-    // rewind the file
-    if(lseek(fd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "read_file lseek for status file: %s\n", strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    scanstate_reset(cmpscan);
-    readfd_attach(cmpscan, fd);
-	compare_attach(cmpscan, mv, joblist);
-
-    // we may want to check the token to see if there are any
-    // special requests (like detabbing).
-}
-
-
-/** Returns true if the given buffer contains non-whitespace characters,
- * false if the buffer consists entirely of whitespace. */
-
-static int contains_nws(const char *cp, int len)
-{
-	const char *ce = cp + len;
-
-	while(cp < ce) {
-		if(!isspace(*cp)) {
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-
-/** Scans the given buffer for the exit value.
- *
- * Ignores everything except for the first digit and any digits that
- * follow it.
- *
- * If digits are found, then it updates the test structure with
- * whether the exit values match or not.
- * If no digits are found, then this routine does nothing.
- */
-
-void parse_exit_clause(struct test *test, const char *cp, int len)
-{
-	const char *ce = cp + len;
-	unsigned int num = 0;
-
-	// skip to the first digit in the buffer
-	while(!isdigit(*cp) && cp < ce) cp++;
-	if(cp >= ce) return;
-
-	// scan the number
-	while(isdigit(*cp)) {
-		num = 10*num + (*cp - '0');
-		cp++;
-	}
-
-	test->expected_exitno = num;
-	test->exitno_match = (test->exitno == num ? match_yes : match_no);
-}
-
-
-/** Increments cp past the section name.
- *
- * Will not increment cp by more than len bytes.
- * This routine must match the token parsing found in the tfscan_start routine.
- */
-
-const char *skip_section_name(const char *cp, int len)
-{
-	const char *ce = cp + len;
-
-	// skip to colon separating section name from data
-	while(*cp != ':' && *cp != '\n' && cp < ce) cp++;
-	if(*cp == ':') cp++;
-	return cp;
-}
-
-
-void parse_modify_clause(struct test *test, const char *cp, const char *ce)
-{
-	pcrs_job *job, **p;
-	char *string;
-	int err;
-
-	char buf[128];	// holds the pcrs command.  We will dynamically
-		// allocate a buffer if the entire substitution doesn't fit
-		// into this buffer.  The vast majority will be <30 chars.
-
-	// skip any leading whitespace
-	while(isspace(*cp) && cp < ce) cp++;
-
-	// ensure there's still data worth parsing
-	if(*cp == '\n' || cp >= ce) {
-		return;
-	}
-
-	// don't parse it if it's a comment
-	if(*cp == '#') {
-		return;
-	}
-
-	// It's retarded that I can't pass a buf/len combo to pcrs_compile_command.
-	// It's also retarded that pcrs won't tell me where it stopped parsing
-	// so that we can have multiple substitution clauses on line line.
-
-	if(ce-cp-1 < sizeof(buf)) {
-		string = buf;
-	} else {
-		string = malloc(ce-cp+1);
-		if(!string) {
-			perror("malloc in parse_modify_clause");
-			exit(10);
-		}
-	}
-
-	memcpy(string, cp, ce-cp);
-	string[ce-cp] = '\0';
-	job = pcrs_compile_command(string, &err);
-	if(job == NULL) {
-        fprintf(stderr, "%s line %d compile error: %s (%d).\n",
-                get_testfile_name(test), test->testfile.line,
-                pcrs_strerror(err), err);
-	}
-
-	if(ce-cp-1 < sizeof(buf)) {
-		// nothing to do; we used the static buffer
-	} else {
-		free(string);
-	}
-
-	if(job == NULL) {
-		return;
-	}
-
-	// link this job onto the end of the list.
-	p = &test->eachline;
-	while(*p) p = &(**p).next;
-	*p = job;
-}
-
-
-/** This routine parses the tokens returned by scan_sections() and
- * compares them against the actual test results.  It stores the
- * results in test->match_stdout, match_stderr, and match_result.
- *
- * The refcon needs to be an allocated scanner.  It need not be
- * attached to anything -- this routine will take care of attaching
- * and detaching it as needed.
- */
-
-void parse_section_compare(struct test *test, int sec,
-        const char *datap, int len, void *refcon)
-{
-    #define get_cur_state(ss)    ((int)(ss)->userref)
-    #define set_cur_state(ss,x)  ((ss)->userref=(void*)(x))
-
-    scanstate *cmpscan = refcon;
-    int newsec = EX_TOKEN(sec);
-
-    if(get_cur_state(cmpscan) == 0) {
-        // This is the first time this scanner has been used.
-        set_cur_state(cmpscan, exCOMMAND);
-    }
-
-    if(!is_section_token(newsec) && sec != 0) {
-        // We only work with result section tokens.  Ignore all
-        // non-section-tokens except the eof token.
-        return;
-    }
-
-    if(EX_ISNEW(sec) || sec == 0) {
-        // ensure previoius section is finished
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-            case exSTDERR:
-                compare_end(cmpscan);
-                break;
-            default:
-                ;
-        }
-
-        // then fire up the new section
-        set_cur_state(cmpscan, newsec);
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-				if(test->stdout_match == match_unknown) {
-					compare_section_start(cmpscan, test->outfd, test->eachline,
-							&test->stdout_match, get_testfile_name(test), "STDOUT");
-				} else {
-					fprintf(stderr, "%s line %d Error: duplicate STDOUT section.  Ignored.\n",
-							get_testfile_name(test), test->testfile.line);
-					// as long as scanref == null, no comparison will happen.
-					assert(!cmpscan->scanref);
-				}
-                break;
-            case exSTDERR:
-				if(test->stderr_match == match_unknown) {
-					compare_section_start(cmpscan, test->errfd, test->eachline,
-							&test->stderr_match, get_testfile_name(test), "STDERR");
-				} else {
-					fprintf(stderr, "%s line %d Error: duplicate STDERR section.  Ignored.\n",
-							get_testfile_name(test), test->testfile.line);
-					// as long as scanref == null, no comparison will happen.
-					assert(!cmpscan->scanref);
-				}
-                break;
-            case exRESULT:
-				parse_exit_clause(test, datap, len);
-                break;
-            case exMODIFY:
-				parse_modify_clause(test, skip_section_name(datap,len), datap+len);
-                break;
-            case exCOMMAND:
-                assert(!"Well, this is impossible.  How did you start a new command section??");
-                break;
-        }
-    } else {
-        // we're continuing an already started section.
-        assert(get_cur_state(cmpscan) == newsec);
-
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-            case exSTDERR:
-                compare_continue(cmpscan, datap, len);
-                break;
-            case exRESULT:
-				if(contains_nws(datap, len)) {
-					fprintf(stderr, "%s line %d Error: RESULT clause contains garbage.\n",
-							get_testfile_name(test), test->testfile.line);
-					//exit(10);
-				}
-                break;
-            case exMODIFY:
-				parse_modify_clause(test, datap, datap+len);
-                break;
-            case exCOMMAND:
-                break;
-        }
-    }
-}
-
-
-/** Scans the output sections of the test and calls the supplied parser
- * for each token.
- *
- * Tokens are defined by the tfscan_start() routine.  Currently they're
- * full lines.  If the line starts with a recognized section heading,
- *
- *
- * @param scanner: used to provide the section tokens.
- */
-
-void scan_sections(struct test *test, scanstate *scanner,
-        void (*parseproc)(struct test *test, int sec, const char *datap,
-                int len, void *refcon), void *refcon)
-{
-    // if the testfile is already at its eof, it means that
-    // it didn't have any sections.  therefore, we'll assume
-    // defaults for all values.  we're done.
-    if(scan_finished(scanner)) {
-        return;
-    }
-    
-    do {
-        int tokno = scan_token(scanner);
-        if(tokno < 0) {
-            fprintf(stderr, "Error %d pulling status tokens: %s\n", 
-                    tokno, strerror(errno));
-            exit(10);
-        } else if(tokno == 0) {
-			break;
-		}
-
-        (*parseproc)(test, tokno, token_start(scanner),
-                token_length(scanner), refcon);
-
-    } while(!scan_finished(scanner));
-
-    // give the parser an eof token so it can finalize things.
-    (*parseproc)(test, 0, NULL, 0, refcon);
-}
-
-
-static void print_reason(struct test *test, const char *name, const char *prep)
-{
-	printf("%s %-25s ", name, get_testfile_name(test));
-	if(!was_started(test->status)) {
-		printf("%s %s", prep, test->last_file_processed);
-		if(test->status_reason) {
-			printf(": ");
-		}
-	}
-	if(test->status_reason) {
-		printf("%s", test->status_reason);
-	}
-	printf("\n");
-}
-
-
-/** Checks the actual results against the expected results.
- */
-
-void test_results(struct test *test)
-{
-    scanstate scanner;
-    char scanbuf[MAX_LINE_LENGTH];
-	int stdo, stde, exno;	// true if there are differences.
-	
-	if(was_aborted(test->status)) {
-		print_reason(test, "ABRT", "by");
-		test_failures++;
-		test->aborted = 1;
-		return;
-	}
-
-	if(was_disabled(test->status)) {
-		print_reason(test, "dis ", "by");
-		return;
-	}
-
-    if(!was_started(test->status)) {
-		print_reason(test, "ERR ", "error in");
-        test_failures++;
-        return;
-    }
-
-    test->exitno_match = match_unknown;
-    test->stdout_match = match_unknown;
-    test->stderr_match = match_unknown;
-
-    scanstate_init(&scanner, scanbuf, sizeof(scanbuf));
-    scan_sections(test, &test->testfile, parse_section_compare, &scanner);
-
-    assert(test->stdout_match != match_inprogress);
-    assert(test->stderr_match != match_inprogress);
-
-    // convert any unknowns into a solid yes/no
-    if(test->exitno_match == match_unknown) {
-		test->expected_exitno = 0;
-        test->exitno_match = (test->exitno == 0 ? match_yes : match_no);
-    }
-    if(test->stdout_match == match_unknown) {
-        test->stdout_match = (fd_has_data(test->outfd) ? match_no : match_yes);
-    }
-    if(test->stderr_match == match_unknown) {
-        test->stderr_match = (fd_has_data(test->errfd) ? match_no : match_yes);
-    }
-
-    stdo = (test->stdout_match != match_yes);
-    stde = (test->stderr_match != match_yes);
-    exno = (test->exitno_match != match_yes);
-
-    if(!stdo && !stde && !exno) {
-        test_successes++;
-        printf("ok   %s \n", get_testfile_name(test));
-    } else {
-        test_failures++;
-        printf("FAIL %-25s ", get_testfile_name(test));
-		printf("%c%c%c  ",
-				(stdo ? 'O' : '.'),
-				(stde ? 'E' : '.'),
-				(exno ? 'X' : '.'));
-		if(stdo || stde) {
-			if(stdo) printf("stdout ");
-			if(stdo && stde) printf("and ");
-			if(stde) printf("stderr ");
-			printf("differed");
-		}
-		if((stdo || stde) && exno) printf(", ");
-		if(exno) printf("result was %d not %d", test->exitno, test->expected_exitno);
-		printf("\n");
-    }
-
-    return;
-}
-
-
-static void write_exit_no(int fd, int exitno)
-{
-    char buf[512];
-    int cnt;
-
-    cnt = snprintf(buf, sizeof(buf), "RESULT: %d\n", exitno);
-    write(fd, buf, cnt);
-}
-
-
-void write_raw_file(int outfd, int infd)
-{
-    char buf[BUFSIZ];
-    int rcnt, wcnt;
-
-    // first rewind the input file
-    if(lseek(infd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "write_file lseek on %d: %s\n", infd, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // then write the file.
-    do {
-        do {
-            rcnt = read(infd, buf, sizeof(buf));
-        } while(rcnt < 0 && errno == EINTR);
-        if(rcnt > 0) {
-            do {
-                wcnt = write(outfd, buf, rcnt);
-            } while(wcnt < 0 && errno == EINTR);
-            if(wcnt < 0) {
-                // write error.  do something!
-                perror("writing in write_file");
-                break;
-            }
-        } else if (rcnt < 0) {
-            // read error.  do something!
-            perror("reading in write_file");
-            break;
-        }
-    } while(rcnt);
-}
-
-
-static void write_modified_file(int outfd, int infd, pcrs_job *job)
-{
-    // this routine is fairly similar to compare_continue_lines.
-    // it would be nice to unify them.  that would take some fairly
-    // major surgery though.
-
-    scanstate scanner, *ss = &scanner;
-    char scanbuf[MAX_LINE_LENGTH];
-    const char *p;
-    char *new;
-    size_t newsize;
-    int rcnt, wcnt;
-
-    // first rewind the input file
-    if(lseek(infd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "write_file lseek on %d: %s\n", infd, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // create the scanner we'll use to buffer the lines
-    scanstate_init(ss, scanbuf, sizeof(scanbuf));
-    readfd_attach(ss, infd);
-
-    do {
-        p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-        if(!p) {
-            rcnt = (*ss->read)(ss);
-            if(rcnt < 0) {
-                // read error.  do something!
-                perror("reading in write_modified_file");
-                break;
-            }
-            p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-            if(!p) {
-                p = ss->limit - 1;
-            }
-        }
-
-        p += 1;
-        new = substitute_string(job, ss->cursor, p, &newsize);
-        if(!new) {
-            // substitution error!  message already printed.
-            break;
-        }
-
-        do {
-            wcnt = write(outfd, new, newsize);
-        } while(wcnt < 0 && errno == EINTR);
-        free(new);
-        if(wcnt < 0) {
-            // write error.  do something!
-            perror("writing in write_modified_file");
-            break;
-        }
-        ss->cursor = p;
-    } while(rcnt);
-}
-
-
-static void write_file(int outfd, int infd, pcrs_job *job)
-{
-	if(!job) {
-		// use the simple, fast routine
-		write_raw_file(outfd, infd);
-	} else {
-		// use the line buffered routine
-		write_modified_file(outfd, infd, job);
-	}
-}
-
-
-/** Writes the actual results in place of the expected results.
- */
-
-void parse_section_output(struct test *test, int sec,
-        const char *datap, int len, void *refcon)
-{
-    assert(sec >= 0);
-
-    switch(sec) {
-        case 0:
-            // don't need to worry about eof
-            break;
-
-        case exSTDOUT|exNEW:
-            test->stdout_match = match_yes;
-			write_strconst(test->rewritefd, "STDOUT:\n");
-            write_file(test->rewritefd, test->outfd, test->eachline);
-            break;
-        case exSTDOUT:
-            // ignore all data in the expected stdout.
-            break;
-
-        case exSTDERR|exNEW:
-            test->stderr_match = match_yes;
-			write_strconst(test->rewritefd, "STDERR:\n");
-            write_file(test->rewritefd, test->errfd, test->eachline);
-        case exSTDERR:
-            // ignore all data in the expected stderr
-            break;
-
-        case exRESULT|exNEW:
-            test->exitno_match = match_yes;
-            write_exit_no(test->rewritefd, test->exitno);
-            break;
-
-        case exRESULT:
-            // allow random garbage in result section to pass
-            write(test->rewritefd, datap, len);
-            break;
-
-        case exMODIFY|exNEW:
-            parse_modify_clause(test, skip_section_name(datap,len), datap+len);
-            write(test->rewritefd, datap, len);
-            break;
-
-        case exMODIFY:
-            // parse modify sections and still print them.
-            parse_modify_clause(test, datap, datap+len);
-            write(test->rewritefd, datap, len);
-            break;
-            
-        default:
-            write(test->rewritefd, datap, len);
-    }
-}
-
-
-static void dump_reason(struct test *test, const char *name)
-{
-	fprintf(stderr, "ERROR Test %s", name);
-	if(!was_started(test->status)) {
-		fprintf(stderr, " by %s", convert_testfile_name(test->last_file_processed));
-		if(test->status_reason) {
-			printf(": ");
-		}
-	}
-	if(test->status_reason) {
-		fprintf(stderr, ": %s", test->status_reason);
-	}
-	fprintf(stderr, "\n");
-}
-
-
-/** Prints the actual result sections in the same order as they
- * appear in the testfile.
- */
-
-void dump_results(struct test *test)
-{
-	if(was_aborted(test->status)) {
-		dump_reason(test, "was aborted");
-		test->aborted = 1;
-		return;
-	}
-
-	if(was_disabled(test->status)) {
-		dump_reason(test, "is disabled");
-		return;
-
-	}
-
-    if(!was_started(test->status)) {
-        fprintf(stderr, "Error: %s was not started due to errors in %s.\n",
-				get_testfile_name(test), test->last_file_processed);
-        test_failures++;
-        return;
-    }
-
-    // The command section has already been dumped.  We just
-    // need to dump the result sections.  The trick is, though,
-    // that we need to dump them in the same order as they occur
-    // in the testfile otherwise the diff will be all screwed up.
-
-    test->exitno_match = match_unknown;
-    test->stdout_match = match_unknown;
-    test->stderr_match = match_unknown;
-
-    // ensure that we haven't yet parsed any modify sections.
-    assert(!test->eachline);
-
-    scan_sections(test, &test->testfile, parse_section_output, NULL);
-
-    // if any sections haven't been output, but they differ from
-    // the default, then they need to be output here at the end.
-
-    if(test->exitno_match == match_unknown && test->exitno != 0) {
-        write_exit_no(test->rewritefd, test->exitno);
-    }
-    if(test->stderr_match == match_unknown && fd_has_data(test->errfd)) {
-		write_strconst(test->rewritefd, "STDERR:\n");
-        write_file(test->rewritefd, test->errfd, test->eachline);
-    }
-    if(test->stdout_match == match_unknown && fd_has_data(test->outfd)) {
-		write_strconst(test->rewritefd, "STDOUT:\n");
-        write_file(test->rewritefd, test->outfd, test->eachline);
-    }
-}
-
-
-void print_test_summary()
-{
-    printf("\n");
-    printf("%d test%s run, ", test_runs, (test_runs != 1 ? "s" : ""));
-    printf("%d success%s, ", test_successes, (test_successes != 1 ? "es" : ""));
-    printf("%d failure%s.", test_failures, (test_failures != 1 ? "s" : ""));
-
-	if(!quiet) {
-		printf("    ");
-		print_rusage();
-	}
-	
-	printf("\n");
-}
-
-
-void test_init(struct test *test)
-{
-    test_runs++;
-    memset(test, 0, sizeof(struct test));
-    test->rewritefd = -1;
-}
-
-
-void test_free(struct test *test)
-{
-	int err;
-
-	// the buffer for the testfile scanner is allocated on the stack.
-	if(test->eachline) {
-		pcrs_free_joblist(test->eachline);
-	}
-
-	if(test->diffname) {
-		err = close(test->diff_fd);
-		if(err < 0) {
-			fprintf(stderr, "Could not close %s: %s\n", test->diffname, strerror(errno));
-		}
-		err = unlink(test->diffname);
-		if(err < 0) {
-			fprintf(stderr, "Could not remove %s: %s\n", test->diffname, strerror(errno));
-		}
-		free(test->diffname);
-	}
-
-	if(test->status_reason) {
-		free(test->status_reason);
-	}
-
-	if(test->last_file_processed) {
-		free(test->last_file_processed);
-	}
-}
-
-

Copied: trunk/test.c (from rev 85, TRUNK/test.c)

Deleted: trunk/tfscan.c
===================================================================
--- TRUNK/tfscan.c	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/tfscan.c	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,258 +0,0 @@
-/* Generated by re2c 0.5 on Sun Dec 18 12:25:00 2005 */
-
-/* tfscan.re
- * Scott Bronson
- * 30 Dec 2004
- *
- * Scanner for test files.
- * This file needs to be processed by re2c, http://re2c.org
- *
- * This file is covered by the MIT License.
- */
-
-#include "tfscan.h"
-
-
-#define START(x) (ss->scanref=(void*)(x))
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a new section, it returns the token name of that section
- * with the exNEW flag turned on.  After that, it returns each
- * line in the section with the token's identifier.  Then, when it
- * finds a new section, you get a exNEW+TOKEN of the new section.
- */
-
-int tfscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    inc_line(ss);
-
-{
-	YYCTYPE yych;
-	unsigned int yyaccept;
-	goto yy0;
-yy1:	++YYCURSOR;
-yy0:
-	if((YYLIMIT - YYCURSOR) < 6) YYFILL(6);
-	yych = *YYCURSOR;
-	switch(yych){
-	case '\n':	goto yy7;
-	case 'M':	goto yy4;
-	case 'R':	goto yy3;
-	case 'S':	goto yy2;
-	default:	goto yy5;
-	}
-yy2:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy29;
-	default:	goto yy6;
-	}
-yy3:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy19;
-	default:	goto yy6;
-	}
-yy4:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy9;
-	default:	goto yy6;
-	}
-yy5:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy6;
-yy6:	switch(yych){
-	case '\n':	goto yy7;
-	default:	goto yy5;
-	}
-yy7:	yych = *++YYCURSOR;
-	goto yy8;
-yy8:
-
-	{ return (int)ss->scanref; }
-yy9:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy10;
-	default:	goto yy6;
-	}
-yy10:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy11;
-	default:	goto yy6;
-	}
-yy11:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'F':	goto yy12;
-	default:	goto yy6;
-	}
-yy12:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'Y':	goto yy13;
-	default:	goto yy6;
-	}
-yy13:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy14;
-yy14:	switch(yych){
-	case '\t':	case ' ':	goto yy13;
-	case '\n':	goto yy7;
-	case ':':	goto yy15;
-	default:	goto yy5;
-	}
-yy15:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy16;
-yy16:	switch(yych){
-	case '\n':	goto yy17;
-	default:	goto yy15;
-	}
-yy17:	yych = *++YYCURSOR;
-	goto yy18;
-yy18:
-
-	{ START(exMODIFY); return exNEW|exMODIFY; }
-yy19:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'S':	goto yy20;
-	default:	goto yy6;
-	}
-yy20:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy21;
-	default:	goto yy6;
-	}
-yy21:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'L':	goto yy22;
-	default:	goto yy6;
-	}
-yy22:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy23;
-	default:	goto yy6;
-	}
-yy23:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy24;
-yy24:	switch(yych){
-	case '\t':	case ' ':	goto yy23;
-	case '\n':	goto yy7;
-	case ':':	goto yy25;
-	default:	goto yy5;
-	}
-yy25:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy26;
-yy26:	switch(yych){
-	case '\n':	goto yy27;
-	default:	goto yy25;
-	}
-yy27:	yych = *++YYCURSOR;
-	goto yy28;
-yy28:
-
-	{ START(exRESULT); return exNEW|exRESULT; }
-yy29:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy30;
-	default:	goto yy6;
-	}
-yy30:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy31;
-	case 'O':	goto yy32;
-	default:	goto yy6;
-	}
-yy31:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy40;
-	default:	goto yy6;
-	}
-yy32:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy33;
-	default:	goto yy6;
-	}
-yy33:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy34;
-	default:	goto yy6;
-	}
-yy34:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy35;
-yy35:	switch(yych){
-	case '\t':	case ' ':	goto yy34;
-	case '\n':	goto yy7;
-	case ':':	goto yy36;
-	default:	goto yy5;
-	}
-yy36:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy37;
-yy37:	switch(yych){
-	case '\n':	goto yy38;
-	default:	goto yy36;
-	}
-yy38:	yych = *++YYCURSOR;
-	goto yy39;
-yy39:
-
-	{ START(exSTDOUT); return exNEW|exSTDOUT; }
-yy40:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy41;
-	default:	goto yy6;
-	}
-yy41:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy42;
-yy42:	switch(yych){
-	case '\t':	case ' ':	goto yy41;
-	case '\n':	goto yy7;
-	case ':':	goto yy43;
-	default:	goto yy5;
-	}
-yy43:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy44;
-yy44:	switch(yych){
-	case '\n':	goto yy45;
-	default:	goto yy43;
-	}
-yy45:	yych = *++YYCURSOR;
-	goto yy46;
-yy46:
-
-	{ START(exSTDERR); return exNEW|exSTDERR; }
-}
-
-
-}
-
-
-/** Prepares the given scanner to scan a testfile.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* tfscan_attach(scanstate *ss)
-{
-    if(ss) {
-        START(exCOMMAND);
-        ss->state = tfscan_start;
-    }
-
-    return ss;
-}
-

Copied: trunk/tfscan.c (from rev 85, TRUNK/tfscan.c)

Deleted: trunk/tfscan.h
===================================================================
--- TRUNK/tfscan.h	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/tfscan.h	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,40 +0,0 @@
-/* tfscan.h
- * Scott Bronson
- */
-
-/** @file tfscan.h
- *
- * This file declares the interface to the expected results test
- * file scanner.
- */
-
-
-#include "re2c/scan.h"
-
-
-/** This lists all the tokens that the test file scanner may return.
- */
-
-enum {
-    // command sections are numbered between 1 and 63
-    exCOMMAND = 1,			///< marks a new line in the command section.  (in the future, we might actually start parsing the command section)
-    exCOMMAND_TOKEN_END,	///< never returned.  this token is always one higher than the highest-numbered command token.
-
-    // result sections are numbered from 64 through 127.
-    exSTDOUT = 64,			///< marks a line in the stdout section.
-    exSTDERR,				///< marks a line in the stderr section.
-    exRESULT,				///< marks a line in the result (exit value) section.
-    exMODIFY,				///< marks a line in the modify (per-line substitution) section.
-    exRESULT_TOKEN_END,		///< never returned.  this token is always one higher than the highest-numbered section token.
-
-    exNEW = 0x100,			///< flag added to the section token that specifies that this is the start of a new section.
-};
-
-
-#define EX_TOKEN(x) ((x)&0xFF)
-#define EX_ISNEW(x) ((x)&exNEW)
-#define is_command_token(x) (EX_TOKEN(x)>=exCOMMAND && EX_TOKEN(x)<ex_COMMAND_TOKEN_END)
-#define is_section_token(x) (EX_TOKEN(x)>=exSTDOUT && EX_TOKEN(x)<exRESULT_TOKEN_END)
-
-scanstate* tfscan_attach(scanstate *ss);
-

Copied: trunk/tfscan.h (from rev 85, TRUNK/tfscan.h)

Deleted: trunk/tfscan.re
===================================================================
--- TRUNK/tfscan.re	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/tfscan.re	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,60 +0,0 @@
-/* tfscan.re
- * Scott Bronson
- * 30 Dec 2004
- *
- * Scanner for test files.
- * This file needs to be processed by re2c, http://re2c.org
- *
- * This file is covered by the MIT License.
- */
-
-#include "tfscan.h"
-
-
-#define START(x) (ss->scanref=(void*)(x))
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a new section, it returns the token name of that section
- * with the exNEW flag turned on.  After that, it returns each
- * line in the section with the token's identifier.  Then, when it
- * finds a new section, you get a exNEW+TOKEN of the new section.
- */
-
-int tfscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    inc_line(ss);
-
-/*!re2c
-
-WS      = [ \t];
-ANYN    = [\000-\377]\[\n];
-
-"STDOUT" WS* ":" ANYN* "\n"  { START(exSTDOUT); return exNEW|exSTDOUT; }
-"STDERR" WS* ":" ANYN* "\n"  { START(exSTDERR); return exNEW|exSTDERR; }
-"RESULT" WS* ":" ANYN* "\n"  { START(exRESULT); return exNEW|exRESULT; }
-"MODIFY" WS* ":" ANYN* "\n"  { START(exMODIFY); return exNEW|exMODIFY; }
-
-ANYN* "\n"                  { return (int)ss->scanref; }
-
-*/
-}
-
-
-/** Prepares the given scanner to scan a testfile.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* tfscan_attach(scanstate *ss)
-{
-    if(ss) {
-        START(exCOMMAND);
-        ss->state = tfscan_start;
-    }
-
-    return ss;
-}
-

Deleted: trunk/tmtest.conf
===================================================================
--- TRUNK/tmtest.conf	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/tmtest.conf	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,56 +0,0 @@
-# tmtest.conf
-# Scott Bronson
-# 31 Dec 2004
-
-
-# This file tells how to run tests on tmtest itself.
-# See tmtestetc or tmtestrc for examples of globally-installed
-# configuration files.
-
-
-# This can be a little confusing because one copy of tmtest runs another
-# copy and checks its output.  We'll call the executable doing the testing
-# the superexec, and the program being tested the subexec.
-#
-# Because the user launched the superexec, we have no control over which
-# executable is used to run the tests.  Hopefully it's reasonably stable.
-#
-# This configuration file, tmtest.conf, tells the superexec how to run the
-# test battery.  Local settings are read from /etc/tmtest.conf, ~/.tmtestrc,
-# etc., then this file is loaded.
-#
-# The subtests do not read any configuration files outside of the test
-# directory except for one, tmtest.sub.conf.
-
-
-# turn on debugging
-# set -x
-
-
-# All tests are written to be pedantic.  We want them to exit at the
-# first sign of trouble and have the result code reported in RESULT.
-
-set -e
-
-
-
-# Add the current directory at the front of the PATH environment variable.
-# This means that while the test is running, any executables in this
-# directory will take priority over similarly-named executables anywhere
-# else (like /usr/bin or ~/bin).  This ensures that we lauch the unstable
-# copy of tmtest to handle each test.
-
-PATH="$MYDIR:$PATH";
-
-
-# All testfiles include $args in the arguments to the subexec.
-# (if they don't, it's a bug in the test).
-#
-# This allows us to specify default commands for all tests being run.
-# For instance, forcing the config file ensures that no config files
-# outside the test directory will be read.  This way we can be sure
-# that the tests are not succeeding due to some local configuration;
-# their environment is as clean as we can possibly make it.
-
-args="--config=$MYPATH/test/tmtest.sub.conf"
-

Copied: trunk/tmtest.conf (from rev 85, TRUNK/tmtest.conf)





From tmtest-commits at berlios.de  Tue Feb 28 01:48:53 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 01:48:53 +0100
Subject: [Tmtest-commits] [87] create releases directory
Message-ID: <200602280048.k1S0mr3b014180@sheep.berlios.de>

Revision: 87
Author:   bronson
Date:     2006-02-28 01:48:25 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
create releases directory

Modified Paths:
--------------
    trunk/CHANGES

Added Paths:
-----------
    releases/
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-27 23:10:08 UTC (rev 86)
+++ trunk/CHANGES	2006-02-28 00:48:25 UTC (rev 87)
@@ -1,8 +1,5 @@
-- rename TRUNK to trunk
 - write some tests to ensure diff works with files that don't end in CR.
-- Fix 99-Misc.
 - move INDENT from 04-diff into the stdlib.  Add to docs.
-- Eradicate the MODIFY clause from the documentation.  Mark it deprecated.
 ----
 - Bash3 has made it so that the RE can no longer appear on the same line as
   the MODIFY command.  I updated all tests and accelerated MODIFY deprecation.





From tmtest-commits at berlios.de  Tue Feb 28 01:51:12 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 01:51:12 +0100
Subject: [Tmtest-commits] [88] releases/0.92/: Tag release 0.92
Message-ID: <200602280051.k1S0pCRV014747@sheep.berlios.de>

Revision: 88
Author:   bronson
Date:     2006-02-28 01:50:58 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Tag release 0.92

Added Paths:
-----------
    releases/0.92/
Copied: releases/0.92 (from rev 76, TRUNK)





From tmtest-commits at berlios.de  Tue Feb 28 14:44:55 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 14:44:55 +0100
Subject: [Tmtest-commits] [89] trunk: Add INDENT to stdlib, start make-dist script
Message-ID: <200602281344.k1SDit3s001268@sheep.berlios.de>

Revision: 89
Author:   bronson
Date:     2006-02-28 14:44:47 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Add INDENT to stdlib, start make-dist script

Modified Paths:
--------------
    trunk/CHANGES
    trunk/Makefile
    trunk/stscan.c
    trunk/test/04-diff/09-MultiLevelDiff.test
    trunk/test/04-diff/10-Patch.test
    trunk/test/04-diff/11-MultiPatch.test
    trunk/test/04-diff/12-MultiLevelPatch.test
    trunk/test/04-diff/13-MultiLevelPatch.test
    trunk/tmlib.sh

Added Paths:
-----------
    trunk/make-dist

Removed Paths:
-------------
    trunk/test/04-diff/indent.sh
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/CHANGES	2006-02-28 13:44:47 UTC (rev 89)
@@ -1,6 +1,9 @@
 - write some tests to ensure diff works with files that don't end in CR.
-- move INDENT from 04-diff into the stdlib.  Add to docs.
+- write some tests to ensure binary transparency of stdout and stderr.
+  (especially hit the newlines hard)
+- Release next version.
 ----
+- Added the INDENT function to tmlib.
 - Bash3 has made it so that the RE can no longer appear on the same line as
   the MODIFY command.  I updated all tests and accelerated MODIFY deprecation.
 - Added -n (--no-trailing-newline) capability to STDOUT and STDERR sections.
@@ -8,6 +11,7 @@
 - Got rid of all AUTHOR and DATE automation.  Too heavyhanded.
 - Standardized licensing: everything under my control is MIT, package is LGPL.
 - When installing locally, it's ~/.tmlib.sh instead of ~/share/tmtest/tmlib.sh
+
 - Bump to 0.92
 - install now installs config files too.
 - Added the --config option to override default config files.

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/Makefile	2006-02-28 13:44:47 UTC (rev 89)
@@ -5,7 +5,7 @@
 # This software is distributed under the LGPL.  See COPYING for more.
 
 
-VERSION=0.92
+VERSION=0.94
 
 # override this when installing: "make install prefix=/usr/local"
 #prefix=/usr
@@ -95,6 +95,8 @@
 distclean: clean
 	rm -f stscan.[co]
 
+dist: stscan.c
+	
 tags: $(CSRC) $(CHDR) $(INTERMED)
 	ctags -R
 

Added: trunk/make-dist
===================================================================
--- trunk/make-dist	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/make-dist	2006-02-28 13:44:47 UTC (rev 89)
@@ -0,0 +1,48 @@
+#!/bin/sh
+
+# make-dist (for tmtest)
+# Scott Bronson
+# 30 May 2000
+
+
+name=tmtest
+version=$(perl -ne '/VERSION=([0-9]+\.[0-9A-Za-z_.-]+)/ && print $1' Makefile)
+
+if [ ! "$version" ] ; then echo "Could not figure out version." ; exit 1 ; fi
+
+grep -w $version CHANGES 2>&1 >/dev/null
+if [ "$?" != "0" ]; then echo "Add $version to CHANGES!"; exit 1; fi
+
+pushd . 2>&1 > /dev/null
+
+# Ensure tree is ready to go
+make distclean > /dev/null || exit 1
+make dist > /dev/null || exit 1
+
+# get rid of possible old files
+rm -rf /tmp/$name-$version
+rm -rf /tmp/$name-$version.tar.gz
+
+# make a working copy in /tmp
+cp -r . /tmp/$name-$version
+
+# remove unneeded files
+cd /tmp/$name-$version
+find . -name .svn | xargs rm -rf
+rm -f Makefile.old
+rm make-dist
+
+# check for any invisible files
+find . | grep /\\. && echo "BAD FILES!  Won't finish." && exit 1
+
+# show a list of files so we can see questionable stuff
+find .
+
+# tar it up
+cd ..
+tar zcf $name-$version.tar.gz $name-$version
+
+# we're done
+echo "New dist is in /tmp/$name-$version.tar.gz, enjoy!"
+popd 2>&1 > /dev/null
+


Property changes on: trunk/make-dist
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/stscan.c
===================================================================
--- trunk/stscan.c	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/stscan.c	2006-02-28 13:44:47 UTC (rev 89)
@@ -1,4 +1,4 @@
-/* Generated by re2c 0.9.10 on Mon Feb 27 18:07:08 2006 */
+/* Generated by re2c 0.9.10 on Mon Feb 27 20:04:36 2006 */
 
 /* stscan.re
  * Scott Bronson

Modified: trunk/test/04-diff/09-MultiLevelDiff.test
===================================================================
--- trunk/test/04-diff/09-MultiLevelDiff.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/04-diff/09-MultiLevelDiff.test	2006-02-28 13:44:47 UTC (rev 89)
@@ -11,9 +11,6 @@
 # tt/two/one/t.test
 
 
-. "$MYDIR/indent.sh"
-
-
 MKDIR tt
 cd "$tt" || ABORT "Could not cd to $tt"
 

Modified: trunk/test/04-diff/10-Patch.test
===================================================================
--- trunk/test/04-diff/10-Patch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/04-diff/10-Patch.test	2006-02-28 13:44:47 UTC (rev 89)
@@ -4,9 +4,7 @@
 # tests tmtest -d | patch
 # Updated for tmtest 2.0 on 29 Jan 2005
 
-. "$MYDIR/indent.sh"
 
-
 MKFILE tt <<-EOL
 	echo "right output"
 	STDOUT:
@@ -20,7 +18,7 @@
 tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch)
 echo "And the patched file:"
 echo
-INDENT < "$tt"
+INDENT "\t" < "$tt"
 
 MODIFY:
   s/^patching .*/patching FILE/

Modified: trunk/test/04-diff/11-MultiPatch.test
===================================================================
--- trunk/test/04-diff/11-MultiPatch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/04-diff/11-MultiPatch.test	2006-02-28 13:44:47 UTC (rev 89)
@@ -4,9 +4,7 @@
 # tests tmtest -d | patch
 # Updated for tmtest 2.0 on 29 Jan 2005
 
-. "$MYDIR/indent.sh"
 
-
 MKFILE tt1 <<-EOL
 	echo "right output1"
 	STDOUT:
@@ -30,11 +28,11 @@
 
 tmtest --all-files -d "$tt1" "$tt2" "$tt3" | (cd `dirname "$tt1"` && patch)
 echo
-INDENT < "$tt1"
+INDENT "\t" < "$tt1"
 echo
-INDENT < "$tt2"
+INDENT "\t" < "$tt2"
 echo
-INDENT < "$tt3"
+INDENT "\t" < "$tt3"
 
 MODIFY:
   s/^patching .*/patching FILE/

Modified: trunk/test/04-diff/12-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/12-MultiLevelPatch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/04-diff/12-MultiLevelPatch.test	2006-02-28 13:44:47 UTC (rev 89)
@@ -11,9 +11,6 @@
 # tt/two/one/t.test
 
 
-. "$MYDIR/indent.sh"
-
-
 MKDIR tt
 cd "$tt" || ABORT "Could not cd to $tt"
 
@@ -56,15 +53,15 @@
 
 tmtest --all-files -d | patch -p0
 echo
-INDENT < t.test
+INDENT "\t" < t.test
 echo
-INDENT < one/t.test
+INDENT "\t" < one/t.test
 echo
-INDENT < two/t1.test
+INDENT "\t" < two/t1.test
 echo
-INDENT < two/t2.test
+INDENT "\t" < two/t2.test
 echo
-INDENT < two/one/t.test
+INDENT "\t" < two/one/t.test
 
 rm -rf t.test one two
 

Modified: trunk/test/04-diff/13-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/13-MultiLevelPatch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/04-diff/13-MultiLevelPatch.test	2006-02-28 13:44:47 UTC (rev 89)
@@ -11,9 +11,6 @@
 # tt/two/one/t.test
 
 
-. "$MYDIR/indent.sh"
-
-
 MKDIR tt
 cd "$tt" || ABORT "Could not cd to $tt"
 
@@ -57,15 +54,15 @@
 
 tmtest --all-files -d .. | patch -p0
 echo
-INDENT < ../t.test
+INDENT "\t" < ../t.test
 echo
-INDENT < ../one/t.test
+INDENT "\t" < ../one/t.test
 echo
-INDENT < t1.test
+INDENT "\t" < t1.test
 echo
-INDENT < t2.test
+INDENT "\t" < t2.test
 echo
-INDENT < one/t.test
+INDENT "\t" < one/t.test
 
 rm -rf ../t.test ../one ../two
 

Deleted: trunk/test/04-diff/indent.sh
===================================================================
--- trunk/test/04-diff/indent.sh	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/04-diff/indent.sh	2006-02-28 13:44:47 UTC (rev 89)
@@ -1,9 +0,0 @@
-# This function indents each line of its stdin with a tab.
-
-INDENT ()
-{
-	while read LINE; do
-		echo $'\t'"$LINE"
-	done
-}
-

Modified: trunk/tmlib.sh
===================================================================
--- trunk/tmlib.sh	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/tmlib.sh	2006-02-28 13:44:47 UTC (rev 89)
@@ -5,13 +5,19 @@
 
 
 # TODO: should these routines be prefixed by "TM"?
+# TODO: is there any way to get rid of MKFILE_EMPTY?  Can't MKFILE notice
+#       if read would block and, if so, just create an empty file.?
 
 
-# Current functions:
-# ASSERT: Stop a test if a condition fails
-# ATEXIT: Ensure something gets cleaned up even if the test fails.
-# MKFILE MKFILE_EMPTY: create temporary files
-# MKDIR: create a temporary directory
+# tmlib functions:
+#
+# ASSERT:   Stop a test if a condition fails
+# TRAP:     Execute a command when an exception happens
+# ATEXIT:   Ensure a command runs even if the test fails (usually to clean up).
+# MKFILE_EMPTY: create an empty temporary file.
+# MKFILE:   Creates a temporary file with the given contents.
+# MKDIR:    create a temporary directory
+# INDENT:   indent some output.
 
 
 
@@ -178,3 +184,36 @@
 	ATEXIT "rmdir '$name'"
 }
 
+
+# 
+# INDENT
+#
+# Indents the output the given number of spaces.
+# Note that this only works with stdout!  You'll have to combine
+# the stdout and stderr streams if you want to indent stderr.
+#
+# By default this script indents each line with two spaces.
+# Pass an argument to tell this function what to put before
+# each line.
+#
+# Examples:
+#
+#    echo hi | INDENT "\t"      # indents stdout with a tab char
+#    cat /tmp 2>&1 | INDENT     # indents both stdout and stderr
+#    exec > >(INDENT)           # indents all further script output
+#
+
+INDENT ()
+{
+    # sed appears more binary transparent than bash's builtins so I'm
+    # using sed instead of read.
+
+    sed -e "s/^/${1-  }/"
+
+    # even though this might be faster, it mucks things up.
+    #
+    #	while read LINE; do
+    #		echo $'\t'"$LINE"
+    #	done
+}
+





From tmtest-commits at berlios.de  Tue Feb 28 15:43:04 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 15:43:04 +0100
Subject: [Tmtest-commits] [90] trunk: Wrote some tests to ensre that diff/patch work with
Message-ID: <200602281443.k1SEh4nH028273@sheep.berlios.de>

Revision: 90
Author:   bronson
Date:     2006-02-28 15:42:59 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Wrote some tests to ensre that diff/patch work with --suppress-trailing-newline

Modified Paths:
--------------
    trunk/CHANGES
    trunk/TODO
    trunk/tmtest.pod

Added Paths:
-----------
    trunk/test/04-diff/20-DiffNoNL.test
    trunk/test/04-diff/21-PatchNoNL.test
    trunk/test/04-diff/22-PatchNoNL2.test
    trunk/test/04-diff/23-PatchNoNL3.test
    trunk/test/04-diff/tmtest.conf
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-28 13:44:47 UTC (rev 89)
+++ trunk/CHANGES	2006-02-28 14:42:59 UTC (rev 90)
@@ -1,4 +1,3 @@
-- write some tests to ensure diff works with files that don't end in CR.
 - write some tests to ensure binary transparency of stdout and stderr.
   (especially hit the newlines hard)
 - Release next version.

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-02-28 13:44:47 UTC (rev 89)
+++ trunk/TODO	2006-02-28 14:42:59 UTC (rev 90)
@@ -33,6 +33,9 @@
   - Yes, if a config file returns DISABLED, then that folder and all its
     subfolders are skipped.  Just make the test itself call the DISABLED
 	command if you want testing to continue in that subfolder.
+- Print a warning if we notice that an output section doesn't end in
+  a newline, but the testfile hasn't marked that section with a "-n".
+  See 22-PatchNoNL2.test for more.  Make sure a test for this is in 03 too.
 
 0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.

Added: trunk/test/04-diff/20-DiffNoNL.test
===================================================================
--- trunk/test/04-diff/20-DiffNoNL.test	2006-02-28 13:44:47 UTC (rev 89)
+++ trunk/test/04-diff/20-DiffNoNL.test	2006-02-28 14:42:59 UTC (rev 90)
@@ -0,0 +1,31 @@
+# DiffNoNL
+# author: Scott Bronson
+# date:   28 Feb 2006
+
+
+# If this test fails but PatchNoNL doesn't then you're probably using a
+# non-Gnu diff and patch programs.  As long as 21 works, you're in good
+# shape.  Please send me the output of 'tmtest -o 20-DiffNoNL.test' so
+# I can update this test.
+#
+# If both DiffNoNL and PatchNoNL fail, your diff and patch programs are
+# buggy and you should probably update them.
+
+
+tmtest -d - <<-EOL | FIX_DIFF
+    echo -n "right output"
+    STDOUT:
+    right output
+EOL
+
+
+STDOUT:
+--- /tmp/FILE DATE TIME TZ
++++ - DATE TIME TZ
+@@ -1,3 +1,5 @@
+     echo -n "right output"
+     STDOUT:
+     right output
++STDOUT:
++right output
+\ No newline at end of file

Added: trunk/test/04-diff/21-PatchNoNL.test
===================================================================
--- trunk/test/04-diff/21-PatchNoNL.test	2006-02-28 13:44:47 UTC (rev 89)
+++ trunk/test/04-diff/21-PatchNoNL.test	2006-02-28 14:42:59 UTC (rev 90)
@@ -0,0 +1,33 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Ensures that patch can handle diffs that remove the trailing newline.
+# 
+# If ONLY this test fails, then chances are the patch utility installed
+# on this system is buggy.  You'll probably want to update it to the
+# latest Gnu Patch, http://www.gnu.org/software/patch/
+
+
+MKFILE tt <<-EOL
+	echo -n "right output"
+	STDOUT:
+	right output
+EOL
+
+
+# This is a little exotic...  Patch needs the CWD to be the directory
+# containing the file to patch.  "dirname $(tt.test)" gives that dir.
+
+tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
+echo "And the patched file:"
+INDENT < "$tt"
+echo "<<DONE>>"
+echo "(since there's no trailing newline, DONE should appear on the prevous line)"
+
+STDOUT:
+patching FILE
+And the patched file:
+  echo -n "right output"
+  STDOUT:
+  right output<<DONE>>
+(since there's no trailing newline, DONE should appear on the prevous line)

Added: trunk/test/04-diff/22-PatchNoNL2.test
===================================================================
--- trunk/test/04-diff/22-PatchNoNL2.test	2006-02-28 13:44:47 UTC (rev 89)
+++ trunk/test/04-diff/22-PatchNoNL2.test	2006-02-28 14:42:59 UTC (rev 90)
@@ -0,0 +1,39 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Ensures that patch can handle diffs that remove the trailing newline.
+# Except that we wedge it by putting the STDERR clause right after the
+# STDOUT.
+
+# Since STDOUT includes no trailing newline, STDERR ends up on the end
+# of the last STDOUT line.  This is not real good, but at least it
+# guarantees that the test will fail until the user fixes it.
+
+
+MKFILE tt <<-EOL
+	echo -n "right output"
+    echo "stderr text" 1>&2
+	STDOUT:
+	right output
+    STDERR:
+    stderr text
+EOL
+
+
+# This is a little exotic...  Patch needs the CWD to be the directory
+# containing the file to patch.  "dirname $(tt.test)" gives that dir.
+
+tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
+echo "And the patched file:"
+INDENT < "$tt"
+echo "<<DONE>>"
+
+STDOUT:
+patching FILE
+And the patched file:
+  echo -n "right output"
+      echo "stderr text" 1>&2
+  STDOUT:
+  right outputSTDERR:
+  stderr text
+<<DONE>>

Added: trunk/test/04-diff/23-PatchNoNL3.test
===================================================================
--- trunk/test/04-diff/23-PatchNoNL3.test	2006-02-28 13:44:47 UTC (rev 89)
+++ trunk/test/04-diff/23-PatchNoNL3.test	2006-02-28 14:42:59 UTC (rev 90)
@@ -0,0 +1,36 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Ensures that patch can handle diffs that remove the trailing newline.
+# In this case, patch adds a newline to a section that erroneously
+# didn't have one.
+
+# By the time we get to the end of the STDOUT section, it's too late to
+# remove the "-n".  Therefore, we just add another newline.  If the
+# section has two newlines but suppresses one, it matches the output's
+# single newline exactly.
+
+
+MKFILE tt <<-EOL
+	echo "right output"
+	STDOUT: -n
+	right output
+EOL
+
+
+# This is a little exotic...  Patch needs the CWD to be the directory
+# containing the file to patch.  "dirname $(tt.test)" gives that dir.
+
+tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
+echo "And the patched file:"
+INDENT < "$tt"
+echo "<<DONE>>"
+
+STDOUT:
+patching FILE
+And the patched file:
+  echo "right output"
+  STDOUT: -n
+  right output
+  
+<<DONE>>

Added: trunk/test/04-diff/tmtest.conf
===================================================================
--- trunk/test/04-diff/tmtest.conf	2006-02-28 13:44:47 UTC (rev 89)
+++ trunk/test/04-diff/tmtest.conf	2006-02-28 14:42:59 UTC (rev 90)
@@ -0,0 +1,23 @@
+# This file contains a function that is really useful to the tests
+# in this directory.  Because this file is named 'tmtest.conf', this
+# function is included into testfiles automatically.
+
+
+# remove all dynamic elements from a standard diff file.
+# to use: 'diff file1 file2 | FIX_DIFF'
+
+FIX_DIFF ()
+{
+    sed -e 's/^---.*/--- \/tmp\/FILE DATE TIME TZ/' \
+        -e 's/^[+][+][+].*/+++ - DATE TIME TZ/'
+}
+
+
+# remove all dynamic elements from typical patch output
+# to use: 'patch -p0 < file.patch | FIX_PATCH'
+
+FIX_PATCH ()
+{
+    sed -e 's/^patching .*/patching FILE/'
+}
+

Modified: trunk/tmtest.pod
===================================================================
--- trunk/tmtest.pod	2006-02-28 13:44:47 UTC (rev 89)
+++ trunk/tmtest.pod	2006-02-28 14:42:59 UTC (rev 90)
@@ -14,6 +14,20 @@
 
 =over 8
 
+=item B<--all-files>
+
+Causes tmtest to ignore the name of the testfile while running tests.
+
+Normally tmtest only runs files with names that end in ".test".
+While this is often a very good thing (you wouldn't want tmtest
+to try to run just any old random file as a test), sometimes it
+gets in the way.  For instance, MKFILE offers no control over the
+name of the file generated.  If you used MKFILE to create a
+testfile, run tmtest with --all-files and name the testfile explicitly
+on the command line.
+
+See 10-Patch.test for an example.  (TODO: cobble together a better example)
+
 =item B<-c> B<--config>
 
 Specifies the config file to be read before running the test file.





From tmtest-commits at berlios.de  Tue Feb 28 19:17:44 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 19:17:44 +0100
Subject: [Tmtest-commits] [91] trunk: Added REPLACE function to tmlib
Message-ID: <200602281817.k1SIHiYl023544@sheep.berlios.de>

Revision: 91
Author:   bronson
Date:     2006-02-28 19:17:12 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Added REPLACE function to tmlib

Modified Paths:
--------------
    trunk/CHANGES
    trunk/test/README
    trunk/tmlib.sh

Added Paths:
-----------
    trunk/test/02-running/40-Replace.test
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-28 14:42:59 UTC (rev 90)
+++ trunk/CHANGES	2006-02-28 18:17:12 UTC (rev 91)
@@ -2,7 +2,7 @@
   (especially hit the newlines hard)
 - Release next version.
 ----
-- Added the INDENT function to tmlib.
+- Added the INDENT and REPLACE functions to tmlib.
 - Bash3 has made it so that the RE can no longer appear on the same line as
   the MODIFY command.  I updated all tests and accelerated MODIFY deprecation.
 - Added -n (--no-trailing-newline) capability to STDOUT and STDERR sections.

Added: trunk/test/02-running/40-Replace.test
===================================================================
--- trunk/test/02-running/40-Replace.test	2006-02-28 14:42:59 UTC (rev 90)
+++ trunk/test/02-running/40-Replace.test	2006-02-28 18:17:12 UTC (rev 91)
@@ -0,0 +1,48 @@
+# Tests tmlib's REPLACE function.  Mostly tests to be sure that
+# regular expression metachars are correctly interpreted as
+# regular characters.
+
+echo $'Abc  : '   $'abc'       | REPLACE abc def
+echo $'A\'b  : '  $'a\'b'      | REPLACE $'a\'b' def
+echo $'A\"b  : '  $'a\"b'      | REPLACE $'a\"b' def
+echo $'A\'\'b : ' $'a\'\'b'    | REPLACE $'a\'\'b' def
+echo $'A\"\"b : ' $'a\"\"b'    | REPLACE $'a\"\"b' def
+echo $'A\\\'b : ' $'a\\\'b'    | REPLACE $'a\\\'b' def
+echo $'A\\\"b : ' $'a\\\"b'    | REPLACE $'a\\\"b' def
+echo $'A\'\\b : ' $'a\'\\b'    | REPLACE $'a\'\\b' def
+echo $'A\"\\b : ' $'a\"\\b'    | REPLACE $'a\"\\b' def
+echo $'A\\\\b : ' $'a\\\\b'    | REPLACE $'a\\\\b' def
+echo  'A/b  : '   'a/b'        | REPLACE a/b def
+echo  'A.b  : '   'a.b'        | REPLACE 'a.b' def
+echo  'A*b  : '   'a*b'        | REPLACE 'a*b' def
+echo  'A+b  : '   'a+b'        | REPLACE 'a+b' def
+echo  'A$b  : '   'a$b'        | REPLACE 'a$b' def
+echo  'A$$b : '   'a$$b'       | REPLACE 'a$$b' def
+echo  'A at b  : '   'a at b'        | REPLACE 'a at b' def
+echo  'D.f  : '   'def'        | REPLACE 'd.f' BAD
+echo $'A\\\'b : ' $'a\\\'b'    | REPLACE $'a\\\'b' def
+echo $'A\\\"b : ' $'a\\\"b'    | REPLACE $'a\\\"b' def
+echo $'A\\Q\\Eb:' $'a\\Q\\Eb' | REPLACE $'a\\Q\\Eb' def
+
+STDOUT:
+Abc :  def
+A'b :  def
+A"b :  def
+A''b :  def
+A""b :  def
+A\'b:  def
+A\"b:  def
+A'\b:  def
+A"\b:  def
+A\\b:  def
+A/b:   def
+A.b:   def
+A*b:   def
+A+b:   def
+A$b:   def
+A$$b:  def
+A at b:   def
+D.f:   def
+A\'b:  def
+A\"b:  def
+A\Q\Eb:  def

Modified: trunk/test/README
===================================================================
--- trunk/test/README	2006-02-28 14:42:59 UTC (rev 90)
+++ trunk/test/README	2006-02-28 18:17:12 UTC (rev 91)
@@ -15,8 +15,8 @@
 
 02-running: tests running the actual tests
     Ensures that the test environment is set up properly.
-    For instance, checks that disabled tests are not run, the tmlib
-    calls are performed properly, etc.
+    For instance, checks that disabled tests are not run,
+    tmlib functions behave correctly, etc.
 
 03-results: tests the results
     Ensures that we compare the test results properly.

Modified: trunk/tmlib.sh
===================================================================
--- trunk/tmlib.sh	2006-02-28 14:42:59 UTC (rev 90)
+++ trunk/tmlib.sh	2006-02-28 18:17:12 UTC (rev 91)
@@ -18,6 +18,7 @@
 # MKFILE:   Creates a temporary file with the given contents.
 # MKDIR:    create a temporary directory
 # INDENT:   indent some output.
+# REPLACE:  replaces literal text with other literal text (no regexes).
 
 
 
@@ -217,3 +218,44 @@
     #	done
 }
 
+
+# 
+# REPLACE
+#
+# Replaces all occurrences of the first argument with the second
+# argument.  Both should be regex-safe.  Use sed if you want to
+# replace with regexes.  NOTE: replace does not work if a newline
+# is embedded in either argument.
+#
+# Three layers of escaping!  (bash, perlvar, perlre)  This is insane.
+# I wish sed or awk would work with raw strings instead of regexes.
+# Why isn't a replace utility a part of Gnu coreutils?
+#
+
+REPLACE()
+{
+    # unfortunately bash can't handle this substitution because it
+    # must work on ' and \ simultaneously.  So, send it to perl for
+    # processing.  Until ' and \ have been escaped, Perl can't 
+    
+
+#    echo "got: '$1' '${1//[\'\\]/\'}'"
+#    perl -e "print \"in: \" . quotemeta('${1//\'/\'}') . \"\\n\";"
+
+#     (echo "$1"; echo "$2"; cat) | cat
+#     (echo "$1"; echo "$2"; cat) | perl -e "my \$in = <>; chomp \$in; my \$out = <>; chomp \$out; print '  in: <<' . \$in . \">>\n out: <<\" . \$out . \">>\n\"; while(<>) { print \"DATA: \$_\" }"
+#     (echo "$1"; echo "$2"; cat) | perl -e "my \$in = <>; chomp \$in; \$in=quotemeta(\$in); my \$out = <>; chomp \$out; print '  in: <<' . \$in . \">>\n out: <<\" . \$out . \">>\n\"; while(<>) { print \"DATA: \$_\" }"
+
+     (echo "$1"; echo "$2"; cat) | perl -e "my \$in = <>; chomp \$in; \$in=quotemeta(\$in); my \$out = <>; chomp \$out; while(<>) { s/\$in/\$out/g; print or die \"Could not print: \$!\\\\n\"; }"
+
+
+# this scheme also works but it's much better to feed the vars on stdin
+# along with the data.  Less process overhead, simpler script.  This
+# does mean that REPLACE won't work with embedded newlines though.
+#
+#    local in=$(perl -p -e "s/([\\'\\\\])/\\\\\$1/g" <<< $1);
+#    local out=$(perl -p -e "s/([\\'\\\\])/\\\\\$1/g" <<< $2);
+#
+#     perl -e "<>; my \$in = quotemeta(chomp); <>; my \$out = chomp; while(<>) { s/\$in/\$out/g; print or die \"Could not print: \$!\\\\n\"; }"
+#    perl -e "my \$in = quotemeta('${1//\'/\'}'); my \$out = '${2//\'/\'}'; while(<>) { s/\$in/\$out/g; print or die \"Could not print: \$!\\\\n\"; }"
+}





From tmtest-commits at berlios.de  Tue Feb 28 21:00:43 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 21:00:43 +0100
Subject: [Tmtest-commits] [92] trunk: Made tmtest report in the test results if child was exited
Message-ID: <200602282000.k1SK0hpG004167@sheep.berlios.de>

Revision: 92
Author:   bronson
Date:     2006-02-28 21:00:30 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Made tmtest report in the test results if child was exited by a signal.

Modified Paths:
--------------
    trunk/CHANGES
    trunk/main.c
    trunk/test.c
    trunk/test.h

Added Paths:
-----------
    trunk/test/02-running/22-Signal.test
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-28 18:17:12 UTC (rev 91)
+++ trunk/CHANGES	2006-02-28 20:00:30 UTC (rev 92)
@@ -2,6 +2,7 @@
   (especially hit the newlines hard)
 - Release next version.
 ----
+- Now reports in the test results if child was terminated by a signal.
 - Added the INDENT and REPLACE functions to tmlib.
 - Bash3 has made it so that the RE can no longer appear on the same line as
   the MODIFY command.  I updated all tests and accelerated MODIFY deprecation.

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-02-28 18:17:12 UTC (rev 91)
+++ trunk/main.c	2006-02-28 20:00:30 UTC (rev 92)
@@ -172,7 +172,6 @@
 int wait_for_child(int child, const char *name)
 {
     int pid;
-    int signal;
     int status;
 
     // wait patiently for child to finish.
@@ -184,23 +183,20 @@
     }
 
     if(WIFSIGNALED(status)) {
-        signal = WTERMSIG(status);
-        if(signal == SIGINT) {
+        if(WTERMSIG(status) == SIGINT) {
             // If test was interrupted with a sigint then raise it on ourselves.
-            // Otherwise it can be hard to interrupt a test battery.
+            // Otherwise it can be hard to interrupt a series of tests
+            // (you kill one test but the next one fires right up).
 			kill(getpid(), SIGINT);
         }
-        // it's probably a SIGABRT if child hit an assertion.
-        // we'll just return 256.
-        return 256;
-    }
-
-    if(!WIFEXITED(status)) {
-        fprintf(stderr, "Unknown status returned by %s: %d\n", name, status);
+    } else if(!WIFEXITED(status)) {
+        // not signalled, but os claims child didn't exit normally.
+        fprintf(stderr, "WTF??  Unknown status returned by %s: %d\n",
+                name, status);
         exit(runtime_error);
     }
 
-    return WEXITSTATUS(status);
+    return status;
 }
 
 
@@ -318,12 +314,23 @@
 
 void finish_diff(struct test *test, int diffpid)
 {
+    int status;
+    int exitcode;
+
     close(test->rewritefd);
 
-    int status = wait_for_child(diffpid, "diff");
+    status = wait_for_child(diffpid, "diff");
+    if(WIFSIGNALED(status)) {
+        fprintf(stderr, "diff terminated by signal %d!\n", WTERMSIG(status));
+        exit(runtime_error);
+    }
 
-    if(status != 0 && status != 1) {
-        fprintf(stderr, "diff returned %d!\n", status);
+    exitcode = WEXITSTATUS(status);
+
+    // I forget what return code 1 meands but it's harmless
+    // (in gnu diff anyway; dunno about other diffs)
+    if(exitcode != 0 && exitcode != 1) {
+        fprintf(stderr, "diff returned %d!\n", exitcode);
         exit(runtime_error);
     }
 }
@@ -357,6 +364,7 @@
 	int keepontruckin;
     int diffpid;
     int fd = -1;
+    int i;
     FILE *tochild;
 
     // defined in the exec.c file generated by exec.tmpl.
@@ -479,7 +487,10 @@
     fclose(tochild);
 
     // wait for the test to finish
-    test.exitno = wait_for_child(child, "test");
+    i = wait_for_child(child, "test");
+    test.exitsignal = (WIFSIGNALED(i) ? WTERMSIG(i) : 0);
+    test.exitcored = (WIFSIGNALED(i) ? WCOREDUMP(i) : 0);
+    test.exitno = (WIFEXITED(i) ? WEXITSTATUS(i) : 256);
 
 	// read the status file to determine what happened
 	// and store the information in the test struct.

Added: trunk/test/02-running/22-Signal.test
===================================================================
--- trunk/test/02-running/22-Signal.test	2006-02-28 18:17:12 UTC (rev 91)
+++ trunk/test/02-running/22-Signal.test	2006-02-28 20:00:30 UTC (rev 92)
@@ -0,0 +1,15 @@
+# This verifies that tmtest correctly handles a child exiting
+# by a signal.
+
+# it's important that the heredoc word is quoted.  Otherwise the $$ would
+# be expanded to be the pid of the parent, not the pid of the child process
+# that we want to kill!
+
+tmtest $CFG -q - <<'EOL'
+    kill -9 $$
+EOL
+
+STDOUT:
+FAIL (STDIN)                   terminated by signal 9
+
+1 test run, 0 successes, 1 failure.

Modified: trunk/test.c
===================================================================
--- trunk/test.c	2006-02-28 18:17:12 UTC (rev 91)
+++ trunk/test.c	2006-02-28 20:00:30 UTC (rev 92)
@@ -819,18 +819,24 @@
     } else {
         test_failures++;
         printf("FAIL %-25s ", get_testfile_name(test));
-		printf("%c%c%c  ",
-				(stdo ? 'O' : '.'),
-				(stde ? 'E' : '.'),
-				(exno ? 'X' : '.'));
-		if(stdo || stde) {
-			if(stdo) printf("stdout ");
-			if(stdo && stde) printf("and ");
-			if(stde) printf("stderr ");
-			printf("differed");
-		}
-		if((stdo || stde) && exno) printf(", ");
-		if(exno) printf("result was %d not %d", test->exitno, test->expected_exitno);
+        if(test->exitsignal) {
+            printf("terminated by signal %d%s", test->exitsignal,
+                    (test->exitcored ? " with core" : ""));
+        } else {
+            printf("%c%c%c  ",
+                    (stdo ? 'O' : '.'),
+                    (stde ? 'E' : '.'),
+                    (exno ? 'X' : '.'));
+            if(stdo || stde) {
+                if(stdo) printf("stdout ");
+                if(stdo && stde) printf("and ");
+                if(stde) printf("stderr ");
+                printf("differed");
+            }
+            if((stdo || stde) && exno) printf(", ");
+            if(exno) printf("result was %d not %d",
+                    test->exitno, test->expected_exitno);
+        }
 		printf("\n");
     }
 

Modified: trunk/test.h
===================================================================
--- trunk/test.h	2006-02-28 18:17:12 UTC (rev 91)
+++ trunk/test.h	2006-02-28 20:00:30 UTC (rev 92)
@@ -47,7 +47,9 @@
     int outfd;				///< the file that receives the test's stdout.
     int errfd;				///< the file that receives the test's stderr.
     int statusfd;			///< receives the runtime test status messages.
-    int exitno;				///< the test's actual exit value.
+    int exitno;				///< the test's actual exit value (WEXITSTATUS).
+    int exitsignal;         ///< the value returned for the test by waitpid(2)
+    int exitcored;          ///< if exitsignal is true, true if child core dumped.
 
 	pcrs_job *eachline;		///< a linked list of pcrs jobs to be applied to each line.
 





From tmtest-commits at berlios.de  Tue Feb 28 21:58:48 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 21:58:48 +0100
Subject: [Tmtest-commits] [93] trunk/re2c: Wow, what an embarrasing bug.
Message-ID: <200602282058.k1SKwmGb028883@sheep.berlios.de>

Revision: 93
Author:   bronson
Date:     2006-02-28 21:58:44 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Wow, what an embarrasing bug.  I guess it has lived for so long
because none of my tests ever needed to have the buffer shifted.

Modified Paths:
--------------
    trunk/re2c/read.c
    trunk/re2c/scan.h
Modified: trunk/re2c/read.c
===================================================================
--- trunk/re2c/read.c	2006-02-28 20:00:30 UTC (rev 92)
+++ trunk/re2c/read.c	2006-02-28 20:58:44 UTC (rev 93)
@@ -47,6 +47,6 @@
         assert(ss->cursor <= ss->limit);
     }
 
-    return ss->bufsiz - (ss->bufptr - ss->limit);
+    return ss->bufsiz - (ss->limit - ss->bufptr);
 }
 

Modified: trunk/re2c/scan.h
===================================================================
--- trunk/re2c/scan.h	2006-02-28 20:00:30 UTC (rev 92)
+++ trunk/re2c/scan.h	2006-02-28 20:58:44 UTC (rev 93)
@@ -176,7 +176,7 @@
     // (these do a poor job of simulating capturing parens)
     const char *token;  ///< The start of the current token (manually updated by the scanner).
     int line;           ///< The scanner may or may not maintain the current line number in this field.
-    int at_eof;         ///< You almost certainly don't want to be using this (unless you're writing a readproc).  Use scan_finished() instead.  This field gets set when the readproc realizes it has hit eof.  by convention 1 means eof, 2 means yes, at_eof is true, but because of an unrecoverable read error (todo: this should be formalized).
+    int at_eof;         ///< You almost certainly don't want to be using this unless you're writing a readproc.  Use scan_finished() instead.  This field gets set when the readproc realizes it has hit eof.  by convention 1 means eof, 2 means yes, at_eof is true, but because of an unrecoverable read error (todo: this should be formalized?  TODO: audit code to see if this is indeed the case).
 
     const char *bufptr; ///< The buffer currently in use
     int bufsiz;         ///< The maximum number of bytes that the buffer can hold





From tmtest-commits at berlios.de  Tue Feb 28 22:32:56 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 22:32:56 +0100
Subject: [Tmtest-commits] [94] trunk: read_shiftbuf was totally messed up.
Message-ID: <200602282132.k1SLWuQx029659@sheep.berlios.de>

Revision: 94
Author:   bronson
Date:     2006-02-28 22:32:53 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
read_shiftbuf was totally messed up.  Fixed now.
Also needed to update the token when comparing (otherwise the scanner
will try to keep the entire token in the buffer, run out of room,
and bail).

Modified Paths:
--------------
    trunk/compare.c
    trunk/re2c/read.c
Modified: trunk/compare.c
===================================================================
--- trunk/compare.c	2006-02-28 20:58:44 UTC (rev 93)
+++ trunk/compare.c	2006-02-28 21:32:53 UTC (rev 94)
@@ -48,6 +48,11 @@
 
 static int compare_fill(scanstate *ss)
 {
+    // need to pretend like we're updating the token,
+    // otherwise the readproc will think we need to keep
+    // the token and we quickly run out of buffer room.
+    ss->token = ss->cursor;
+
     return (*ss->read)(ss);
 }
 
@@ -90,6 +95,7 @@
         n = ss->limit - ss->cursor;
         if(!n) {
             n = compare_fill(ss);
+            ss->line += n;
             if(n < 0) {
                 // there was an error while trying to fill the buffer
                 // TODO: this should be propagated to the client somehow.

Modified: trunk/re2c/read.c
===================================================================
--- trunk/re2c/read.c	2006-02-28 20:58:44 UTC (rev 93)
+++ trunk/re2c/read.c	2006-02-28 21:32:53 UTC (rev 94)
@@ -33,18 +33,40 @@
 
  */
 
+
+// cnt tells how many bytes need to be shifted downward.
+// The bytes that need to be shifted are those between the token
+// and the limit.
+
 int read_shiftbuf(scanstate *ss)
 {
-    int cnt = ss->token - ss->bufptr;
+    const char *min;
+    int cnt;
+
+    min = ss->token;
+    if(ss->marker && ss->marker < min) {
+        min = ss->marker;
+    }
+
+    // this tells how many bytes need to be shifted.
+    cnt = ss->limit - min;
     if(cnt) {
-        memmove((void*)ss->bufptr, ss->token, ss->limit - ss->token);
-        ss->token = ss->bufptr;
-        ss->cursor -= cnt;
-        if(ss->marker) ss->marker -= cnt;
-        ss->limit -= cnt;
+        int delta = min - ss->bufptr;
+        memmove((void*)ss->bufptr, min, cnt);
+        ss->cursor -= delta;
+        ss->token -= delta;
+        if(ss->marker) ss->marker -= delta;
+        ss->limit -= delta;
+
         assert(ss->limit >= ss->bufptr);
         assert(ss->cursor >= ss->bufptr);
         assert(ss->cursor <= ss->limit);
+    } else {
+        // nothing to shift so we reset the buffer to maximum size.
+        ss->cursor = ss->bufptr;
+        ss->token = ss->bufptr;
+        if(ss->marker)  ss->marker = ss->bufptr;
+        ss->limit = ss->bufptr;
     }
 
     return ss->bufsiz - (ss->limit - ss->bufptr);





From tmtest-commits at berlios.de  Tue Feb 28 22:53:18 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 22:53:18 +0100
Subject: [Tmtest-commits] [95] trunk: Add tests to ensure binary transparency.
Message-ID: <200602282153.k1SLrIGl004915@sheep.berlios.de>

Revision: 95
Author:   bronson
Date:     2006-02-28 22:53:17 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Add tests to ensure binary transparency.  After some parsing
effort it appears to work.

Modified Paths:
--------------
    trunk/CHANGES
    trunk/TODO

Added Paths:
-----------
    trunk/test/03-results/30-Binary.test
    trunk/test/03-results/31-BinaryFail.test
    trunk/test/03-results/32-BinaryLarge.test
    trunk/test/03-results/33-BinaryHuge.test
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-28 21:32:53 UTC (rev 94)
+++ trunk/CHANGES	2006-02-28 21:53:17 UTC (rev 95)
@@ -1,5 +1,3 @@
-- write some tests to ensure binary transparency of stdout and stderr.
-  (especially hit the newlines hard)
 - Release next version.
 ----
 - Now reports in the test results if child was terminated by a signal.

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-02-28 21:32:53 UTC (rev 94)
+++ trunk/TODO	2006-02-28 21:53:17 UTC (rev 95)
@@ -2,7 +2,6 @@
 - An empty test with a STDOUT clause should fail without the -n right?
   I mean, there's no newline in the actual output, but there is in the
   expected...
-- Add tests for binary transparency.
 - write tests for nesting testfiles with --config.
         // If the user specifies a config file, we only check directories
         // not above the given config file.  i.e. if user specifies
@@ -16,6 +15,14 @@
     supports the --config argument (make them DISABLED or something).
 
 0.96:
+- Change the I/O scheme to be event based.  Get rid of the tempfiles.
+  Convert to using the async io library.  Don't use temporary files.
+  This would allow us to recognize that the test is disabled before
+  producing a partial diff, blowing away output sections.
+- Use i/o lib for everything.  No need for temp files.
+  This means that we stream everything EXCEPT stderr, which we memory
+  buffer.  If your stderr is more than 100K or so in size, just redirect
+  it to stdout.
 - stdin is all buggered up.  why is it that "cat" with no args will print
   the rest of the test script?  And why is it that if you fork, diff freezes?
   They're related problems I suspect.
@@ -38,16 +45,6 @@
   See 22-PatchNoNL2.test for more.  Make sure a test for this is in 03 too.
 
 0.98:
-- Change the I/O scheme to be event based.  Get rid of the tempfiles.
-  Convert to using the async io library.  Don't use temporary files.
-  This would allow us to recognize that the test is disabled before
-  producing a partial diff, blowing away output sections.
-- Use i/o lib for everything.  No need for temp files.
-  This means that we stream everything EXCEPT stderr, which we memory
-  buffer.  If your stderr is more than 100K or so in size, just redirect
-  it to stdout.
-
-2.0:
 - get rid of all the exit(10) calls in test.c.  We need a better way to
   abort the test.
   should get rid of a whole bunch in main.c as well.
@@ -55,6 +52,8 @@
 - Get rid of MODIFY clauses.  It's unnecessary complexity.
   And it's a LOT.  First remove it from the tests, then from the code.
 
+1.0:
+
 ?:
 - add gcov support so you can see what sort of coverage your tests provide.
 - Provide some sort of automatable XML output?

Added: trunk/test/03-results/30-Binary.test
===================================================================
--- trunk/test/03-results/30-Binary.test	2006-02-28 21:32:53 UTC (rev 94)
+++ trunk/test/03-results/30-Binary.test	2006-02-28 21:53:17 UTC (rev 95)
@@ -0,0 +1,24 @@
+# Ensures that a testfile can contain 4 NULLs and comparison will
+# still work.
+
+# We need to create the testfile in its own file because Bash will
+# screw things up if we use a heredoc.
+
+MKFILE tt <<-EOL
+	echo -e "\\0\\0\\0\\0"
+    # stdout will be filled in below
+	STDOUT:
+EOL
+
+# Add the expected results to the testfile.
+echo -e "\\0\\0\\0\\0" >> "$tt"
+
+# and run the test
+tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
+
+STDOUT:
+
+Processing /tmp/FILE
+ok   /tmp/FILE 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/03-results/31-BinaryFail.test
===================================================================
--- trunk/test/03-results/31-BinaryFail.test	2006-02-28 21:32:53 UTC (rev 94)
+++ trunk/test/03-results/31-BinaryFail.test	2006-02-28 21:53:17 UTC (rev 95)
@@ -0,0 +1,24 @@
+# Ensures that a testfile can contain 4 NULLs and comparison will
+# still work.  This tests what happens if the comparison fails.
+
+# We need to create the testfile by hand in the /tmp directory
+# because Bash will screw up the binary if we use a heredoc.
+
+MKFILE tt <<-EOL
+	echo -e "\\0\\0\\0\\0"
+	STDOUT:
+EOL
+
+# Add the expected results to the testfile.  NOTE: there is one
+# to few NULs here.  This will cause the test to fail.
+echo -e "\\0\\0\\0" >> "$tt"
+
+# and run the test
+tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
+
+STDOUT:
+
+Processing /tmp/FILE
+FAIL /tmp/FILE        O..  stdout differed
+
+1 test run, 0 successes, 1 failure.

Added: trunk/test/03-results/32-BinaryLarge.test
===================================================================
--- trunk/test/03-results/32-BinaryLarge.test	2006-02-28 21:32:53 UTC (rev 94)
+++ trunk/test/03-results/32-BinaryLarge.test	2006-02-28 21:53:17 UTC (rev 95)
@@ -0,0 +1,35 @@
+# Ensures that a testfile can contain some arbitrary binary
+# data and the test will still work.  This just tests control chars.
+
+# We need to manuall create the testfile because Bash will screw 
+# things up if we use a heredoc.
+
+MKFILE tt <<-'EOL'
+    for i in `seq 1 20`; do
+        echo -e "\\0\\0\\0\\0\\r\\n\\0\\0\\0\\0\\a\\e\\b\\f\\t\\v\\'"
+        echo -e "\\000\\001\\002\\003\\004\\005\\006\\007"
+        echo -e "\\010\\011\\012\\013\\014\\015\\016\\017"
+        echo -e "\\020\\021\\022\\023\\024\\025\\026\\027"
+        echo -e "\\030\\031\\032\\033\\034\\035\\036\\037"
+    done
+	STDOUT:
+EOL
+
+# Add the expected results to the testfile.
+for i in `seq 1 20`; do
+    echo -e "\\0\\0\\0\\0\\r\\n\\0\\0\\0\\0\\a\\e\\b\\f\\t\\v\\'"
+    echo -e "\\000\\001\\002\\003\\004\\005\\006\\007"
+    echo -e "\\010\\011\\012\\013\\014\\015\\016\\017"
+    echo -e "\\020\\021\\022\\023\\024\\025\\026\\027"
+    echo -e "\\030\\031\\032\\033\\034\\035\\036\\037"
+done >> "$tt"
+
+# and run the test
+tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
+
+STDOUT:
+
+Processing /tmp/FILE
+ok   /tmp/FILE 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/03-results/33-BinaryHuge.test
===================================================================
--- trunk/test/03-results/33-BinaryHuge.test	2006-02-28 21:32:53 UTC (rev 94)
+++ trunk/test/03-results/33-BinaryHuge.test	2006-02-28 21:53:17 UTC (rev 95)
@@ -0,0 +1,27 @@
+# Ensures that a testfile can contain some arbitrary binary
+# data and the test will still work.  We use every permeutation
+# of 2 1-byte values (64K of data).
+
+# We need to manually create the testfile because Bash will screw 
+# things up if we use a heredoc.
+
+
+MKFILE tt <<-'EOL'
+    perl -e 'for(my $i=0; $i<256; $i++) { for(my $j=0; $j<256; $j++) { print pack("cc", $i, $j); }}'
+    # stdout will be filled in below
+	STDOUT:
+EOL
+
+
+# Add the expected results to the testfile.
+perl -e 'for(my $i=0; $i<256; $i++) { for(my $j=0; $j<256; $j++) { print pack("cc", $i, $j); }}' >> "$tt"
+
+# and run the test
+tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
+
+STDOUT:
+
+Processing /tmp/FILE
+ok   /tmp/FILE 
+
+1 test run, 1 success, 0 failures.





From tmtest-commits at berlios.de  Tue Feb 28 23:03:11 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 23:03:11 +0100
Subject: [Tmtest-commits] [96] trunk: Make --dump-script clean up after itself.
Message-ID: <200602282203.k1SM3BWV006144@sheep.berlios.de>

Revision: 96
Author:   bronson
Date:     2006-02-28 23:03:10 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Make --dump-script clean up after itself.

Modified Paths:
--------------
    trunk/CHANGES
    trunk/main.c
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-28 21:53:17 UTC (rev 95)
+++ trunk/CHANGES	2006-02-28 22:03:10 UTC (rev 96)
@@ -1,5 +1,6 @@
 - Release next version.
 ----
+- --dump-script now cleans up after itself.
 - Now reports in the test results if child was terminated by a signal.
 - Added the INDENT and REPLACE functions to tmlib.
 - Bash3 has made it so that the RE can no longer appear on the same line as

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-02-28 21:53:17 UTC (rev 95)
+++ trunk/main.c	2006-02-28 22:03:10 UTC (rev 96)
@@ -361,7 +361,7 @@
     char buf[BUFSIZ];   // scan buffer for the testfile
     int pipes[2];
     int child;
-	int keepontruckin;
+	int keepontruckin = 0;
     int diffpid;
     int fd = -1;
     int i;
@@ -471,54 +471,58 @@
 
     if(dumpscript) {
         print_template(&test, exec_template, stdout);
-        exit(0);  // screw the kid
-    }
+        // don't want to print a summary of the tests run so make
+        // sure tmtest realizes it's dumping a test.
+        outmode = outmode_dump;
+    } else {
+        // set up the pipes for the parent
+        close(pipes[0]);
+        tochild = fdopen(pipes[1], "w");
+        if(!tochild) {
+            perror("calling fdopen on pipe");
+            exit(runtime_error);
+        }
 
-    // set up the pipes for the parent
-    close(pipes[0]);
-    tochild = fdopen(pipes[1], "w");
-    if(!tochild) {
-        perror("calling fdopen on pipe");
-        exit(runtime_error);
-    }
+        // write the test script to the kid
+        print_template(&test, exec_template, tochild);
+        fclose(tochild);
 
-    // write the test script to the kid
-    print_template(&test, exec_template, tochild);
-    fclose(tochild);
+        // wait for the test to finish
+        i = wait_for_child(child, "test");
+        test.exitsignal = (WIFSIGNALED(i) ? WTERMSIG(i) : 0);
+        test.exitcored = (WIFSIGNALED(i) ? WCOREDUMP(i) : 0);
+        test.exitno = (WIFEXITED(i) ? WEXITSTATUS(i) : 256);
 
-    // wait for the test to finish
-    i = wait_for_child(child, "test");
-    test.exitsignal = (WIFSIGNALED(i) ? WTERMSIG(i) : 0);
-    test.exitcored = (WIFSIGNALED(i) ? WCOREDUMP(i) : 0);
-    test.exitno = (WIFEXITED(i) ? WEXITSTATUS(i) : 256);
+        // read the status file to determine what happened
+        // and store the information in the test struct.
+        scan_status_file(&test);
 
-	// read the status file to determine what happened
-	// and store the information in the test struct.
-	scan_status_file(&test);
+        // process and output the test results
+        switch(outmode) {
+            case outmode_test:
+                test_results(&test);
+                break;
+            case outmode_dump:
+                dump_results(&test);
+                break;
+            case outmode_diff:
+                dump_results(&test);
+                finish_diff(&test, diffpid);
+                break;
+            default:
+                assert(!"Unhandled outmode 2 in run_test()");
+        }
 
-    // process and output the test results
-    switch(outmode) {
-        case outmode_test:
-            test_results(&test);
-            break;
-        case outmode_dump:
-            dump_results(&test);
-            break;
-        case outmode_diff:
-            dump_results(&test);
-            finish_diff(&test, diffpid);
-            break;
-        default:
-            assert(!"Unhandled outmode 2 in run_test()");
+        // if we had to open the testfile to read it, we now close it.
+        // because the scanner is statically allocated, there's no
+        // need to destroy it.
+        if(fd >= 0) {
+            close(fd);
+        }
+
+        keepontruckin = !test.aborted;
     }
 
-    // if we had to open the testfile to read it, we now close it.
-    // because the scanner is statically allocated, there's no
-    // need to destroy it.
-    if(fd >= 0) {
-        close(fd);
-    }
-	keepontruckin = !test.aborted;
     test_free(&test);
 
 	return keepontruckin;





From tmtest-commits at berlios.de  Tue Feb 28 23:05:17 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 28 Feb 2006 23:05:17 +0100
Subject: [Tmtest-commits] [97] trunk/test/02-running/40-Replace.test: Fix 40-Replace.test.
Message-ID: <200602282205.k1SM5HFE006380@sheep.berlios.de>

Revision: 97
Author:   bronson
Date:     2006-02-28 23:05:17 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
Fix 40-Replace.test.  Apparently I forgot to update it after aligning
the columns.  Silly.

Modified Paths:
--------------
    trunk/test/02-running/40-Replace.test
Modified: trunk/test/02-running/40-Replace.test
===================================================================
--- trunk/test/02-running/40-Replace.test	2006-02-28 22:03:10 UTC (rev 96)
+++ trunk/test/02-running/40-Replace.test	2006-02-28 22:05:17 UTC (rev 97)
@@ -25,24 +25,24 @@
 echo $'A\\Q\\Eb:' $'a\\Q\\Eb' | REPLACE $'a\\Q\\Eb' def
 
 STDOUT:
-Abc :  def
-A'b :  def
-A"b :  def
+Abc  :  def
+A'b  :  def
+A"b  :  def
 A''b :  def
 A""b :  def
-A\'b:  def
-A\"b:  def
-A'\b:  def
-A"\b:  def
-A\\b:  def
-A/b:   def
-A.b:   def
-A*b:   def
-A+b:   def
-A$b:   def
-A$$b:  def
-A at b:   def
-D.f:   def
-A\'b:  def
-A\"b:  def
-A\Q\Eb:  def
+A\'b :  def
+A\"b :  def
+A'\b :  def
+A"\b :  def
+A\\b :  def
+A/b  :  def
+A.b  :  def
+A*b  :  def
+A+b  :  def
+A$b  :  def
+A$$b :  def
+A at b  :  def
+D.f  :  def
+A\'b :  def
+A\"b :  def
+A\Q\Eb: def





