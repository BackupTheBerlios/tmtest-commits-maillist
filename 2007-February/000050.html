<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tmtest-commits] [133] trunk: Totally replaced the path handling	code.
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tmtest-commits/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:tmtest-commits%40lists.berlios.de?Subject=Re%3A%20%5BTmtest-commits%5D%20%5B133%5D%20trunk%3A%20Totally%20replaced%20the%20path%20handling%0A%09code.&In-Reply-To=%3C200702171347.l1HDlFZ3027861%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000049.html">
   <LINK REL="Next"  HREF="000051.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tmtest-commits] [133] trunk: Totally replaced the path handling	code.</H1>
    <B>tmtest-commits at lists.berlios.de</B> 
    <A HREF="mailto:tmtest-commits%40lists.berlios.de?Subject=Re%3A%20%5BTmtest-commits%5D%20%5B133%5D%20trunk%3A%20Totally%20replaced%20the%20path%20handling%0A%09code.&In-Reply-To=%3C200702171347.l1HDlFZ3027861%40sheep.berlios.de%3E"
       TITLE="[Tmtest-commits] [133] trunk: Totally replaced the path handling	code.">tmtest-commits at lists.berlios.de
       </A><BR>
    <I>Sat Feb 17 14:47:15 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000049.html">[Tmtest-commits] [132] trunk/zutest.h: Make the 2-arg 1-op macros	look less Forth-like.
</A></li>
        <LI>Next message: <A HREF="000051.html">[Tmtest-commits] [134] trunk: Minor cleanups lying around in an	older tree
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50">[ date ]</a>
              <a href="thread.html#50">[ thread ]</a>
              <a href="subject.html#50">[ subject ]</a>
              <a href="author.html#50">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Revision: 133
Author:   bronson
Date:     2007-02-17 14:46:25 +0100 (Sat, 17 Feb 2007)

Log Message:
-----------
Totally replaced the path handling code.  Excised the globals,
cleaned up a lot of the logic.  Any time I change the path
handling code it's serious pain.

Also changed zutest test dispatch from table-based to function-based.

Modified Paths:
--------------
    trunk/CHANGES
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/main.c
    trunk/pathconv.c
    trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test
    trunk/test/02-running/03-Unit-Fails.test
    trunk/test/02-running/03-Unit-Tests.test
    trunk/test.h
    trunk/units.c
    trunk/units.h
    trunk/vars.c
    trunk/zutest.c
    trunk/zutest.h

Added Paths:
-----------
    trunk/pathstack.c
    trunk/pathstack.h

Removed Paths:
-------------
    trunk/curdir.c
    trunk/curdir.h
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/CHANGES	2007-02-17 13:46:25 UTC (rev 133)
@@ -1,3 +1,4 @@
+- Rewrote the path handling code and gave it some unit tests.
 - Added -f command-line option to print only the failed tests.
 - Made REPLACE handle multiple text substitutions; could only handle 1 before.
 - Got rid of RESULT and all its code.  echo $? from within your test instead.

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/Makefile	2007-02-17 13:46:25 UTC (rev 133)
@@ -28,14 +28,13 @@
 
 COPTS=-g -Wall -Werror
 
+# scanner files
+SCANC=re2c/read.c re2c/read-fd.c re2c/read-mem.c re2c/read-rand.c re2c/scan.c re2c/scan-dyn.c
+SCANH=re2c/read.h re2c/read-fd.h re2c/read-mem.h re2c/read-rand.h re2c/scan.h re2c/scan-dyn.h
+	
 # utilities:
 CSRC+=qscandir.c pathconv.c pathstack.c
 CHDR+=qscandir.h pathconv.h pathstack.h
-# scanner files
-CSRC+=re2c/read.c re2c/read-fd.c re2c/read-mem.c re2c/read-rand.c \
-	re2c/scan.c re2c/scan-dyn.c
-CHDR+=re2c/read.h re2c/read-fd.h re2c/read-mem.h re2c/read-rand.h \
-	re2c/scan.h re2c/scan-dyn.h
 # program files:
 CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c template.c
 CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h
@@ -48,8 +47,8 @@
 
 all: tmtest
 
-tmtest: $(CSRC) $(CHDR) $(INTERMED)
-	$(CC) $(COPTS) $(CSRC) -o tmtest -DVERSION=&quot;$(VERSION)&quot; -DZUTEST
+tmtest: $(CSRC) $(SCANH) $(SCANC) $(CHDR) $(INTERMED)
+	$(CC) $(COPTS) $(CSRC) $(SCANC) -o tmtest -DVERSION=&quot;$(VERSION)&quot;
 
 template.c: template.sh cstrfy
 	./cstrfy -n exec_template &lt; template.sh &gt; template.c
@@ -65,10 +64,18 @@
 test: tmtest
 	./tmtest --run-unit-tests
 	tmtest test
+	
+# Sometimes the app won't compile but we still want to run the unit tests...
+units: compare.c pathstack.c units.c units.h zutest.c zutest.h $(SCANH) $(SCANC) Makefile
+	$(CC) -g -Wall compare.c pathstack.c pathconv.c units.c zutest.c $(SCANC) -o units -DUNITS_MAIN
 
-unit: tmtest
-	./tmtest --run-unit-tests
+run-units: units
+	./units
 
+# todo -- when global variables are worked out, just compile everything
+#units: $(CSRC) $(CHDR) $(SCANH) $(SCANC) Makefile
+#	$(CC) $(COPTS) $(CSRC) $(SCANC) -o units -DUNITS_MAIN
+
 install: tmtest
 	install -d -m755 $(bindir)
 	install tmtest $(bindir)

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/TODO	2007-02-17 13:46:25 UTC (rev 133)
@@ -1,4 +1,6 @@
 0.96:
+- Put the zutest macro inside the tests (zutest { ... }) instead of outside.
+- Remove the allfiles and quiet options.
 - Is it possible to separate STDOUT and STDERR?  Maybe stderr comes first
   in the testfile with each line prefixed by :.  Then STDOUT.  No need
   for this delimiter craziness.

Modified: trunk/compare.c
===================================================================
--- trunk/compare.c	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/compare.c	2007-02-17 13:46:25 UTC (rev 133)
@@ -186,7 +186,7 @@
 }
 
 
-#include &quot;zutest.h&quot;
+#include &quot;units.h&quot;
 #include &quot;re2c/read-mem.h&quot;
 #include &quot;re2c/read-rand.h&quot;
 #include &lt;stdlib.h&gt;
@@ -358,13 +358,13 @@
 }
 */
 
-zutest_proc compare_tests[] = {
-	test_empty,
-	test_standard,
-	test_large,
-	test_newlines,
-	test_inc,
-	test_inc_newlines,
-	NULL
+void compare_tests()
+{
+	zutest( test_empty() );
+	zutest( test_standard() );
+	zutest( test_large() );
+	zutest( test_newlines() );
+	zutest( test_inc() );
+	zutest( test_inc_newlines() );
 };
 

Deleted: trunk/curdir.c
===================================================================
--- trunk/curdir.c	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/curdir.c	2007-02-17 13:46:25 UTC (rev 133)
@@ -1,157 +0,0 @@
-/* curdir.c
- * 29 Jan 2005
- * Copyright (C) 2005 Scott Bronson
- *
- * This file is distrubuted under the MIT License
- * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
- *
- * Some simple path handling routines
- *
- * Unfortunately this file got hacked to shreds when tmtest was
- * made to run with /tmp as the constant cwd.  It's pretty
- * incomprehensible and in dire dire DIRE need of a rewrite.
- *
- * There's also now a pretty serious impedance mismatch...
- * The caller must handle all occurrences of &quot;//&quot; &quot;/.&quot;, &quot;..&quot;
- * etc. in the partial path before passing it here.  But
- * that's stupid because properly handling those requires
- * converting the parital to an absolute path before normalizing.
- * This library should normalize the path after catting, then
- * return the number of normalized directories added.  This is
- * pretty decidedly nontrivial, of course, because if I push
- * &quot;..&quot;, a directory gets removed from the path, then I push
- * &quot;dir&quot;, then I pop twice, I need to return to the original
- * directory.
- *
- * So for now, alas, it's hacked in main.c.
- *
- * What this file should have been:
- *
- * A completely flexible path lib.  You can init the path with an
- * arbitrary string or from the cwd.  You can push an arbitrary
- * path onto the end (including &quot;..&quot;) and it will return a pointer
- * to an &quot;undo&quot; struct.  Then, when you want to pop the pushed
- * path, you pass the undo struct, and everything is reverted to
- * the way it was before.  You can push an arbitrary number of
- * times.  Push/pop must always be nested of course.  And, of
- * course, you must be able to save and restore the state of the
- * curdir.  Finally, it should not use globals so multiple threads
- * etc. can all maintain their own curdirs.
- *
- * If we had a module that could do this, main.c could be
- * *drastically* cleaned up.  Sigh.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;assert.h&gt;
-
-#include &quot;curdir.h&quot;
-
-
-static char curdir[CURDIR_SIZE];
-static char *curpart;
-
-
-int curinit(const char *path)
-{
-	if(path) {
-		if(strlen(path)+1 &gt; sizeof(curdir)) {
-			return -1;
-		}
-		strcpy(curdir, path);
-		curpart = NULL;	// don't use partials when inited from a path
-	} else {
-		if(!getcwd(curdir, sizeof(curdir))) {
-			return -1;
-		}
-		curpart = curdir + strlen(curdir) + 1;
-		*curpart = '\0';
-	}
-
-	return 0;
-}
-
-
-/**
- * @returns the number of directories you just pushed.
- * You'll need to pass this value to curpop if you want to pop
- * the same number of directories when you're done.
- */
-
-int curpush(const char *dir)
-{
-	int clen = strlen(curdir);
-	int dlen = strlen(dir);
-	int keep = 1;
-	const char *cp;
-
-	assert(dir);
-	assert(dir[0]);
-	assert(dir[0] != '/');
-
-	// count the number of '/' characters in dir
-	for(cp=dir; (cp=strchr(cp,'/'))!=0; cp++) {
-		keep++;
-	}
-
-	if(clen + dlen + 2 &gt; sizeof(curdir)) {
-		return -1;
-	}
-
-	strcat(curdir, &quot;/&quot;);
-	strcat(curdir, dir);
-
-	return keep;
-}
-
-
-void curpop(int keep)
-{
-	assert(keep&gt;0);
-
-	while(keep) {
-		char *cp = strrchr(curdir, '/');
-		assert(curpart &lt;= cp+1);
-		if(!cp) {
-			// we've run out of slashes.
-			assert(!&quot;out of slashes -- that's bad.&quot;);
-			return;
-		}
-
-		cp[0] = '\0';	// get rid of the slash.
-		cp[1] = '\0';	// blank out curpart or any other ptrs to this dir.
-		keep -= 1;
-	}
-}
-
-
-void cursave(struct cursave *save)
-{
-	strcpy(save-&gt;buf, curdir);
-	save-&gt;part = curpart;
-}
-
-
-void currestore(struct cursave *save)
-{
-	strcpy(curdir, save-&gt;buf);
-	curpart = save-&gt;part;
-}
-
-
-const char *curabsolute()
-{
-	return curdir;
-}
-
-
-const char *currelative()
-{
-	return curpart ? curpart : curdir;
-}
-
-
-

Deleted: trunk/curdir.h
===================================================================
--- trunk/curdir.h	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/curdir.h	2007-02-17 13:46:25 UTC (rev 133)
@@ -1,25 +0,0 @@
-/* curdir.h
- * 29 Jan 2005
- * Copyright (C) 2005 Scott Bronson
- * 
- * Some simple path handling routines.
- * See curdir.c for license.
- */
-
-
-#define CURDIR_SIZE PATH_MAX
-
-
-struct cursave {
-	char buf[CURDIR_SIZE];
-	char *part;
-};
-
-int curinit(const char *path);
-int curpush(const char *dir);
-void curpop(int keep);
-void cursave(struct cursave *save);
-void currestore(struct cursave *save);
-const char *curabsolute();
-const char *currelative();
-

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/main.c	2007-02-17 13:46:25 UTC (rev 133)
@@ -27,11 +27,11 @@
 #include &quot;re2c/read-fd.h&quot;
 
 #include &quot;test.h&quot;
-#include &quot;curdir.h&quot;
 #include &quot;qscandir.h&quot;
 #include &quot;vars.h&quot;
 #include &quot;tfscan.h&quot;
 #include &quot;pathconv.h&quot;
+#include &quot;pathstack.h&quot;
 #include &quot;units.h&quot;
 
 
@@ -47,16 +47,13 @@
 };
 
 int outmode = outmode_test;
-int allfiles = 0;
-int dumpscript = 0;
+int allfiles = 0;			// run a testfile even if it begins with a dash
+int dumpscript = 0;			// print the script instead of running it
 int quiet = 0;
 const char *orig_cwd;		// tmtest runs with the cwd pointed to /tmp
 char *config_file;	// absolute path to the user-specified config file
 					// null if user didn't specify a config file.
 
-int arg_was_absolute;	// this is an absolutely awful hack.  it's true
-		// if the current path is absolute, false if it's relative.
-
 #define TESTDIR &quot;/tmp/tmtest-XXXXXX&quot;
 char g_testdir[sizeof(TESTDIR)];
 
@@ -304,8 +301,10 @@
     int pipes[2];
     int child;
 	const char *filename = NULL;
+	char buf[PATH_MAX];
+	struct pathstack stack;
 
-    assert(test-&gt;testfilename);
+	assert(test-&gt;testfilename);
 	// if the test is coming from stdin, we need to copy it to a
 	// real file before we can diff against it.
     if(is_dash(test-&gt;testfilename)) {
@@ -314,13 +313,14 @@
 		// then, read the test from this file instead of stdin.
 		filename = test-&gt;diffname;
 		assert(filename);
+		assert(filename[0]);
     }
-
+		
     if(pipe(pipes) &lt; 0) {
         perror(&quot;creating diff pipe&quot;);
         exit(runtime_error);
     }
-
+    
     child = fork();
     if(child &lt; 0) {
         perror(&quot;forking diff&quot;);
@@ -333,30 +333,25 @@
         }
         close(pipes[0]);
         close(pipes[1]);
-
-		if(!filename) {
-			// figure out the filename that diff will use
-			if(test-&gt;testfilename[0] == '/') {
+        
+        if (!filename) {
+			// need to figure out the filename to pass to diff
+        	if (test-&gt;testfilename[0] == '/') {
+        		// if the path is absolute, we can just use it straight away.
 				filename = test-&gt;testfilename;
 			} else {
-				// since we don't have an absolute path, we need to
-				// cd to the original wd and run the diff with
-				// a relative path.  it takes a bit of computation...
-				curpush(test-&gt;testfilename);
-				filename = strdup(currelative());
-				if(!filename) {
-					perror(&quot;strdup in start_diff&quot;);
-					exit(runtime_error);
-				}
-				curpop(1);
-				if(0 != chdir(curabsolute())) {
-					fprintf(stderr, &quot;Could not chdir 1 to %s: %s\n&quot;,
-							curabsolute(), strerror(errno));
-					exit(runtime_error);
-				}
+				pathstack_init(&amp;stack, buf, sizeof(buf), test-&gt;testfiledir);
+				pathstack_push(&amp;stack, test-&gt;testfilename, NULL);
+				filename = pathstack_absolute(&amp;stack);
 			}
 		}
 
+		if(0 != chdir(test-&gt;testfiledir)) {
+			fprintf(stderr, &quot;Could not chdir 1 to %s: %s\n&quot;,
+					test-&gt;testfiledir, strerror(errno));
+			exit(runtime_error);
+		}
+
         execl(DIFFPROG, DIFFPROG, &quot;-u&quot;, filename, &quot;-&quot;, (char*)NULL);
         perror(&quot;executing &quot; DIFFPROG &quot; for test&quot;);
         exit(runtime_error);
@@ -396,26 +391,60 @@
 }
 
 
+/* Combines testfiledir and testfilename into a single absolute path for the testfile.
+ * The caller must supply a buffer to fill with the result. */
+
+static void assemble_absolute_testpath(struct test *test, char *buf, int bufsiz)
+{
+	buf[0] = '\0';
+	strncat(buf, test-&gt;testfiledir, bufsiz-1);
+	strncat(buf, &quot;/&quot;, bufsiz-1);
+	strncat(buf, test-&gt;testfilename, bufsiz-1);
+}
+
+
 /* Prints the relative path from the original cwd to the current testfile */
 
 static void print_test_path(struct test *test)
 {
 	char result[PATH_MAX];
+	char testfile[PATH_MAX];
+	
+	assemble_absolute_testpath(test, testfile, sizeof(testfile));
 
-	int keep = curpush(test-&gt;testfilename);
-	if(keep &lt;= 0) {
-		printf(&quot;print_test_path: path is too long!\n&quot;);
-		return;
-	}
-
-	if(abs2rel(curabsolute(), orig_cwd, result, sizeof(result))) {
+	if(abs2rel(testfile, orig_cwd, result, sizeof(result))) {
 		printf(&quot;%s\n&quot;, result);
 	} else {
-		printf(&quot;print_test_path: abs2rel error: %s relto %s\n&quot;,
-			curabsolute(), orig_cwd);
+		printf(&quot;print_test_path: abs2rel error: %s relto %s\n&quot;, testfile, orig_cwd);
 	}
+}
 
-	curpop(keep);
+static int open_test_file(struct test *test)
+{
+	char buf[PATH_MAX];
+	int fd;
+	
+	// If the filename is a dash then we just use stdin.
+	if(is_dash(test-&gt;testfilename)) {
+        return STDIN_FILENO;
+    }
+    
+	if(test-&gt;testfilename[0] == '/') {
+	    // If the filename is absolute, we use it directly.
+	    strncpy(buf, test-&gt;testfilename, sizeof(buf));
+	    buf[sizeof(buf)-1] = 0;
+	} else {
+		// Otherwise we need to make an absolute path
+		assemble_absolute_testpath(test, buf, sizeof(buf));
+	}
+	
+	fd = open(buf, O_RDONLY);
+    if(fd &lt; 0) {
+        fprintf(stderr, &quot;Could not open %s: %s\n&quot;, buf, strerror(errno));
+        exit(runtime_error);
+    }
+    
+    return fd;
 }
 
 
@@ -438,7 +467,7 @@
  * @returns 1 if we should keep testing, 0 if we should stop now.
  */
 
-static int run_test(const char *name, const char *dispname, int warn_suffix)
+static int run_test(const char *path, const char *name, const char *dispname, int warn_suffix)
 {
     struct test test;
     char buf[BUFSIZ];   // scan buffer for the testfile
@@ -475,6 +504,7 @@
 	}
 
     test.testfilename = name;
+    test.testfiledir = path;
     test.outfd = g_outfd;
     test.errfd = g_errfd;
     test.statusfd = g_statusfd;
@@ -537,26 +567,8 @@
 			exit(runtime_error);
 		}
         readfd_attach(&amp;test.testfile, test.diff_fd);
-	} else if(is_dash(name)) {
-        readfd_attach(&amp;test.testfile, STDIN_FILENO);
-    } else {
-		if(name[0] == '/') {
-			fd = open(name, O_RDONLY);
-		} else {
-			int keep = curpush(name);
-			if(keep &lt;= 0) {
-				fprintf(stderr, &quot;Path is too long.&quot;);
-				exit(runtime_error);
-			}
-			fd = open(curabsolute(), O_RDONLY);
-			curpop(keep);
-		}
-        if(fd &lt; 0) {
-            fprintf(stderr, &quot;Could not open %s: %s\n&quot;,
-                    curabsolute(), strerror(errno));
-            exit(runtime_error);
-        }
-        readfd_attach(&amp;test.testfile, fd);
+	} else {
+        readfd_attach(&amp;test.testfile, open_test_file(&amp;test));
     }
     tfscan_attach(&amp;test.testfile);
 
@@ -625,44 +637,6 @@
 }
 
 
-/** This routine filters out any dirents that begin with '.'.
- *  We don't want to process any hidden files or special directories.
- */
-
-static int select_nodots(const struct dirent *d)
-{
-    return d-&gt;d_name[0] != '.';
-}
-
-
-/**
- * Sucks the dirname from an absolute file path and calls curinit with it.
- */
-
-static void init_absolute_filepath(const char *path)
-{
-	const char *cp;
-	int loc;
-	char buf[PATH_MAX];
-	
-	cp = strrchr(path, '/');
-	if(cp == NULL) {
-		fprintf(stderr, &quot;Illegal absolute path '%s'\n&quot;, path);
-		exit(runtime_error);
-	}
-
-	strncpy(buf, path, sizeof(buf));
-
-	loc = cp - path;
-	if(sizeof(buf)-1 &lt; loc) {
-		loc = sizeof(buf)-1;
-	}
-
-	buf[loc] = '\0';
-	curinit(buf);
-}
-
-
 /** Processes a directory specified using an absolute or deep
  * path.  We need to save and restore curpath to do this.
  *
@@ -672,93 +646,70 @@
  * @returns 1 if we should continue testing, 0 if we should abort.
  */
 
-static int process_absolute_file(const char *path, int warn_suffix)
+static int process_absolute_file(const char *abspath, const char *origpath, int warn_suffix)
 {
-	struct cursave save;
-	int keepontruckin;
-
-	cursave(&amp;save);
-	init_absolute_filepath(path);
-
-	keepontruckin = run_test(strrchr(path,'/')+1, path, warn_suffix);
-
-	currestore(&amp;save);
-	return keepontruckin;
-}
-
-
-static void init_path(const char *base, const char *path)
-{
 	char buf[PATH_MAX];
+	struct pathstack stack;
+	char *file, *dir;
 
-	strncpy(buf, curabsolute(), PATH_MAX);
-	strncat(buf, &quot;/&quot;, PATH_MAX);
-	strncat(buf, path, PATH_MAX);
-	buf[PATH_MAX-1] = '\0';
-
-	normalize_absolute_path(buf);
-
-	curinit(buf);
+	pathstack_init(&amp;stack, buf, sizeof(buf), abspath);
+	pathstack_normalize(&amp;stack);
+	
+	dir = pathstack_absolute(&amp;stack);
+	file = strrchr(dir, '/');
+	if(!file) {
+		fprintf(stderr, &quot;Path wasn't absolute in process_absolute file!?  %s\n&quot;, abspath);
+		return 0;
+	}
+	
+	*file++ = '\0';		// separate the path and the filename
+	// If the file was in the root directory, ensure we don't blow away
+	// the leading slash.
+	if(dir[0] == '\0') {
+		dir = &quot;/&quot;;
+	}
+	
+	return run_test(dir, file, origpath, warn_suffix);
 }
 
 
+// forward declaration for recursion
+int process_dir(struct pathstack *ps, int print_absolute);
 
-/**
- * This is actually a hassle.  The user may have specified
- * &quot;../..&quot; which means we need to normalize an absolute path
- * and use that.
- */
 
-static int process_deep_file(const char *path, int warn_suffix)
+static int process_absolute_dir(const char *abspath, const char *origpath, int print_absolute)
 {
-	struct cursave save;
-	int keepontruckin;
+	char buf[PATH_MAX];
+	struct pathstack stack;
 
-	cursave(&amp;save);
-	init_path(orig_cwd, path);
-	curpop(1);	// get rid of the filename
-
-	keepontruckin = run_test(strrchr(path,'/')+1, path, warn_suffix);
-
-	currestore(&amp;save);
-	return keepontruckin;
-}
-
-
-// forward declaration for recursion
-int process_dir();
-
-static int process_absolute_dir(const char *path)
-{
-	struct cursave save;
-	int keepontruckin;
-
-	cursave(&amp;save);
-	curinit(path);
-
-	// we are certain the fullpath has already been normalized.
-	// no need to do it again.
-
 	if(outmode == outmode_test) {
-		printf(&quot;\nProcessing %s\n&quot;, path);
+		if(print_absolute) {
+			printf(&quot;\nProcessing %s\n&quot;, abspath);
+		} else {
+			printf(&quot;\nProcessing ./%s\n&quot;, origpath);
+		}
 	}
-	keepontruckin = process_dir();
-
-	currestore(&amp;save);
-
-	return keepontruckin;
+	
+	pathstack_init(&amp;stack, buf, sizeof(buf), abspath);
+	pathstack_normalize(&amp;stack);
+	return process_dir(&amp;stack, print_absolute);
 }
 
 
-static void print_relative_dir()
+static void print_relative_dir(struct pathstack *ps, int print_absolute)
 {
 	char buf[PATH_MAX];
+	
+	// Don't print anything unless we're actually testing.
+    if(outmode != outmode_test) {
+    	return;
+    }
 
-	if(arg_was_absolute) {
-		printf(&quot;\nProcessing %s\n&quot;, curabsolute());
+	if(print_absolute) {
+		printf(&quot;\nProcessing %s\n&quot;, pathstack_absolute(ps));
 	} else {
-		if(!abs2rel(curabsolute(), orig_cwd, buf, PATH_MAX)) {
-			printf(&quot;Path couldn't be converted \&quot;\%s\&quot;\n&quot;, curabsolute());
+		if(!abs2rel(pathstack_absolute(ps), orig_cwd, buf, PATH_MAX)) {
+			printf(&quot;Path couldn't be converted \&quot;\%s\&quot;\n&quot;, pathstack_absolute(ps));
 			exit(runtime_error);
 		}
 		printf(&quot;\nProcessing ./%s\n&quot;, buf);
@@ -766,49 +717,25 @@
 }
 
 
-/**
- * This routine used to be a simple &quot;push the dir onto curpath,
- * run, and pop&quot; affair.  Now, with &quot;..&quot; being fairly nontrivial,
- * we just need to save and restore.  Arg.  But at least this
- * works.
- *
- * The relative path can't be normalied because it might be
- * simply &quot;..&quot;.  Therefore, it's one above whatever the cwd
- * is.  Gotta figure that out at runtime.
- */
-
-static int process_relative_dir(const char *path)
-{
-	struct cursave save;
-	int keepontruckin;
-
-	cursave(&amp;save);
-	init_path(curabsolute(), path);
-
-	if(outmode == outmode_test) {
-		print_relative_dir();
-	}
-	keepontruckin = process_dir();
-
-	currestore(&amp;save);
-
-	return keepontruckin;
-}
-
-
 /** Process all entries in a directory.
  *
- * @param is_topmost True if we are not recursing.  This allows us to
- * tell whether we should display pathnames absolute or relative
- * (if the user specified them relative on the command line, we
- * show them relative, and vice versa).
+ * @param ps The pathstack to use.  It comes pre-set-up with whatever
+ * basedir we should be running from (where the ents are found).
+ * This will be used during processing but is guaranteed to be
+ * returned in exactly the same state as it was passed in.
+ * @param ents The list of entries to process.
+ * @param print_absolute tells if you want the user-visible path to
+ * be printed absolute or relative.  -1 means that you don't know,
+ * and process_ents should decide on its own for each ent (if the
+ * ent is absolute then all paths will be absolute).
  */
 
-static int process_ents(char **ents, int is_topmost)
+static int process_ents(struct pathstack *ps, char **ents, int print_absolute)
 {
 	struct stat st;
+	struct pathstate save;
     mode_t *modes;
-    int i, n;
+    int i, n, ret;
 	int keepontruckin;
 
     for(n=0; ents[n]; n++)
@@ -820,18 +747,17 @@
         exit(runtime_error);
     }
     
-    // first collect the stat info for each entry
+    // first collect the stat info for each entry and perform a quick sanity check
     for(i=0; i&lt;n; i++) {
         if(!is_dash(ents[i])) {
 			const char *cp = ents[i];
-			int keep = 0;
 			if(ents[i][0] != '/') {
-				keep = curpush(ents[i]);
-				if(keep &lt;= 0) {
-					fprintf(stderr, &quot;Path is too long.&quot;);
+				ret = pathstack_push(ps, ents[i], &amp;save);
+				if(ret != 0) {
+					fprintf(stderr, &quot;Paths are too long:\n   %s\n   %s\n&quot;, pathstack_absolute(ps), ents[i]);
 					exit(runtime_error);
 				}
-				cp = curabsolute();
+				cp = pathstack_absolute(ps);
 			}
 			// Need to be careful to test that file does exist.
 			// Bash opens it, not us, so the error message might
@@ -839,21 +765,29 @@
 			if(!verify_readable(cp,&amp;st,0)) {
                 exit(runtime_error);
             }
-			if(ents[i][0] != '/') curpop(keep);
+			if(ents[i][0] != '/') {
+				pathstack_pop(ps, &amp;save);
+			}
             modes[i] = st.st_mode;
         }
     }
-
+    
     // process all files in dir
     for(i=0; i&lt;n; i++) {
         if(is_dash(ents[i]) || S_ISREG(modes[i])) {
 			if(ents[i][0] == '/') {
 				// we know the path has already been fully normalized.
-				keepontruckin = process_absolute_file(ents[i], is_topmost);
-			} else if(strchr(ents[i], '/')) {
-				keepontruckin = process_deep_file(ents[i], is_topmost);
+				assert(print_absolute == -1);	// it should be impossible to get here if we've already recursed
+				keepontruckin = process_absolute_file(ents[i], ents[i], 1);
 			} else {
-				keepontruckin = run_test(ents[i], ents[i], is_topmost);
+				if(strchr(ents[i], '.') || strchr(ents[i], '/')) {
+					// if there are potential non-normals in the path, we need to normalize it.
+					ret = pathstack_push(ps, ents[i], &amp;save);
+					keepontruckin = process_absolute_file(pathstack_absolute(ps), ents[i], print_absolute == -1);
+					pathstack_pop(ps, &amp;save);
+				} else {
+					keepontruckin = run_test(pathstack_absolute(ps), ents[i], ents[i], print_absolute == -1);
+				}
 			}
 			if(!keepontruckin) {
 				goto abort;
@@ -866,16 +800,23 @@
     for(i=0; i&lt;n; i++) {
         if(is_dash(ents[i]) || modes[i] == 0) continue;
         if(S_ISDIR(modes[i])) {
-			if(is_topmost) {
-				// this is an unfortunate hack.  we display the path the same
-				// way the user specified (absolute or relative) so we need
-				// to remember which one it is.
-				arg_was_absolute = (ents[i][0] == '/');
-			}
 			if(ents[i][0] == '/') {
-				keepontruckin = process_absolute_dir(ents[i]);
+				assert(print_absolute == -1);	// it should be impossible to get here if we've already recursed
+				keepontruckin = process_absolute_dir(ents[i], ents[i], 1);
 			} else {
-				keepontruckin = process_relative_dir(ents[i]);
+				if(print_absolute == -1) print_absolute = 0;
+				if(strchr(ents[i], '.') || strchr(ents[i], '/')) {
+					// if there are potential non-normals in the path, we need to normalize it.
+					ret = pathstack_push(ps, ents[i], &amp;save);
+					keepontruckin = process_absolute_dir(pathstack_absolute(ps), ents[i], print_absolute);
+					pathstack_pop(ps, &amp;save);
+				} else {
+					// Otherwise, we just push the path and chug.
+					ret = pathstack_push(ps, ents[i], &amp;save);
+					print_relative_dir(ps, print_absolute);
+					keepontruckin = process_dir(ps, print_absolute);
+					pathstack_pop(ps, &amp;save);
+				}
 			}
 			if(!keepontruckin) {
 				goto abort;
@@ -889,22 +830,31 @@
 }
 
 
+/** This routine filters out any dirents that begin with '.'.
+ *  We don't want to process any hidden files or special directories.
+ */
+
+static int select_nodots(const struct dirent *d)
+{
+    return d-&gt;d_name[0] != '.';
+}
+
+
 /** Runs all tests in the current directory and all its subdirectories.
  */
 
-int process_dir()
+int process_dir(struct pathstack *ps, int print_absolute)
 {
     char **ents;
-    int i;
-	int keepontruckin;
+    int i, keepontruckin;
 
-    ents = qscandir(curabsolute(), select_nodots, qdirentcoll);
+    ents = qscandir(pathstack_absolute(ps), select_nodots, qdirentcoll);
     if(!ents) {
         // qscandir has already printed the error message
         exit(runtime_error);
     }
 
-    keepontruckin = process_ents(ents, 0);
+    keepontruckin = process_ents(ps, ents, print_absolute);
 
     for(i=0; ents[i]; i++) {
         free(ents[i]);
@@ -976,11 +926,6 @@
     g_statusfd = open_file(g_statusname, STATUSNAME, O_APPEND);
 	assert(strlen(g_statusname) == sizeof(g_statusname)-1);
 
-	if(curinit(NULL) != 0) {
-		fprintf(stderr, &quot;Could not get the cwd: %s\n&quot;, strerror(errno));
-		exit(initialization_error);
-	}
-
 	// tmtest always runs with the CWD pointed to the temporary directory
 	cp = getenv(&quot;TMPDIR&quot;);
 	if(!cp) cp = &quot;/tmp&quot;;
@@ -1106,11 +1051,11 @@
 				break;
 
 			case 'U':
-				run_unit_tests(all_unit_tests);
+				run_unit_tests(run_all_unit_tests);
 				exit(0);
 
 			case 257:
-				run_unit_tests_showing_failures(all_unit_tests);
+				run_unit_tests_showing_failures(run_all_unit_tests);
 				exit(0);
 
 			case 'V':
@@ -1133,7 +1078,8 @@
 }
 
 
-/*
+/* normalize_path
+ * 
  * I wish I could use canonicalize_path(3), but that routine resolves
  * symbolic links and provides no way to turn that behavior off.
  * How stupid!  This isn't as much of a hack as it looks because
@@ -1142,9 +1088,11 @@
  * @param original: the path to be normalized
  * @param outpath: the normalized path.  this may or may not be the same
  *     as original.
+ * 
+ * TODO: how about hitting this routine with some unit tests?
  */
 
-static void normalize_path(char *original, char **outpath)
+static void normalize_path(struct pathstack *ps, char *original, char **outpath)
 {
     char buf[PATH_MAX];
     char normalized[PATH_MAX];
@@ -1157,7 +1105,7 @@
 		strcpy(normalized, original);
 		normalize_absolute_path(normalized);
     } else {
-        strncpy(buf, curabsolute(), PATH_MAX);
+        strncpy(buf, pathstack_absolute(ps), PATH_MAX);
 		strncat(buf, &quot;/&quot;, PATH_MAX);
 		strncat(buf, original, PATH_MAX);
 		buf[PATH_MAX-1] = '\0';
@@ -1166,7 +1114,7 @@
 		// convert it back to a relative path so it prints the
 		// way the user intends.  We need to beware later on
 		// to trim .. from the leading path.
-		if(!abs2rel(buf, curabsolute(), normalized, PATH_MAX)) {
+		if(!abs2rel(buf, pathstack_absolute(ps), normalized, PATH_MAX)) {
             fprintf(stderr, &quot;Could not reabsize %s: %s\n&quot;,
 				original, strerror(errno));
 			exit(runtime_error);
@@ -1195,18 +1143,20 @@
  * and modify that.
  */
 
-static void process_argv(char **argv)
+static void process_argv(struct pathstack *ps, char **argv)
 {
 	char **ents;
-	int i, n;
+	int i, n, oldlen;
 
     for(n=0; argv[n]; n++) { }
 
 	ents = malloc((n+1)*sizeof(*ents));
 	ents[n] = NULL;
-
-	for(i=0; i&lt;n; i++) { normalize_path(argv[i], &amp;ents[i]); }
-	process_ents(ents, 1);
+	
+	for(i=0; i&lt;n; i++) { normalize_path(ps, argv[i], &amp;ents[i]); }
+	oldlen = ps-&gt;curlen;
+	process_ents(ps, ents, -1);
+	assert(oldlen == ps-&gt;curlen);	// process_ents needs to not modify the pathstack.
 	for(i=0; i&lt;n; i++) { normalize_free(argv[i], ents[i]); }
 
 	free(ents);
@@ -1232,17 +1182,22 @@
 
 int main(int argc, char **argv)
 {
+	char buf[PATH_MAX];
+	struct pathstack pathstack;
+	
 	orig_cwd = dup_cwd();
 	process_args(argc, argv);
 
+	pathstack_init(&amp;pathstack, buf, sizeof(buf), orig_cwd);
+
     start_tests();
     if(optind &lt; argc) {
-		process_argv(argv+optind);
+		process_argv(&amp;pathstack, argv+optind);
     } else {
         if(outmode == outmode_test) {
             printf(&quot;\nProcessing .\n&quot;);
         }
-        process_dir();
+        process_dir(&amp;pathstack, 0);
     }
     stop_tests();
 

Modified: trunk/pathconv.c
===================================================================
--- trunk/pathconv.c	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/pathconv.c	2007-02-17 13:46:25 UTC (rev 133)
@@ -32,12 +32,7 @@
  *	r)		!= NULL: relative path
  *			== NULL: error
  */
-char *
-abs2rel(path, base, result, size)
-	const char *path;
-	const char *base;
-	char *result;
-	const size_t size;
+char* abs2rel(const char *path, const char *base, char *result, const size_t size)
 {
 	const char *pp, *bp, *branch;
 	/*
@@ -108,7 +103,7 @@
 }
 
 
-// Copyright (c) 2006 Scott Bronson
+// The following code is Copyright (c) 2006 Scott Bronson
 // The following code can be distributed under the LGPL as above
 // or, at your option, the much simpler MIT license.
 
@@ -120,7 +115,8 @@
  * to walk two pointers through the string copying bits from the
  * src to the dst so I don't spend so much time moving the same
  * bytes over and over.  Alas, I'm out of time so I'm going to
- * resort to this loathesome coding style for less chance of bugs.
+ * resort to this loathesome memmove coding style so I can spend
+ * less time debugging.
  *
  * @returns 1 if this was a relative path and therefore the function
  * did nothing.  Otherwise returns 0.

Added: trunk/pathstack.c
===================================================================
--- trunk/pathstack.c	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/pathstack.c	2007-02-17 13:46:25 UTC (rev 133)
@@ -0,0 +1,328 @@
+/* pathstack.c
+ * 14 Feb 2007
+ * Copyright (C) 2007 Scott Bronson
+ *
+ * This file is distrubuted under the MIT License
+ * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
+ *
+ * Some simple path handling routines
+ * 
+ * A pathstack is just like a regular stack, except you push and pull
+ * path fragments.  The only slightly strange concept is the pathstack_state
+ * used to &quot;rewind&quot; a push.
+ */
+
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+#include &lt;limits.h&gt;
+#include &quot;pathstack.h&quot;
+#include &quot;pathconv.h&quot;
+
+
+/** pathstack_init
+ *
+ * Initializes a pathstack for use.  You must supply a buffer and an
+ * optional string to initialize it with.  The buffer must be able to
+ * hold at least a single character (for the null terminator).
+ * 
+ * We never allocate any memory so there's no need for a pathstack_free.
+ */
+
+void pathstack_init(struct pathstack *ps, char *buf,
+                    int bufsiz, const char *str)
+{
+    assert(ps);
+    assert(bufsiz &gt; 1);	  // bufsiz must hold &quot;/&quot; and the null terminator.
+
+    ps-&gt;buf = buf;
+    ps-&gt;maxlen = bufsiz - 1;
+    if(str) {
+    	assert(str[0] == '/');	// ensure it's an absolute path
+        ps-&gt;curlen = strlen(str);
+        if(ps-&gt;curlen &gt; ps-&gt;maxlen) {
+            ps-&gt;curlen = ps-&gt;maxlen;
+        }
+        strncpy(ps-&gt;buf, str, ps-&gt;curlen);
+    } else {
+        ps-&gt;curlen = 1;
+        ps-&gt;buf[0] = '/';
+    }
+    ps-&gt;buf[ps-&gt;curlen] = '\0';
+}
+
+
+/** pathstack_push
+ * 
+ * Adds the given relative path onto the end of the absolute path.
+ * 
+ * If the relative path won't fit, we'll push as much as possible and return -1.
+ * It's illegal for the relative path to be NULL or empty.
+ * 
+ * If the existing path doesn't end with a '/' and the new path doesn't begin
+ * with one, a slash will be automatically added to separate the two paths.
+ * 
+ * @param state is optional but, if supplied, specifies a place to hold state.
+ * The state can then be passed to pathstack_pop() to return the pathstack to
+ * its state before pushing.
+ * 
+ * @return 0 if everything went OK, -1 if the result had to be truncated.
+ * It's perfectly safe to ignore the return value.
+ */
+
+int pathstack_push(struct pathstack *ps, const char *newpath,
+                   struct pathstate *state)
+{
+    int pathlen = strlen(newpath);
+
+    assert(ps);
+    assert(newpath);
+
+    // First, save the state if requested
+    if (state) {
+        state-&gt;oldlen = ps-&gt;curlen;
+    }
+
+    // if there's no room for even a single character, bail.
+    if(ps-&gt;curlen == ps-&gt;maxlen) {
+        return -1;
+    }
+    // if the new string is empty then we don't change a thing
+    if(newpath[0] == '\0') {
+    	return 0;
+    }
+
+    // ensure the two paths are separated by '/'
+    if(ps-&gt;buf[ps-&gt;curlen-1] != '/' &amp;&amp; newpath[0] != '/') {
+        ps-&gt;buf[ps-&gt;curlen] = '/';
+        ps-&gt;curlen += 1;
+    }
+
+	// and copy the new string
+    if(ps-&gt;curlen + pathlen &gt; ps-&gt;maxlen) {
+    	pathlen = ps-&gt;maxlen - ps-&gt;curlen;
+    }
+    memcpy(ps-&gt;buf+ps-&gt;curlen, newpath, pathlen);
+    ps-&gt;curlen += pathlen;
+    ps-&gt;buf[ps-&gt;curlen] = '\0';
+    
+    return 0;
+}
+
+
+/** pathstack_pop
+ * 
+ * Removes the most recent addition from the pathstack.
+ * 
+ * Returns -1 if the state was invalid.
+ * 
+ * If you don't supply a state, this function is a no-op.
+ * (originally it was going to remove the topmost path item)
+ */
+
+
+int pathstack_pop(struct pathstack *ps, struct pathstate *state)
+{
+	if(state) {
+		if(state-&gt;oldlen &gt; ps-&gt;curlen) {
+			// we can't enlarge the string using state; we'd expose invalid data.
+			return -1;
+		}
+		ps-&gt;curlen = state-&gt;oldlen;
+		state-&gt;oldlen = INT_MAX;	// ensure this state can never be used again
+	} else {
+		// popping without supplying state is currently a no-op...
+		// implement this later if needed.
+	}
+	
+    ps-&gt;buf[ps-&gt;curlen] = '\0';
+    return 0;
+}
+
+
+/** pathstack_normalize
+ *
+ * Normalizes the path stored in the pathstack.
+ * NOTE: Never ever call pathstack_push, normalize the stack, and then
+ * call pathstack_pop!!  Normalizing will potentially change the path,
+ * invalidating the offsets stored in the pathstate structs.
+ * 
+ * TODO: add some unit tests for this!
+ */
+ 
+void pathstack_normalize(struct pathstack *ps)
+{
+	normalize_absolute_path(ps-&gt;buf);
+    ps-&gt;curlen = strlen(ps-&gt;buf);
+}
+
+
+// unit testing
+
+#ifndef NOUNITS
+#include &quot;units.h&quot;
+
+// We don't try popping without state since we don't care about that case.
+
+static void test_pathstack()
+{
+	int ret;
+	char buf[23];
+	struct pathstack stack, *ps = &stack;
+	struct pathstate save1, save2, save3;
+	const char *origstr = &quot;/tryit&quot;;
+	
+	int bufsiz = sizeof(buf) - 1;	// we pretend the buffer is 1 char smaller than it really is
+	buf[sizeof(buf)-1] = 127;		// so we can add a sentinel to see if it overflowed.
+		// therefore, buffer can hold 23 characters, bufsiz is only 22, and the entire buffer
+		// can hold a maximum of 21 characters including the leading '/'.
+	
+	// init the pathstack
+	pathstack_init(ps, buf, bufsiz, origstr);
+	AssertEqual(ps-&gt;curlen, strlen(origstr));
+	AssertEqual(ps-&gt;maxlen, bufsiz-1);
+	AssertStrEqual(ps-&gt;buf, origstr);
+	
+	
+	// push an actual string
+	ret = pathstack_push(ps, &quot;/next&quot;, &amp;save1);
+	AssertZero(ret);
+	AssertEqual(save1.oldlen, strlen(origstr));
+	AssertEqual(ps-&gt;maxlen, bufsiz-1);
+	AssertStrEqual(ps-&gt;buf, &quot;/tryit/next&quot;);
+	
+	// and pop it
+	ret = pathstack_pop(ps, &amp;save1);
+	AssertZero(ret);
+	AssertEqual(ps-&gt;curlen, strlen(origstr));
+	AssertEqual(ps-&gt;maxlen, bufsiz-1);
+	AssertStrEqual(ps-&gt;buf, origstr);
+	
+	
+	// push an empty string
+	ret = pathstack_push(ps, &quot;&quot;, &amp;save1);
+	AssertZero(ret);
+	AssertEqual(ps-&gt;curlen, strlen(origstr));
+	AssertEqual(ps-&gt;maxlen, bufsiz-1);
+	AssertStrEqual(ps-&gt;buf, origstr);
+	
+	// and pop it.
+	ret = pathstack_pop(ps, &amp;save1);
+	AssertZero(ret);
+	AssertEqual(ps-&gt;curlen, strlen(origstr));
+	AssertEqual(ps-&gt;maxlen, bufsiz-1);
+	AssertStrEqual(ps-&gt;buf, origstr);
+	
+	
+	// push a series of strings, hit the end of the buffer
+	ret = pathstack_push(ps, &quot;next/&quot;, &amp;save1);
+	AssertZero(ret);
+	ret = pathstack_push(ps, &quot;n&quot;, &amp;save2);
+	AssertZero(ret);
+	ret = pathstack_push(ps, &quot;123456789&quot;, &amp;save3);
+	AssertZero(ret);
+	
+	//                       123456789012345678901ns  (n: null terminator, s: sentinel)
+	AssertStrEqual(ps-&gt;buf, &quot;/tryit/next/n/1234567&quot;);
+	AssertEqual(ps-&gt;curlen, ps-&gt;maxlen);
+	AssertEqual(ps-&gt;maxlen, bufsiz-1);
+	
+	// and pop it
+	ret = pathstack_pop(ps, &amp;save3);
+	AssertZero(ret);
+	ret = pathstack_pop(ps, &amp;save2);
+	AssertZero(ret);
+	
+	// Ensure that an out-of-order pop gets ignored
+	ret = pathstack_pop(ps, &amp;save3);
+	AssertEqual(ret, -1);
+	AssertStrEqual(ps-&gt;buf, &quot;/tryit/next/&quot;);
+	
+	ret = pathstack_pop(ps, &amp;save1);
+	AssertZero(ret);
+	
+	AssertEqual(ps-&gt;curlen, strlen(origstr));
+	AssertEqual(ps-&gt;maxlen, bufsiz-1);
+	AssertStrEqual(ps-&gt;buf, origstr);
+	
+	// ensure we can push without saving state without bus erroring
+	ret = pathstack_push(ps, &quot;123&quot;, NULL);
+	// (can't really think of anything to test... the fact that we
+	// reached this line at all means the test succeeded).
+	
+	// And finally, check the sentinel
+	AssertEqual(buf[sizeof(buf)-1], 127);
+}
+
+
+static void test_small_pathstack()
+{
+	struct pathstack stack, *ps = &stack;
+	char buf[6];
+	
+	// Ensures that we won't overflow while initing.
+	// There are probably some other small path ops we should verify.
+	
+	// Pathstacks always need to start with '/'
+	pathstack_init(ps, buf, sizeof(buf), &quot;/23456789&quot;);
+	AssertStrEqual(ps-&gt;buf, &quot;/2345&quot;);	// 5 characters plus the null byte
+	AssertEqual(ps-&gt;curlen, ps-&gt;maxlen);
+}
+
+
+#define AssertStackEmpty(ps) do {				\
+		AssertEqual((ps)-&gt;curlen, 1); 			\
+		AssertEqual((ps)-&gt;maxlen, 1); 			\
+		AssertStrEqual((ps)-&gt;buf, &quot;/&quot;);			\
+	} while(0)
+	
+
+static void test_empty_pathstack()
+{
+	// pathstacks can't actually be empty anymore...  They always
+	// contain at least a leading &quot;/&quot;.
+	
+	int ret;
+	char buf[2];
+	struct pathstack stack, *ps = &stack;
+	struct pathstate save;
+	
+	// is there a way to test that passing a bufsiz of 0 will
+	// cause the assert to trigger?
+	
+	// init the pathstack
+	pathstack_init(ps, buf, sizeof(buf), NULL);
+	AssertStackEmpty(ps);
+	
+	// push an actual string
+	ret = pathstack_push(ps, &quot;/next&quot;, &amp;save);
+	AssertEqual(ret, -1);
+	AssertEqual(save.oldlen, 1);
+	AssertStackEmpty(ps);
+	
+	// and pop it
+	ret = pathstack_pop(ps, &amp;save);
+	AssertZero(ret);
+	AssertStackEmpty(ps);
+	
+	// push an empty string.  It's illegal to push an empty string onto a pathstack.
+	ret = pathstack_push(ps, &quot;&quot;, &amp;save);
+	AssertEqual(ret, -1);
+	AssertEqual(save.oldlen, 1);
+	AssertStackEmpty(ps);
+	
+	// and pop it.
+	ret = pathstack_pop(ps, &amp;save);
+	AssertZero(ret);
+	AssertStackEmpty(ps);
+}
+
+
+void pathstack_tests()
+{
+	zutest( test_pathstack() );
+	zutest( test_small_pathstack() );
+	zutest( test_empty_pathstack() );
+}
+
+#endif

Added: trunk/pathstack.h
===================================================================
--- trunk/pathstack.h	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/pathstack.h	2007-02-17 13:46:25 UTC (rev 133)
@@ -0,0 +1,32 @@
+/* pathstack.h
+ * 14 Feb 2007
+ * Copyright (C) 2007 Scott Bronson
+ * 
+ * Some simple path handling routines.
+ * See pathstack.c for license.
+ */
+
+struct pathstack {
+    char *buf;
+    int curlen;
+    int maxlen;	///&lt; size of buffer - 1 (for null byte)
+};
+
+struct pathstate {
+	int oldlen;
+};
+
+
+void pathstack_init(struct pathstack *path, char *buf,
+                   int bufsiz, const char * str);
+
+// There is no need to ever delete a pathstack because
+// it's 100% client-allocated.
+
+int pathstack_push(struct pathstack *ps, const char *newpath,
+                   struct pathstate *state);
+int pathstack_pop(struct pathstack *ps, struct pathstate *state);
+
+void pathstack_normalize(struct pathstack *ps);
+
+#define pathstack_absolute(ps) ((ps)-&gt;buf)

Modified: trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test	2007-02-17 13:46:25 UTC (rev 133)
@@ -23,7 +23,6 @@
 	echo &quot;$config&quot;
 EOL
 
-
 $tmtest --dump-script &quot;$di/..&quot; | REPLACE &quot;$do&quot; /tmp/DIR | FIX_SCRIPT
 
 

Modified: trunk/test/02-running/03-Unit-Fails.test
===================================================================
--- trunk/test/02-running/03-Unit-Fails.test	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/test/02-running/03-Unit-Fails.test	2007-02-17 13:46:25 UTC (rev 133)
@@ -10,77 +10,77 @@
 # This doesn't work either
 # $tmtest --show-unit-fails &gt; &gt;(sed s/0x[A-Z0-9][A-Z0-9]*/0xHEXDIGIT/g) 2&gt;&amp;1
 
-$tmtest --show-unit-fails 2&gt;&amp;1 | sed s/0x[A-Z0-9][A-Z0-9]*/0xHEXDIGIT/g
+$tmtest --show-unit-fails 2&gt;&amp;1 | sed s/0x[A-Z0-9][A-Z0-9]*/0xHEXDIGIT/g | sed s/zutest.c:[0-9]\*:/zutest.c:NNN:/
 
 STDOUT:
-zutest.c:197: In test_assert_int, assert a == b failed. a==4 and b==3!
-zutest.c:198: In test_assert_int, assert a != c failed. a==4 and c==4!
-zutest.c:199: In test_assert_int, assert a &gt; c failed. a==4 and c==4!
-zutest.c:200: In test_assert_int, assert b &gt; c failed. b==3 and c==4!
-zutest.c:201: In test_assert_int, assert b &gt;= a failed. b==3 and a==4!
-zutest.c:202: In test_assert_int, assert c &lt; a failed. c==4 and a==4!
-zutest.c:203: In test_assert_int, assert c &lt; b failed. c==4 and b==3!
-zutest.c:204: In test_assert_int, assert a &lt;= b failed. a==4 and b==3!
-zutest.c:207: In test_assert_int, assert a == 0 failed. a==4!
-zutest.c:209: In test_assert_int, assert z != 0 failed. z==0!
-zutest.c:212: In test_assert_int, assert z &gt; 0 failed. z==0!
-zutest.c:213: In test_assert_int, assert n &gt; 0 failed. n==-1!
-zutest.c:217: In test_assert_int, assert a &lt;= 0 failed. a==4!
-zutest.c:220: In test_assert_int, assert z &lt; 0 failed. z==0!
-zutest.c:221: In test_assert_int, assert a &lt; 0 failed. a==4!
-zutest.c:225: In test_assert_int, assert n &gt;= 0 failed. n==-1!
-zutest.c:242: In test_assert_hex, assert a == b failed. a==0xHEXDIGIT and b==0xHEXDIGIT!
-zutest.c:243: In test_assert_hex, assert a != c failed. a==0xHEXDIGIT and c==0xHEXDIGIT!
-zutest.c:244: In test_assert_hex, assert a &gt; c failed. a==0xHEXDIGIT and c==0xHEXDIGIT!
-zutest.c:245: In test_assert_hex, assert b &gt; c failed. b==0xHEXDIGIT and c==0xHEXDIGIT!
-zutest.c:246: In test_assert_hex, assert b &gt;= a failed. b==0xHEXDIGIT and a==0xHEXDIGIT!
-zutest.c:247: In test_assert_hex, assert c &lt; a failed. c==0xHEXDIGIT and a==0xHEXDIGIT!
-zutest.c:248: In test_assert_hex, assert c &lt; b failed. c==0xHEXDIGIT and b==0xHEXDIGIT!
-zutest.c:249: In test_assert_hex, assert a &lt;= b failed. a==0xHEXDIGIT and b==0xHEXDIGIT!
-zutest.c:252: In test_assert_hex, assert a == 0 failed. a==0xHEXDIGIT!
-zutest.c:254: In test_assert_hex, assert z != 0 failed. z==0xHEXDIGIT!
-zutest.c:257: In test_assert_hex, assert z &gt; 0 failed. z==0xHEXDIGIT!
-zutest.c:258: In test_assert_hex, assert n &gt; 0 failed. n==0xHEXDIGIT!
-zutest.c:262: In test_assert_hex, assert a &lt;= 0 failed. a==0xHEXDIGIT!
-zutest.c:265: In test_assert_hex, assert z &lt; 0 failed. z==0xHEXDIGIT!
-zutest.c:266: In test_assert_hex, assert a &lt; 0 failed. a==0xHEXDIGIT!
-zutest.c:270: In test_assert_hex, assert n &gt;= 0 failed. n==0xHEXDIGIT!
-zutest.c:285: In test_assert_ptr, assert n != NULL failed. n==0xHEXDIGIT!
-zutest.c:286: In test_assert_ptr, assert ap == NULL failed. ap==0xHEXDIGIT!
-zutest.c:297: In test_assert_ptr, assert ap == bp failed. ap==0xHEXDIGIT and bp==0xHEXDIGIT!
-zutest.c:298: In test_assert_ptr, assert ap != cp failed. ap==0xHEXDIGIT and cp==0xHEXDIGIT!
-zutest.c:299: In test_assert_ptr, assert ap &gt; cp failed. ap==0xHEXDIGIT and cp==0xHEXDIGIT!
-zutest.c:300: In test_assert_ptr, assert bp &gt; cp failed. bp==0xHEXDIGIT and cp==0xHEXDIGIT!
-zutest.c:301: In test_assert_ptr, assert bp &gt;= ap failed. bp==0xHEXDIGIT and ap==0xHEXDIGIT!
-zutest.c:302: In test_assert_ptr, assert cp &lt; ap failed. cp==0xHEXDIGIT and ap==0xHEXDIGIT!
-zutest.c:303: In test_assert_ptr, assert cp &lt; bp failed. cp==0xHEXDIGIT and bp==0xHEXDIGIT!
-zutest.c:304: In test_assert_ptr, assert ap &lt;= bp failed. ap==0xHEXDIGIT and bp==0xHEXDIGIT!
-zutest.c:321: In test_assert_float, assert a == b failed. a==0.000400 and b==0.000300!
-zutest.c:322: In test_assert_float, assert a != c failed. a==0.000400 and c==0.000400!
-zutest.c:323: In test_assert_float, assert a &gt; c failed. a==0.000400 and c==0.000400!
-zutest.c:324: In test_assert_float, assert b &gt; c failed. b==0.000300 and c==0.000400!
-zutest.c:325: In test_assert_float, assert b &gt;= a failed. b==0.000300 and a==0.000400!
-zutest.c:326: In test_assert_float, assert c &lt; a failed. c==0.000400 and a==0.000400!
-zutest.c:327: In test_assert_float, assert c &lt; b failed. c==0.000400 and b==0.000300!
-zutest.c:328: In test_assert_float, assert a &lt;= b failed. a==0.000400 and b==0.000300!
-zutest.c:339: In test_assert_float, assert a == b failed. a==0.000400 and b==0.000300!
-zutest.c:340: In test_assert_float, assert a != c failed. a==0.000400 and c==0.000400!
-zutest.c:341: In test_assert_float, assert a &gt; c failed. a==0.000400 and c==0.000400!
-zutest.c:342: In test_assert_float, assert b &gt; c failed. b==0.000300 and c==0.000400!
-zutest.c:343: In test_assert_float, assert b &gt;= a failed. b==0.000300 and a==0.000400!
-zutest.c:344: In test_assert_float, assert c &lt; a failed. c==0.000400 and a==0.000400!
-zutest.c:345: In test_assert_float, assert c &lt; b failed. c==0.000400 and b==0.000300!
-zutest.c:346: In test_assert_float, assert a &lt;= b failed. a==0.000400 and b==0.000300!
-zutest.c:367: In test_assert_strings, assert a eq b failed. a is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
-zutest.c:368: In test_assert_strings, assert a ne c failed. a is &quot;Bogozity&quot; and c is &quot;Bogozity&quot;!
-zutest.c:369: In test_assert_strings, assert a gt c failed. a is &quot;Bogozity&quot; and c is &quot;Bogozity&quot;!
-zutest.c:370: In test_assert_strings, assert b gt c failed. b is &quot;Arclamp&quot; and c is &quot;Bogozity&quot;!
-zutest.c:371: In test_assert_strings, assert b ge a failed. b is &quot;Arclamp&quot; and a is &quot;Bogozity&quot;!
-zutest.c:372: In test_assert_strings, assert c lt a failed. c is &quot;Bogozity&quot; and a is &quot;Bogozity&quot;!
-zutest.c:373: In test_assert_strings, assert c lt b failed. c is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
-zutest.c:374: In test_assert_strings, assert a le b failed. a is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
-zutest.c:377: In test_assert_strings, assert a is empty failed. a is: Bogozity
-zutest.c:378: In test_assert_strings, assert n is empty failed. n is NULL!
-zutest.c:381: In test_assert_strings, assert e is nonempty failed. e[0] is 0!
-zutest.c:382: In test_assert_strings, assert n is nonempty failed. n is NULL!
-All OK.  11 tests run, 11 successes (195 assertions).
+zutest.c:NNN: In test_assert_int, assert a == b failed. a==4 and b==3!
+zutest.c:NNN: In test_assert_int, assert a != c failed. a==4 and c==4!
+zutest.c:NNN: In test_assert_int, assert a &gt; c failed. a==4 and c==4!
+zutest.c:NNN: In test_assert_int, assert b &gt; c failed. b==3 and c==4!
+zutest.c:NNN: In test_assert_int, assert b &gt;= a failed. b==3 and a==4!
+zutest.c:NNN: In test_assert_int, assert c &lt; a failed. c==4 and a==4!
+zutest.c:NNN: In test_assert_int, assert c &lt; b failed. c==4 and b==3!
+zutest.c:NNN: In test_assert_int, assert a &lt;= b failed. a==4 and b==3!
+zutest.c:NNN: In test_assert_int, assert a == 0 failed. a==4!
+zutest.c:NNN: In test_assert_int, assert z != 0 failed. z==0!
+zutest.c:NNN: In test_assert_int, assert z &gt; 0 failed. z==0!
+zutest.c:NNN: In test_assert_int, assert n &gt; 0 failed. n==-1!
+zutest.c:NNN: In test_assert_int, assert a &lt;= 0 failed. a==4!
+zutest.c:NNN: In test_assert_int, assert z &lt; 0 failed. z==0!
+zutest.c:NNN: In test_assert_int, assert a &lt; 0 failed. a==4!
+zutest.c:NNN: In test_assert_int, assert n &gt;= 0 failed. n==-1!
+zutest.c:NNN: In test_assert_hex, assert a == b failed. a==0xHEXDIGIT and b==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert a != c failed. a==0xHEXDIGIT and c==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert a &gt; c failed. a==0xHEXDIGIT and c==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert b &gt; c failed. b==0xHEXDIGIT and c==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert b &gt;= a failed. b==0xHEXDIGIT and a==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert c &lt; a failed. c==0xHEXDIGIT and a==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert c &lt; b failed. c==0xHEXDIGIT and b==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert a &lt;= b failed. a==0xHEXDIGIT and b==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert a == 0 failed. a==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert z != 0 failed. z==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert z &gt; 0 failed. z==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert n &gt; 0 failed. n==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert a &lt;= 0 failed. a==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert z &lt; 0 failed. z==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert a &lt; 0 failed. a==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_hex, assert n &gt;= 0 failed. n==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert n != NULL failed. n==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert ap == NULL failed. ap==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert ap == bp failed. ap==0xHEXDIGIT and bp==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert ap != cp failed. ap==0xHEXDIGIT and cp==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert ap &gt; cp failed. ap==0xHEXDIGIT and cp==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert bp &gt; cp failed. bp==0xHEXDIGIT and cp==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert bp &gt;= ap failed. bp==0xHEXDIGIT and ap==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert cp &lt; ap failed. cp==0xHEXDIGIT and ap==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert cp &lt; bp failed. cp==0xHEXDIGIT and bp==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_ptr, assert ap &lt;= bp failed. ap==0xHEXDIGIT and bp==0xHEXDIGIT!
+zutest.c:NNN: In test_assert_float, assert a == b failed. a==0.000400 and b==0.000300!
+zutest.c:NNN: In test_assert_float, assert a != c failed. a==0.000400 and c==0.000400!
+zutest.c:NNN: In test_assert_float, assert a &gt; c failed. a==0.000400 and c==0.000400!
+zutest.c:NNN: In test_assert_float, assert b &gt; c failed. b==0.000300 and c==0.000400!
+zutest.c:NNN: In test_assert_float, assert b &gt;= a failed. b==0.000300 and a==0.000400!
+zutest.c:NNN: In test_assert_float, assert c &lt; a failed. c==0.000400 and a==0.000400!
+zutest.c:NNN: In test_assert_float, assert c &lt; b failed. c==0.000400 and b==0.000300!
+zutest.c:NNN: In test_assert_float, assert a &lt;= b failed. a==0.000400 and b==0.000300!
+zutest.c:NNN: In test_assert_float, assert a == b failed. a==0.000400 and b==0.000300!
+zutest.c:NNN: In test_assert_float, assert a != c failed. a==0.000400 and c==0.000400!
+zutest.c:NNN: In test_assert_float, assert a &gt; c failed. a==0.000400 and c==0.000400!
+zutest.c:NNN: In test_assert_float, assert b &gt; c failed. b==0.000300 and c==0.000400!
+zutest.c:NNN: In test_assert_float, assert b &gt;= a failed. b==0.000300 and a==0.000400!
+zutest.c:NNN: In test_assert_float, assert c &lt; a failed. c==0.000400 and a==0.000400!
+zutest.c:NNN: In test_assert_float, assert c &lt; b failed. c==0.000400 and b==0.000300!
+zutest.c:NNN: In test_assert_float, assert a &lt;= b failed. a==0.000400 and b==0.000300!
+zutest.c:NNN: In test_assert_strings, assert a eq b failed. a is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
+zutest.c:NNN: In test_assert_strings, assert a ne c failed. a is &quot;Bogozity&quot; and c is &quot;Bogozity&quot;!
+zutest.c:NNN: In test_assert_strings, assert a gt c failed. a is &quot;Bogozity&quot; and c is &quot;Bogozity&quot;!
+zutest.c:NNN: In test_assert_strings, assert b gt c failed. b is &quot;Arclamp&quot; and c is &quot;Bogozity&quot;!
+zutest.c:NNN: In test_assert_strings, assert b ge a failed. b is &quot;Arclamp&quot; and a is &quot;Bogozity&quot;!
+zutest.c:NNN: In test_assert_strings, assert c lt a failed. c is &quot;Bogozity&quot; and a is &quot;Bogozity&quot;!
+zutest.c:NNN: In test_assert_strings, assert c lt b failed. c is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
+zutest.c:NNN: In test_assert_strings, assert a le b failed. a is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
+zutest.c:NNN: In test_assert_strings, assert a is empty failed. a is: Bogozity
+zutest.c:NNN: In test_assert_strings, assert n is empty failed. n is NULL!
+zutest.c:NNN: In test_assert_strings, assert e is nonempty failed. e[0] is 0!
+zutest.c:NNN: In test_assert_strings, assert n is nonempty failed. n is NULL!
+All OK.  14 tests run, 14 successes (252 assertions).

Modified: trunk/test/02-running/03-Unit-Tests.test
===================================================================
--- trunk/test/02-running/03-Unit-Tests.test	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/test/02-running/03-Unit-Tests.test	2007-02-17 13:46:25 UTC (rev 133)
@@ -3,4 +3,4 @@
 $tmtest --run-unit-tests
 
 STDOUT:
-All OK.  11 tests run, 11 successes (195 assertions).
+All OK.  14 tests run, 14 successes (252 assertions).

Modified: trunk/test.h
===================================================================
--- trunk/test.h	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/test.h	2007-02-17 13:46:25 UTC (rev 133)
@@ -54,6 +54,7 @@
 
 struct test {
     const char *testfilename;   ///&lt; name of the test file.  does not include any directories.  will be &quot;-&quot; if reading from stdin.
+    const char *testfiledir;	///&lt; full path to the directory containing the testfile.  should never end in a '/'.
     scanstate testfile;         ///&lt; scans the testfile.  may be stdin so seeking is not allowed.
 
     int rewritefd;          ///&lt; where to dump the rewritten test.  -1 if we're just running the tests, or the fd of the file that should receive the test contents.

Modified: trunk/units.c
===================================================================
--- trunk/units.c	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/units.c	2007-02-17 13:46:25 UTC (rev 133)
@@ -1,11 +1,26 @@
 #include &quot;units.h&quot;
-#include &quot;compare.h&quot;
 #include &lt;stddef.h&gt;
 
 
-zutest_suite all_unit_tests[] = {
-	zutest_tests,	// run a self-check on the unit test library
-	compare_tests,
-	NULL
-};
+void run_all_unit_tests()
+{
+	zutest_tests();
+	compare_tests();
+	pathstack_tests();
+}
 
+
+#ifdef UNITS_MAIN
+int main(int argc, char **argv)
+{
+	if(argc &gt; 1) {
+		// &quot;zutest -f&quot; prints all the failures in the zutest unit tests.
+		// This allows you to check the output of each macro.
+		run_unit_tests_showing_failures(run_all_unit_tests);
+	} else {
+		run_unit_tests(run_all_unit_tests);
+	}
+	// this will never be reached
+	return 0;
+}
+#endif

Modified: trunk/units.h
===================================================================
--- trunk/units.h	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/units.h	2007-02-17 13:46:25 UTC (rev 133)
@@ -1,6 +1,8 @@
 #include &quot;zutest.h&quot;
 
-extern zutest_proc compare_tests[];
+void compare_tests();
+void pathstack_tests();
 
-extern zutest_suite all_unit_tests[];
+void run_all_unit_tests();
 
+

Modified: trunk/vars.c
===================================================================
--- trunk/vars.c	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/vars.c	2007-02-17 13:46:25 UTC (rev 133)
@@ -19,7 +19,7 @@
 
 #include &quot;test.h&quot;
 #include &quot;vars.h&quot;
-#include &quot;curdir.h&quot;
+#include &quot;pathstack.h&quot;
 
 #define CONFIG_FILE &quot;tmtest.conf&quot;
 #define HOME_CONFIG_FILE &quot;.tmtestrc&quot;
@@ -48,7 +48,7 @@
 	} else if(test-&gt;testfilename[0] == '/') {
 		fprintf(fp, &quot;%s&quot;, test-&gt;testfilename);
 	} else {
-		fprintf(fp, &quot;%s/%s&quot;, curabsolute(), test-&gt;testfilename);
+		fprintf(fp, &quot;%s/%s&quot;, test-&gt;testfiledir, test-&gt;testfilename);
 	}
 
     return 0;
@@ -56,7 +56,7 @@
 
 static int var_testdir(struct test *test, FILE* fp, const char *var)
 {
-	fputs(curabsolute(), fp);
+	fputs(test-&gt;testfiledir, fp);
     return 0;
 }
 
@@ -76,7 +76,7 @@
 		if(test-&gt;testfilename[0] == '/') {
 			fprintf(fp, &quot;. %s&quot;, test-&gt;testfilename);
 		} else {
-			fprintf(fp, &quot;. '%s/%s'&quot;, curabsolute(), test-&gt;testfilename);
+			fprintf(fp, &quot;. '%s/%s'&quot;, test-&gt;testfiledir, test-&gt;testfilename);
 		}
     }
 
@@ -227,7 +227,7 @@
 	}
 
 	// check config files in the current hierarchy
-	strncpy(buf, curabsolute(), sizeof(buf));
+	strncpy(buf, test-&gt;testfiledir, sizeof(buf));
 	buf[sizeof(buf)-1] = '\0';
 	if(config_file) {
 		confbaselen = strrchr(config_file, '/') - config_file;

Modified: trunk/zutest.c
===================================================================
--- trunk/zutest.c	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/zutest.c	2007-02-17 13:46:25 UTC (rev 133)
@@ -1,15 +1,18 @@
 /* zutest.c
  * Scott Bronson
  * 6 Mar 2006
+ * 
+ * This file is released under the MIT License.
+ * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
  *
- * Version 0.6, 26 Apr 2006
+ * Version 0.7,  16 Feb 2007 -- turn dependency tree into functions
+ * Version 0.6,  26 Apr 2006 -- first version worth releasing
  */
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;stdarg.h&gt;
 #include &lt;string.h&gt;
-#include &lt;setjmp.h&gt;
 #include &quot;zutest.h&quot;
 
 
@@ -22,10 +25,34 @@
  * within a test, the test itself is stopped and printed as a failure
  * but all other tests in the current test suite, and all other test
  * suites, will still be run.
+ * 
+ * You need to ensure that it's impossible for Assert macros to be
+ * called without first ensuring that test_enter is called.
+ * 
+ * A single test is typically:
+ *   
+ *   Generally each step in a test must be processed in order
+ * (later steps depend on earlier).  This is why tmtest bails
+ * on the entire test when the first assert fails -- chances are
+ * that the failure will prevent any further processing in this
+ * test from producing meaningful results, and is probably not
+ * unlikely to cause a full crash.  Therefore when an assert fails,
+ * the current test is stopped and the next test is started.
  *
- * A test suite consists of a number of tests.  Typically a C file
- * will include a test suite that lists all the tests in the file.
+ * Q: Why not collect tests in data structures like other unit test
+ * program do?
+ * A: Zutest used to do this.  However, you can't call a data structure
+ * with different parameters.  For instance, ensuring a suite of tests
+ * works with any sized buffer:
+ *     test_buffer(1024);
+ *     test_buffer(13);
+ *     test_buffer(0);
+ * And you can't set a breakpoint on a data structure or step through
+ * it in a debugger.  So, while it might be conceptually cleaner to
+ * specify your tests purely declarative, in practice it's significantly
+ * less convenient.
  *
+ * TODO: move test setup into the tests themselves.
  * TODO: print test results, test suites, etc as they run.
  *    Add a quiet flag that will suppress printing unless a test fails.
  *    quiet=0, full printing
@@ -36,10 +63,10 @@
 
 
 int zutest_assertions = 0;		///&lt; A goofy statistic, updated by the assertion macros
-static int tests_run = 0;		///&lt; The number of tests that we have run.  successes+failures==tests_run (if not, then there's a bug somewhere).
-static int successes = 0;		///&lt; The number of successful tests run
-static int failures = 0;		///&lt; The number of failed tests run.
-static jmp_buf test_bail;		///&lt; If an assertion fails, and we're not inverted, this is where we end up.
+int zutest_tests_run = 0;		///&lt; The number of tests that we have run.  successes+failures==tests_run (if not, then there's a bug somewhere).
+int zutest_successes = 0;		///&lt; The number of successful tests run
+int zutest_failures = 0;		///&lt; The number of failed tests run.
+jmp_buf zutest_test_bail;		///&lt; If an assertion fails, and we're not inverted, this is where we end up.
 static jmp_buf *inversion;		///&lt; If an assertion fails, and we're inverted, this is where we end up.  This is NULL except when running Zutest's internal unit tests.  See test_fail().
 static int show_failures = 0; 	///&lt; Set this to 1 to print the failures.  This allows you to view the output of each failure to ensure it looks OK.
 
@@ -61,67 +88,41 @@
 		longjmp(*inversion, 1);
 	}
 
-	longjmp(test_bail, 1);
+	longjmp(zutest_test_bail, 1);
 }
 
 
-void run_zutest_suite(const zutest_suite suite)
-{
-	const zutest_proc *test;
-
-	for(test=suite; *test; test++) {
-		tests_run += 1;
-		if(!setjmp(test_bail)) {
-			(*test)();
-			successes += 1;
-		} else {
-			failures += 1;
-		}
-	}
-}
-
-
-void run_zutest_suites(const zutest_suites suites)
-{
-	zutest_suite *suite;
-
-	for(suite=suites; *suite; suite++) {
-		run_zutest_suite(*suite);
-	}
-}
-
-
 void print_zutest_results()
 {
-	if(failures == 0) {
+	if(zutest_failures == 0) {
 		printf(&quot;All OK.  %d test%s run, %d successe%s (%d assertion%s).\n&quot;,
-				successes, (successes == 1 ? &quot;&quot; : &quot;s&quot;),
-				successes, (successes == 1 ? &quot;&quot; : &quot;s&quot;),
+				zutest_successes, (zutest_successes == 1 ? &quot;&quot; : &quot;s&quot;),
+				zutest_successes, (zutest_successes == 1 ? &quot;&quot; : &quot;s&quot;),
 				zutest_assertions, (zutest_assertions == 1 ? &quot;&quot; : &quot;s&quot;));
 		return;
 	}
 
 	printf(&quot;ERROR: %d failure%s in %d test%s run!\n&quot;,
-			failures, (failures == 1 ? &quot;&quot; : &quot;s&quot;), 
-			tests_run, (tests_run == 1 ? &quot;&quot; : &quot;s&quot;));
+			zutest_failures, (zutest_failures == 1 ? &quot;&quot; : &quot;s&quot;), 
+			zutest_tests_run, (zutest_tests_run == 1 ? &quot;&quot; : &quot;s&quot;));
 }
 
 
 /** Runs all the unit tests in all the passed-in test suites.
  */
 
-void run_unit_tests(const zutest_suites suites)
+void run_unit_tests(zutest_proc proc)
 {
-	run_zutest_suites(suites);
+	(*proc)();
 	print_zutest_results();
-	exit(failures &lt; 100 ? failures : 100);
+	exit(zutest_failures &lt; 100 ? zutest_failures : 100);
 }
 
 
-void run_unit_tests_showing_failures(const zutest_suites suites)
+void run_unit_tests_showing_failures(zutest_proc proc)
 {
 	show_failures = 1;
-	run_unit_tests(suites);
+	run_unit_tests(proc);
 }
 
 
@@ -136,19 +137,15 @@
  * without doing anything.
  */
 
-void unit_test_check(int argc, char **argv, const zutest_suites suites)
+void unit_test_check(int argc, char **argv, zutest_proc proc)
 {
 	if(argc &gt; 1 &amp;&amp; strcmp(argv[1],&quot;--run-unit-tests&quot;) == 0) {
-		run_unit_tests(suites);
+		run_unit_tests(proc);
 	}
 }
 
 
 
-
-
-#if defined(ZUTEST) || defined(ZUTEST_MAIN)
-
 /* This code runs the zutest unit tests to ensure that zutest itself
  * is working properly.
  */
@@ -383,43 +380,27 @@
 }
 
 
-zutest_proc zutest_tests[] = {
-	test_assert_int,
-	test_assert_hex,
-	test_assert_ptr,
-	test_assert_float,
-	test_assert_strings,
-	NULL
+void zutest_tests()
+{
+	zutest( test_assert_int() );
+	zutest( test_assert_hex() );
+	zutest( test_assert_ptr() );
+	zutest( test_assert_float() );
+	zutest( test_assert_strings() );
 };
 
 
-// Ensure that zutest doesn't crash if handed an empty suite.
-zutest_proc zutest_empty_suite[] = {
-	NULL
-};
-
-
-zutest_suite all_zutests[] = {
-	zutest_empty_suite,
-	zutest_tests,
-	NULL
-};
-
-
 #ifdef ZUTEST_MAIN
 int main(int argc, char **argv)
 {
 	if(argc &gt; 1) {
 		// &quot;zutest -f&quot; prints all the failures in the zutest unit tests.
 		// This allows you to check the output of each macro.
-		run_unit_tests_showing_failures(all_zutests);
+		run_unit_tests_showing_failures(zutest_tests);
 	} else {
-		run_unit_tests(all_zutests);
+		run_unit_tests(zutest_tests);
 	}
 	// this will never be reached
 	return 0;
 }
 #endif
-
-#endif
-

Modified: trunk/zutest.h
===================================================================
--- trunk/zutest.h	2007-02-16 06:21:16 UTC (rev 132)
+++ trunk/zutest.h	2007-02-17 13:46:25 UTC (rev 133)
@@ -1,13 +1,13 @@
 /* zutest.h
  * Scott Bronson
  * 6 Mar 2006
- *
- * TODO: make tests self-documenting.  The test name is the same as the
- * function name, but they should also have a short and long description.
- * TODO: make zutest suites able to be arranged in a hierarchy.
- *
- * Version 0.62, 22 Jan 2007
- * Version 0.61, 30 Apr 2006
+ * 
+ * This file is released under the MIT License.
+ * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
+ * 
+ * Version 0.7,  16 Feb 2007 -- turn dependency tree into functions
+ * Version 0.62, 22 Jan 2007 -- clean up failure messages
+ * Version 0.61, 30 Apr 2006 -- first version worth releasing
  */
 
 
@@ -17,7 +17,6 @@
  * required to use Zutest in your own applications.
  *
  * Zutest is a ground-up rewrite of Asim Jalis's &quot;CuTest&quot; library.
- * It is released under the MIT License.
  *
  * To compile Zutest to run its own unit tests, do this:
  * 
@@ -38,6 +37,10 @@
 #ifndef ZUTEST_H
 #define ZUTEST_H
 
+// This include is unfortunate...  TODO: try to get this out of here.
+#include &lt;setjmp.h&gt;
+
+
 //#define ZUTBECAUSE &quot; failed because &quot;
 #define ZUTBECAUSE &quot; failed. &quot;
 
@@ -140,8 +143,15 @@
 		if(!(p)[0]) { Fail(#p&quot; is nonempty&quot; ZUTBECAUSE #p&quot;[0] is 0!&quot;); } \
 	} while(0)
 
+// I think that &quot;Equal&quot; looks better than &quot;Eq&quot;.
+// This is probably proof that these macros need to be totally overhauled...
+#define AssertEqual(x,y) AssertEq(x,y)
+#define AssertEqualHex(x,y) AssertHexEq(x,y)
+#define AssertPtrEqual(x,y) AssertPtrEq(x,y)
+#define AssertFloatEqual(x,y) AssertFloatEq(x,y)
+#define AssertDoubleEqual(x,y) AssertFloatEq(x,y)
+#define AssertStrEqual(x,y) AssertStrEq(x,y)
 
-
 //
 // helper macros, not intended to be called directly.
 //
@@ -165,45 +175,7 @@
 
 
 
-/** Keeps track of how many assertions have been made.
- * This needs to be updated manually each time an assertion
- * is made.  The Zutest built-in assertion macros all
- * update this variable properly.
- */
 
-extern int zutest_assertions;
-
-
-/** A single test
- *
- * This routine is called to run the test.  If it returns, the test
- * succeeds.  If zutest_fail() is called (either directly or indirectly
- * via an Assert macro), then the test fails.
- */
-typedef void (*zutest_proc)();
-
-
-/** A suite of tests
- *
- * A zutest_suite is simply a list of tests.  Generally, each .c file
- * in your project will include a test suite that ensures all the tests
- * contained in the .c file are run.  A suite is just a NULL-terminated
- * list of tests.
- */
-typedef zutest_proc *zutest_suite;
-
-
-/** A suite of test suites
- *
- * Zutests runs through each test suite in your project, running all the
- * tests in each suite.  A suite of suites is just a NULL-terminated list
- * of suites.  This is the topmost data structure used by zutest.
- * TODO: make it so zutest chan handle an arbitrary hierarchy of suites.
- * That way this data structure can go away.
- */
-typedef zutest_suite *zutest_suites;
-
-
 /** Fails the current test.
  *
  * This function may only be called from within a ::zutest_proc.
@@ -224,12 +196,42 @@
 
 void zutest_fail(const char *file, int line, const char *func,
 		const char *msg, ...);
+		
+		
+#define zutest(test) do { zutest_tests_run += 1; 	\
+		if(!setjmp(zutest_test_bail)) { 			\
+			do { test; } while(0); 					\
+			zutest_successes += 1; 					\
+		} else { 									\
+			zutest_failures += 1; 					\
+		} } while(0)
+		
 
+/* above this line is stuff only needed within the tests */
+/* ------------------ */
+/* below this line is stuff only needed to run the tests */
 
+
+
+
+/** Keeps track of how many assertions have been made.
+ * This needs to be updated manually each time an assertion
+ * is made.  The Zutest built-in assertion macros all
+ * update this variable properly.
+ */
+
+extern int zutest_assertions;
+extern int zutest_tests_run;
+extern int zutest_successes;
+extern int zutest_failures;
+extern jmp_buf zutest_test_bail;
+
+typedef void (*zutest_proc)();
+
 /** Runs all the tests in a suite. */
-void run_zutest_suite(const zutest_suite suite);
+void run_zutest_suite(zutest_proc proc);
 /** Runs all the tests in all the suites passed in. */
-void run_zutest_suites(const zutest_suites suites);
+void run_zutest_suites(zutest_proc proc);
 
 void print_zutest_results();
 
@@ -243,7 +245,7 @@
  * run_zutest_suites() directly.
  */
 
-void unit_test_check(int argc, char **argv, const zutest_suites suites);
+void unit_test_check(int argc, char **argv, zutest_proc proc);
 
 /**
  *
@@ -251,8 +253,8 @@
  * if you want to handle the arguments yourself.
  */
 
-void run_unit_tests(const zutest_suites suites);
-void run_unit_tests_showing_failures(const zutest_suites suites);
+void run_unit_tests(zutest_proc proc);
+void run_unit_tests_showing_failures(zutest_proc proc);
 
 
 /** Zutest's built-in test suite.
@@ -268,6 +270,7 @@
  * compile and run its unit tests as described in zutest.h.
  */
 
-extern zutest_proc zutest_tests[];
+void zutest_tests();
 
+
 #endif




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000049.html">[Tmtest-commits] [132] trunk/zutest.h: Make the 2-arg 1-op macros	look less Forth-like.
</A></li>
	<LI>Next message: <A HREF="000051.html">[Tmtest-commits] [134] trunk: Minor cleanups lying around in an	older tree
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#50">[ date ]</a>
              <a href="thread.html#50">[ thread ]</a>
              <a href="subject.html#50">[ subject ]</a>
              <a href="author.html#50">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tmtest-commits">More information about the Tmtest-commits
mailing list</a><br>
</body></html>
