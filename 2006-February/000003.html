<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tmtest-commits] [86] &quot;trunk&quot; is the standard trunk, not &quot;TRUNK&quot;
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tmtest-commits/2006-February/index.html" >
   <LINK REL="made" HREF="mailto:tmtest-commits%40lists.berlios.de?Subject=Re%3A%20%5BTmtest-commits%5D%20%5B86%5D%20%22trunk%22%20is%20the%20standard%20trunk%2C%20not%20%22TRUNK%22&In-Reply-To=%3C200602272310.k1RNA9YA008870%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000002.html">
   <LINK REL="Next"  HREF="000004.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tmtest-commits] [86] &quot;trunk&quot; is the standard trunk, not &quot;TRUNK&quot;</H1>
    <B>tmtest-commits at berlios.de</B> 
    <A HREF="mailto:tmtest-commits%40lists.berlios.de?Subject=Re%3A%20%5BTmtest-commits%5D%20%5B86%5D%20%22trunk%22%20is%20the%20standard%20trunk%2C%20not%20%22TRUNK%22&In-Reply-To=%3C200602272310.k1RNA9YA008870%40sheep.berlios.de%3E"
       TITLE="[Tmtest-commits] [86] &quot;trunk&quot; is the standard trunk, not &quot;TRUNK&quot;">tmtest-commits at berlios.de
       </A><BR>
    <I>Tue Feb 28 00:10:09 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000002.html">[Tmtest-commits] [85] TRUNK: Make a simple rename, break the build.
</A></li>
        <LI>Next message: <A HREF="000004.html">[Tmtest-commits] [87] create releases directory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3">[ date ]</a>
              <a href="thread.html#3">[ thread ]</a>
              <a href="subject.html#3">[ subject ]</a>
              <a href="author.html#3">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Revision: 86
Author:   bronson
Date:     2006-02-28 00:10:08 +0100 (Tue, 28 Feb 2006)

Log Message:
-----------
&quot;trunk&quot; is the standard trunk, not &quot;TRUNK&quot;

Added Paths:
-----------
    trunk/
    trunk/BUGS
    trunk/CHANGES
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/compare.h
    trunk/examples/
    trunk/matchval.h
    trunk/re2c/
    trunk/stscan.c
    trunk/stscan.re
    trunk/test/
    trunk/test.c
    trunk/tfscan.c
    trunk/tfscan.h
    trunk/tmtest.conf

Removed Paths:
-------------
    TRUNK/
    trunk/BUGS
    trunk/CHANGES
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/compare.h
    trunk/matchval.h
    trunk/re2c/
    trunk/stscan.c
    trunk/stscan.re
    trunk/test/
    trunk/test.c
    trunk/tfscan.c
    trunk/tfscan.h
    trunk/tfscan.re
    trunk/tmtest.conf
    trunk/tutorial/
Copied: trunk (from rev 83, TRUNK)

Deleted: trunk/BUGS
===================================================================
--- TRUNK/BUGS	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/BUGS	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,38 +0,0 @@
-If you run tmtest -d on a disabled test, it produces a tiny diff with the
-word &quot;Disabled&quot; in its stderr.  If you blindly pipe this diff to patch,
-it will destroy the output section of your test file.  This is easy enough
-to fix -- just re-enable the test and patch it again.  This will be
-fixed in tmtest 2.2 when we parse the status file asynchronously.
-
-
-Bash Bugs:
-
-Bash3 has removed the ability to set LINENO, so you may see the
-wrong line number be printed if there's an error.  The workaround
-suggested by the Bash author is far too large and complex.
-Downgrading to Bash2 works much better.  I don't understand why
-this functionality was removed in the first place!
-
-
-The &lt;&lt;-EOL operator strips ALL tabs from the front of each line.
-This is bad because it means you can't nest heredocs:
-
-	cmd1 &lt;&lt;-EOL
-		cmd2 &lt;&lt;-EOL
-			cmd3
-		EOL
-	EOL
-
-The first heredoc flattens everything and then the EOLs get mixed up.
-What bash SHOULD do is discover the whitespace sequence indenting the
-first line of a heredoc, then remove that sequence from all subsequent
-lines.  If a line doesn't begin with exactly that sequence, then
-it is unchanged.  This would be much safer and more useful than just
-blowing away all tabs wholesale!
-
-
-Why does &amp;&gt; redirect both stdout and stderr to a file, but &amp;| doesn't
-redirect both stdout and stderr to a pipe?
-
-Why is the unset command totally unrelated to the set command?
-

Copied: trunk/BUGS (from rev 85, TRUNK/BUGS)

Deleted: trunk/CHANGES
===================================================================
--- TRUNK/CHANGES	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/CHANGES	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,12 +0,0 @@
-- Get rid of all AUTHOR and DATE automation.  Too heavyhanded.
-- Standardized licensing: everything under my control is MIT, package is LGPL.
-- When installing locally, it's ~/.tmlib.sh instead of ~/share/tmtest/tmlib.sh
-- Bump to 0.92
-- install now installs config files too.
-- Added the --config option to override default config files.
-- Added timing information to test summary.  Disable with new -q option.
-- Created tmlib, a &quot;standard library&quot; for tests.
-- We now stop running all tests if any test aborts.  DISABLE stops the current
-  test but lets all other tests finish; ABORT stops testing altogether.
-- Tests now start with /tmp as the cwd, not the testdir.
-  The testdir is supplied in $TESTDIR (or $MYDIR inside the testfile)

Copied: trunk/CHANGES (from rev 85, TRUNK/CHANGES)

Deleted: trunk/Makefile
===================================================================
--- TRUNK/Makefile	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/Makefile	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,114 +0,0 @@
-# tmtest Makefile
-# Scott Bronson
-# 28 Dec 2004
-#
-# This software is distributed under the LGPL.  See COPYING for more.
-
-
-VERSION=0.92
-
-# override this when installing: &quot;make install prefix=/usr/local&quot;
-#prefix=/usr
-prefix=$(HOME)
-
-
-bindir=$(prefix)/bin
-lib_src=tmlib.sh
-
-ifeq ($(prefix), $(HOME))
-	libdir=$(prefix)
-	stdlib=$(libdir)/.tmlib.sh
-	conf_dst=$(HOME)/.tmtestrc
-else
-	libdir=$(prefix)/share/tmtest
-	stdlib=$(libdir)/tmlib.sh
-	conf_dst=/etc/tmtest.conf
-endif
-
-
-COPTS=-g -Wall -Werror
-
-# utilities:
-CSRC+=curdir.c qscandir.c pcrs.c rel2abs.c
-CHDR+=curdir.h qscandir.h pcrs.h rel2abs.h
-# scanner files
-CSRC+=re2c/read.c re2c/read-fd.c re2c/scan.c
-CHDR+=re2c/read.h re2c/read-fd.h re2c/scan.h
-# program files:
-CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c
-CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h matchval.h
-
-# It makes it rather hard to debug when Make deletes the intermediate files.
-INTERMED=stscan.c
-
-
-tmtest: $(CSRC) $(CHDR) template.c Makefile $(INTERMED)
-	$(CC) $(COPTS) $(CSRC) -lpcre template.c -o tmtest &quot;-DVERSION=$(VERSION)&quot;
-
-template.c: template.sh cstrfy Makefile
-	./cstrfy -n exec_template &lt; template.sh &gt; template.c
-
-%.c: %.re
-	re2c $(REOPTS) $&lt; &gt; $@
-	perl -pi -e 's/^\#line.*$$//' $@
-
-%.o: %.c
-	$(CC) -g -c $&lt; -o $@
-
-
-test: tmtest
-	tmtest --config=./tmtest.conf test
-
-run: tmtest
-	./tmtest
-
-install: tmtest
-	install -d -m755 $(bindir)
-	install tmtest $(bindir)
-	install -d -m755 $(libdir)
-	install tmlib.sh $(stdlib)
-ifeq ($(wildcard $(conf_dst)),$(conf_dst))
-	# configuration already exists, don't overwrite it.
-	@echo &quot;---&gt; Not installing new config file over '$(conf_dst).'&quot;
-	@echo &quot;---&gt; Please merge changes in 'sample.conf' by hand or run 'make uninstall' first.&quot;
-else
-	# global configuration file doesn't exist so install it
-	install sample.conf $(conf_dst)
-	@perl -pi -e 's/USER/$(shell whoami)/g' $(conf_dst)
-	@perl -pi -e 's:STDLIB:$(stdlib):g' $(conf_dst)
-endif
-
-# NOTE: This will remove the configuration file too!
-uninstall: tmtest
-	rm $(bindir)/tmtest
-	rm $(stdlib)
-ifeq ($(prefix), $(HOME))
-	rm $(HOME)/.tmtestrc
-else
-	rm /etc/tmtest.conf
-endif
-
-clean:
-	rm -f tmtest template.c tags
-
-# Ensure re2c is installed to regenerate the scanners before making distclean
-distclean: clean
-	rm -f stscan.[co]
-
-tags: $(CSRC) $(CHDR) $(INTERMED)
-	ctags -R
-
-doc:
-	doxygen
-	which pods2html &gt; /dev/null || echo &quot;You must install Pod::Tree off CPAN&quot;
-	pods2html . docs/html
-	$(MAKE) graphs
-
-%.png: %.dot
-	dot -Tpng $&lt; -o $@
-
-rediff:
-	diff ../oe/re2c/ re2c
-	
-reupdate:
-	ls re2c/*.[ch] | (ODIR=`pwd`; cd ../oe; xargs cp --target-directory $$ODIR/re2c)

Copied: trunk/Makefile (from rev 85, TRUNK/Makefile)

Deleted: trunk/TODO
===================================================================
--- TRUNK/TODO	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/TODO	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,103 +0,0 @@
-1.0:
-- Add to faq: limitation on line length when using MODIFY clause.
-  (MODIFY is memory-based, so a single line must fit into memory).
-  If you're working with big testfiles, don't use MODIFY.
-  - No, we fucking line buffer everything thanks to the scanner.
-  - I'd say it's time to hand-code the scanners so they don't
-    have to be line-buffered.  There's nothing we can do about MODIFY
-	of course.
-- Why is compare_continue not called??
-	Somehow we abandon the newline on the input buffer.
-	The problem is that the scanner REQUIRES a newline on the end.
-	    Shit, I wonder if it's time to just junk the scanner entirely.
-- what do we do when stdout is missing a newline at the end?
-  Test that both raw and modified work when stdout doesn't have a newline.
-  Check that diff works too.
-- Make &quot;make test&quot; work.
-- write tests for nesting testfiles with --config.
-        // If the user specifies a config file, we only check directories
-        // not above the given config file.  i.e. if user specifies
-        // &quot;tmtest -c /a/b/cc /a/t/u/t.test&quot;, we will look for config files
-        // in /a/t/tmtest.conf and /a/t/u/tmtest.conf.
-- merge tmtestlib and tmtestrc.  They're now basically the same file.
-- get rid of all the exit(10) calls in test.c.  We need a better way to
-  abort the test.
-  should get rid of a whole bunch in main.c as well.
-  this should prevent us from dropping turds in /tmp all the time too.
-- Add the ability to specify test arguments on the command line.
-  I'm picturing something where VAR=val on the command line would be
-  inserted without change into the template.  That way you can use the
-  command line to override default settings in the testfile.
-  - This would allow us to test almost every test to ensure it
-    supports the --config argument (make them DISABLED or something).
-
-1.2:
-- stdin is all buggered up.  why is it that &quot;cat&quot; with no args will print
-  the rest of the test script?  And why is it that if you fork, diff freezes?
-  They're related problems I suspect.
-- Could take tests from tarfiles.  We would decompress the tarfile into
-  a temporary directory, run the test, and delete the tarfile.  This will
-  make it easier to maintain tests that all need to be run in a certain
-  directory hierarchy.
-- Tighten up printing a folder name when there are no testfiles in it.
-  No need for double spacing.
-- Change the I/O scheme to be event based.  Get rid of the tempfiles.
-  Convert to using the async io library.  Don't use temporary files.
-  This would allow us to recognize that the test is disabled before
-  producing a partial diff, blowing away output sections.
-  - I'd say it's time to hand-code the scanners so they don't
-    have to be line-buffered.  There's nothing we can do about MODIFY
-	of course.  But don't line-buffer if we don't have to.  Should
-	simplify things quite a bit to get rid of re2c.
-- Add the ability to run multiple tests from one testfile.
-  See tmtest 0.8 for a potential implementation of this.
-  All we'd need to add is a framework to notify the user that multiple
-  tests are in progress; bash can take care of the rest.
-- add the ability to run valgrind over each test and print success/failure
-  of that.  (gives deep valgrind coverage)
-  - One problem with this will be all the false warnings.
-- add gcov support so you can see what sort of coverage your tests provide.
-- Shouldn't run every test in a dir if the DISABLED directive is in a config
-  file.
-  Should discover what dir the DISABLED directive came from and refuse
-  to run anything below that.
-  - Yes, if a config file returns DISABLED, then that folder and all its
-    subfolders are skipped.  Just make the test itself return the DISABLED
-	command if you want testing to continue in that subfolder.
-
-?:
-- should probably indent stdout and stderr clauses two spaces.  otherwise
-  we might misinterpret STDOUT: and STDERR: in a stdout or stderr clause.
-  - True, but this is easy enough to mock with a MODIFY clause.  The
-    downside to this is that 
-- Provide some sort of automatable XML output.
-- allow multiple s/// expressions on a single line.  will probably require
-  modifications to pcrs_compile_command, so make it support buf/len at the
-  same time.  These might be non-trivial changes...
-- it's stupid to dup the str just to null-terminate it so it can be passed
-  to pcrs.  Modify pcrs to compile buffers too.
-
-????:
-- Unify the line modifier in compare.c and test.c.  It's hackish now.
-- There should be a way to repeatedly run a single test with only tiny
-  differences.  i.e. test all permeutations of DISABLE DISABLE:
-  DISABLED DISABLED:  Hopefully that will clean up 05-08-Disable/Abort.test
-- Add a timeout that will terminate stalled tests.  You can set the timeout in the config file.
-
-
-
-- Wow, the pcrs error messages suck.  Is there any way to improve them?
-  &quot;(pcrs:) Syntax error while parsing command (-11).&quot;
-
-
-maybe never:
-- Add STDOUT: trimws and STDERR: trimws - to trim whitespace from
-  the front of each output line.
-  I wanted to add this to simulate the &quot;STDOUT=&lt;&lt;-EOL&quot; heredoc sequence
-  of the original tests (that is nestable, unlinke Bash's.  But now I
-  realize that this problem is pretty much solved from the other direction.
-  Instead of removing indentation from the heredoc, simply add indentation
-  using a MODIFY section (as detailed in the FAQ).
-- add a CLEAR_EACHLINE or CLEAR_MODIFY option to to turn off all substitutions.
-  It would be easy to do.  I'm just not convinced that anyone would find it useful.
-

Copied: trunk/TODO (from rev 85, TRUNK/TODO)

Deleted: trunk/compare.c
===================================================================
--- TRUNK/compare.c	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/compare.c	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,283 +0,0 @@
-/* compare.c
- * Scott Bronson
- * 31 Dec 2004
- *
- * This file is distrubuted under the MIT License
- * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
- *
- *
- * File comparison.
- *
- * This uses all re2c's mechanisms for creating buffers and loading
- * them with data, but it's not an re2c scanner.
- *
- * Here's what you do:
- * - Create a scanstate that reads from one of the files (or
- *   whatever) that you want to compare and pass it to compare_start.
- * - Call compare_continue with any size data block from the other
- *   file you want to compare.  Keep calling until you're out of
- *   data.  Check compare_in_progress to see if it failed prematurely.
- * - Finally, when you're out of data in the other file, call
- *   compare_end.  It will verify that it's at eof on the first
- *   file.
- * - Read the final result from the matchval.
- *
- * Well, the line buffering for the pcrs library has utterly destroyed
- * the simplicity of this file.
- *
- */
-
-#include &lt;string.h&gt;
-#include &quot;compare.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;assert.h&gt;
-
-
-typedef struct {
-	matchval *output;
-	pcrs_job *jobs;
-	const char *pbuf;
-	int pcursor;
-	int plimit;
-} compare_state;
-
-
-static int compare_fill(scanstate *ss)
-{
-    return (*ss-&gt;read)(ss);
-}
-
-
-static void compare_halt(scanstate *ss, matchval newval)
-{
-	compare_state *cmp = (compare_state*)ss-&gt;scanref;
-    *cmp-&gt;output = newval;
-	if(cmp-&gt;pbuf) free((char*)cmp-&gt;pbuf);
-	free(cmp);
-    ss-&gt;scanref = NULL;
-}
-
-
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *jobs)
-{
-	compare_state *cmp = malloc(sizeof(compare_state));
-	if(cmp == NULL) {
-		perror(&quot;compare_attach&quot;);
-		exit(10);
-	}
-	memset(cmp, 0, sizeof(compare_state));
-
-    *mv = match_inprogress;
-
-	cmp-&gt;output = mv;
-	cmp-&gt;jobs = jobs;
-	ss-&gt;scanref = cmp;
-}
-
-
-static void compare_continue_bytes(scanstate *ss, const char *ptr, int len)
-{
-    int n;
-
-    while(len &gt; 0) {
-        n = ss-&gt;limit - ss-&gt;cursor;
-        if(!n) {
-            n = compare_fill(ss);
-            if(n &lt; 0) {
-                // there was an error while trying to fill the buffer
-                // TODO: this should be propagated to the client somehow.
-                perror(&quot;compare_continue_bytes&quot;);
-                exit(10);
-            }
-            if(n == 0) {
-				// there's more input data but we're at eof.
-                compare_halt(ss, match_no);
-                return;
-            }
-        }
-
-        if(len &lt; n) {
-            n = len;
-        }
-
-        // compare
-        if(memcmp(ptr, ss-&gt;cursor, n) != 0) {
-            compare_halt(ss, match_no);
-            return;
-        }
-        ptr += n;
-        ss-&gt;cursor += n;
-        len -= n;
-    }
-}
-
-
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize)
-{
-	char *old, *new;
-	int nsubs;
-	int cnt;
-
-	cnt = 0;
-	old = (char*)cp;
-	*newsize = ce - cp;
-
-	while(job) {
-		// Now, run the line through the substitutions.
-		nsubs = pcrs_execute(job, old, *newsize, &amp;new, newsize);
-		if(nsubs &lt; 0) {
-			fprintf(stderr, &quot;error while substituting expr %d: %s (%d).\n&quot;,
-					cnt, pcrs_strerror(nsubs), nsubs);
-            if(new) {
-                free(new);
-                new = NULL;
-            }
-			break;
-		}
-
-		assert(strlen(new) == *newsize);
-
-		if(old != cp) {
-			// free the intermediate result.
-			free(old);
-		}
-		old = new;
-		job = job-&gt;next;
-		cnt += 1;
-	}
-
-    return new;
-}
-
-
-// This routine is hellish because neither stream is line buffered.
-// Therefore, we line buffer the file and compare in chunks against
-// the input.  &quot;pbuf&quot; is the substitution-modified buffer allocated
-// by the pcre library.
-
-static void compare_continue_lines(scanstate *ss, compare_state *cmp,
-		const char *ptr, size_t len)
-{
-	int n;
-	const char *p;
-    char *new;
-    size_t newsize;
-
-	while(len &gt; 0) {
-		n = cmp-&gt;plimit - cmp-&gt;pcursor;
-		assert(n &gt;= 0);
-		if(n) {
-			// there's more data in the pbuf.  use it for comparison.
-			if(len &lt; n) n = len;
-			if(memcmp(ptr, cmp-&gt;pbuf+cmp-&gt;pcursor, n) != 0) {
-				compare_halt(ss, match_no);
-				return;
-			}
-			cmp-&gt;pcursor += n;
-			ptr += n;
-			len -= n;
-			assert(len &gt;= 0);
-			if(!len) break;
-		}
-
-		// we've emptied the pbuf so we need to regenerate it.
-		// first see if there's anther line in the line buffer.
-		p = memchr(ss-&gt;cursor, '\n', ss-&gt;limit - ss-&gt;cursor);
-		if(!p) {
-			// there's no newline in the buffer.  try to refill.
-			n = compare_fill(ss);
-			if(n &lt; 0) {
-				// there was an error while trying to fill the buffer
-				// TODO: this should be propagated to the client somehow.
-				perror(&quot;compare_continue_lines&quot;);
-				exit(10);
-			}
-			if(n == 0) {
-				// there's more input data but we're at eof.
-				compare_halt(ss, match_no);
-				return;
-			}
-
-			p = memchr(ss-&gt;cursor, '\n', ss-&gt;limit - ss-&gt;cursor);
-			if(!p) {
-				// we'll just have to treat the entire buffer as a full
-				// line and hope for the best.  Subtract one because
-				// the very next line will add one.
-				p = ss-&gt;limit - 1;
-			}
-		}
-
-		// move p past the newline so it's at the end of the current line.
-		p += 1;
-		new = substitute_string(cmp-&gt;jobs, ss-&gt;cursor, p, &amp;newsize);
-        if(!new) {
-            // there must have been an error
-            compare_halt(ss, match_no);
-            return;
-        }
-
-        if(cmp-&gt;pbuf) free((char*)cmp-&gt;pbuf);
-        cmp-&gt;pbuf = new;
-        cmp-&gt;pcursor = 0;
-        cmp-&gt;plimit = newsize;
-		ss-&gt;cursor = p;
-	}
-}
-
-
-void compare_continue(scanstate *ss, const char *ptr, int len)
-{
-	compare_state *cmp = (compare_state*)ss-&gt;scanref;
-
-    if(!ss-&gt;scanref) {
-        // we already decided the files don't match
-        // so don't waste time comparing more.
-        return;
-    }
-
-	if(cmp-&gt;jobs) {
-		compare_continue_lines(ss, cmp, ptr, len);
-	} else {
-		compare_continue_bytes(ss, ptr, len);
-	}
-}
-
-
-void compare_end(scanstate *ss)
-{
-	compare_state *cmp = (compare_state*)ss-&gt;scanref;
-
-    if(!ss-&gt;scanref) {
-        // we already decided the files don't match
-        // so don't waste time comparing more.
-        return;
-    }
-
-	assert(cmp-&gt;pcursor &lt;= cmp-&gt;plimit);
-	assert(ss-&gt;cursor &lt;= ss-&gt;limit);
-
-	if(cmp-&gt;jobs) {
-		// if there's more data in the pbuf then fail.
-		if(cmp-&gt;plimit - cmp-&gt;pcursor != 0) {
-			compare_halt(ss, match_no);
-			return;
-		}
-	}
-
-	// if we have no data left in the scan buffer
-	if(ss-&gt;limit - ss-&gt;cursor == 0) {
-		// and our input file is at eof
-		if(compare_fill(ss) == 0) {
-			// then the two data streams match
-			compare_halt(ss, match_yes);
-			return;
-		}
-	}
-
-    // otherwise, they don't.
-    compare_halt(ss, match_no);
-}
-
-

Copied: trunk/compare.c (from rev 85, TRUNK/compare.c)

Deleted: trunk/compare.h
===================================================================
--- TRUNK/compare.h	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/compare.h	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,27 +0,0 @@
-/* compare.h
- * Scott Bronson
- * 31 Dec 2004
- *
- * File comparison prototypes.
- *
- * See compare.c for license.
- */
-
-#include &quot;pcrs.h&quot;
-#include &quot;matchval.h&quot;
-#include &quot;re2c/scan.h&quot;
-
-
-/** Returns zero if the compare has stopped (i.e. the files differed).
- */
-
-#define compare_in_progress(ss) ((ss)-&gt;scanref)
-
-
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *joblist);
-void compare_continue(scanstate *ss, const char *ptr, int len);
-void compare_end(scanstate *cmp);
-
-// no better place to put this for now...
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize);
-

Copied: trunk/compare.h (from rev 85, TRUNK/compare.h)

Copied: trunk/examples (from rev 85, TRUNK/examples)

Deleted: trunk/matchval.h
===================================================================
--- TRUNK/matchval.h	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/matchval.h	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,27 +0,0 @@
-/* matchval.h
- * Scott Bronson
- * 31 Dec 2004
- *
- */
-
-#ifndef MATCHVAL_H
-#define MATCHVAL_H
-
-
-/**
- * Simply a tristate that tells whether something
- *    - matches
- *    - doesn't match
- *    - hasn't been checked yet.
- */
-
-typedef enum {
-    match_inprogress = -2,
-    match_unknown = -1,
-    match_no = 0,
-    match_yes = 1,
-} matchval;
-
-
-#endif
-

Copied: trunk/matchval.h (from rev 85, TRUNK/matchval.h)

Copied: trunk/re2c (from rev 85, TRUNK/re2c)

Deleted: trunk/stscan.c
===================================================================
--- TRUNK/stscan.c	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/stscan.c	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,437 +0,0 @@
-/* Generated by re2c 0.5 on Sun Dec 18 12:25:01 2005 */
-
-/* stscan.re
- * Scott Bronson
- *
- * This file is covered by the MIT license.
- *
- * Scanner for status files files.
- * This file needs to be processed by re2c, <A HREF="http://re2c.org">http://re2c.org</A>
- */
-
-#include &quot;stscan.h&quot;
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a recognized token, it returns that token with the text
- * of the entire line.  Otherwise, it returns stGARBAGE.
- *
- * Note that this scanner only returns complete lines.  If the file
- * doesn't end with a newline, then the last line will be lost.
- * I think.
- */
-
-int stscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    inc_line(ss);
-
-{
-	YYCTYPE yych;
-	unsigned int yyaccept;
-	goto yy0;
-yy1:	++YYCURSOR;
-yy0:
-	if((YYLIMIT - YYCURSOR) &lt; 8) YYFILL(8);
-	yych = *YYCURSOR;
-	switch(yych){
-	case '\n':	goto yy10;
-	case 'A':	goto yy7;
-	case 'C':	goto yy3;
-	case 'D':	goto yy6;
-	case 'P':	goto yy4;
-	case 'R':	goto yy5;
-	case 'S':	goto yy2;
-	default:	goto yy8;
-	}
-yy2:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy77;
-	default:	goto yy9;
-	}
-yy3:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy67;
-	default:	goto yy9;
-	}
-yy4:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy55;
-	default:	goto yy9;
-	}
-yy5:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy44;
-	default:	goto yy9;
-	}
-yy6:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy23;
-	case 'O':	goto yy24;
-	default:	goto yy9;
-	}
-yy7:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'B':	goto yy12;
-	default:	goto yy9;
-	}
-yy8:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy9;
-yy9:	switch(yych){
-	case '\n':	goto yy10;
-	default:	goto yy8;
-	}
-yy10:	yych = *++YYCURSOR;
-	goto yy11;
-yy11:
-
-	{ return stGARBAGE; }
-yy12:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy13;
-	default:	goto yy9;
-	}
-yy13:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy14;
-	default:	goto yy9;
-	}
-yy14:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy15;
-	default:	goto yy9;
-	}
-yy15:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy16;
-	default:	goto yy9;
-	}
-yy16:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy17;
-	default:	goto yy9;
-	}
-yy17:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy18;
-yy18:	switch(yych){
-	case '\t':	case ' ':	goto yy17;
-	case '\n':	goto yy10;
-	case ':':	goto yy19;
-	default:	goto yy8;
-	}
-yy19:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy20;
-yy20:	switch(yych){
-	case '\n':	goto yy21;
-	default:	goto yy19;
-	}
-yy21:	yych = *++YYCURSOR;
-	goto yy22;
-yy22:
-
-	{ return stABORTED; }
-yy23:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'S':	goto yy33;
-	default:	goto yy9;
-	}
-yy24:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy25;
-	default:	goto yy9;
-	}
-yy25:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy26;
-	default:	goto yy9;
-	}
-yy26:	yych = *++YYCURSOR;
-	switch(yych){
-	case '\t':	case ' ':	goto yy29;
-	case '\n':	goto yy27;
-	default:	goto yy8;
-	}
-yy27:	yych = *++YYCURSOR;
-	goto yy28;
-yy28:
-
-	{ return stDONE; }
-yy29:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy30;
-yy30:	switch(yych){
-	case '\t':	case ' ':	goto yy29;
-	case '\n':	goto yy27;
-	default:	goto yy31;
-	}
-yy31:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy32;
-yy32:	switch(yych){
-	case '\n':	goto yy27;
-	default:	goto yy31;
-	}
-yy33:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy34;
-	default:	goto yy9;
-	}
-yy34:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'B':	goto yy35;
-	default:	goto yy9;
-	}
-yy35:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'L':	goto yy36;
-	default:	goto yy9;
-	}
-yy36:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy37;
-	default:	goto yy9;
-	}
-yy37:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy38;
-	default:	goto yy9;
-	}
-yy38:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy39;
-yy39:	switch(yych){
-	case '\t':	case ' ':	goto yy38;
-	case '\n':	goto yy10;
-	case ':':	goto yy40;
-	default:	goto yy8;
-	}
-yy40:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy41;
-yy41:	switch(yych){
-	case '\n':	goto yy42;
-	default:	goto yy40;
-	}
-yy42:	yych = *++YYCURSOR;
-	goto yy43;
-yy43:
-
-	{ return stDISABLED; }
-yy44:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy45;
-	default:	goto yy9;
-	}
-yy45:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy46;
-	default:	goto yy9;
-	}
-yy46:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy47;
-	default:	goto yy9;
-	}
-yy47:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy48;
-	default:	goto yy9;
-	}
-yy48:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'G':	goto yy49;
-	default:	goto yy9;
-	}
-yy49:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy50;
-yy50:	switch(yych){
-	case '\t':	case ' ':	goto yy49;
-	case '\n':	goto yy10;
-	case ':':	goto yy51;
-	default:	goto yy8;
-	}
-yy51:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy52;
-yy52:	switch(yych){
-	case '\n':	goto yy53;
-	default:	goto yy51;
-	}
-yy53:	yych = *++YYCURSOR;
-	goto yy54;
-yy54:
-
-	{ return stRUNNING; }
-yy55:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy56;
-	default:	goto yy9;
-	}
-yy56:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'P':	goto yy57;
-	default:	goto yy9;
-	}
-yy57:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy58;
-	default:	goto yy9;
-	}
-yy58:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy59;
-	default:	goto yy9;
-	}
-yy59:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy60;
-	default:	goto yy9;
-	}
-yy60:	yych = *++YYCURSOR;
-	switch(yych){
-	case '\t':	case ' ':	goto yy63;
-	case '\n':	goto yy61;
-	default:	goto yy8;
-	}
-yy61:	yych = *++YYCURSOR;
-	goto yy62;
-yy62:
-
-	{ return stPREPARE; }
-yy63:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy64;
-yy64:	switch(yych){
-	case '\t':	case ' ':	goto yy63;
-	case '\n':	goto yy61;
-	default:	goto yy65;
-	}
-yy65:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy66;
-yy66:	switch(yych){
-	case '\n':	goto yy61;
-	default:	goto yy65;
-	}
-yy67:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy68;
-	default:	goto yy9;
-	}
-yy68:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'F':	goto yy69;
-	default:	goto yy9;
-	}
-yy69:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy70;
-	default:	goto yy9;
-	}
-yy70:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'G':	goto yy71;
-	default:	goto yy9;
-	}
-yy71:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy72;
-yy72:	switch(yych){
-	case '\t':	case ' ':	goto yy71;
-	case '\n':	goto yy10;
-	case ':':	goto yy73;
-	default:	goto yy8;
-	}
-yy73:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy74;
-yy74:	switch(yych){
-	case '\n':	goto yy75;
-	default:	goto yy73;
-	}
-yy75:	yych = *++YYCURSOR;
-	goto yy76;
-yy76:
-
-	{ return stCONFIG; }
-yy77:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy78;
-	default:	goto yy9;
-	}
-yy78:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy79;
-	default:	goto yy9;
-	}
-yy79:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy80;
-	default:	goto yy9;
-	}
-yy80:	yych = *++YYCURSOR;
-	switch(yych){
-	case '\t':	case ' ':	goto yy83;
-	case '\n':	goto yy81;
-	default:	goto yy8;
-	}
-yy81:	yych = *++YYCURSOR;
-	goto yy82;
-yy82:
-
-	{ return stSTART; }
-yy83:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy84;
-yy84:	switch(yych){
-	case '\t':	case ' ':	goto yy83;
-	case '\n':	goto yy81;
-	default:	goto yy85;
-	}
-yy85:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy86;
-yy86:	switch(yych){
-	case '\n':	goto yy81;
-	default:	goto yy85;
-	}
-}
-
-
-}
-
-
-/** Prepares the given scanner to scan a status file.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* stscan_attach(scanstate *ss)
-{
-    if(ss) {
-        ss-&gt;state = stscan_start;
-    }
-
-    return ss;
-}
-

Copied: trunk/stscan.c (from rev 85, TRUNK/stscan.c)

Deleted: trunk/stscan.re
===================================================================
--- TRUNK/stscan.re	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/stscan.re	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,63 +0,0 @@
-/* stscan.re
- * Scott Bronson
- *
- * This file is covered by the MIT license.
- *
- * Scanner for status files files.
- * This file needs to be processed by re2c, <A HREF="http://re2c.org">http://re2c.org</A>
- */
-
-#include &quot;stscan.h&quot;
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a recognized token, it returns that token with the text
- * of the entire line.  Otherwise, it returns stGARBAGE.
- *
- * Note that this scanner only returns complete lines.  If the file
- * doesn't end with a newline, then the last line will be lost.
- * I think.
- */
-
-int stscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    inc_line(ss);
-
-/*!re2c
-
-WS      = [ \t];
-ANYN    = [\000-\377]\[\n];
-NOARG   = &quot;\n&quot;|(WS+ ANYN* &quot;\n&quot;);
-HASARG  = WS* &quot;:&quot; ANYN* &quot;\n&quot;;
-
-&quot;START&quot;   NOARG     { return stSTART; }
-&quot;CONFIG&quot;  HASARG    { return stCONFIG; }
-&quot;PREPARE&quot; NOARG     { return stPREPARE; }
-&quot;RUNNING&quot; HASARG    { return stRUNNING; }
-&quot;DONE&quot;    NOARG     { return stDONE; }
-
-&quot;ABORTED&quot;  HASARG   { return stABORTED; }
-&quot;DISABLED&quot; HASARG   { return stDISABLED; }
-
-ANYN* &quot;\n&quot;          { return stGARBAGE; }
-
-*/
-}
-
-
-/** Prepares the given scanner to scan a status file.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* stscan_attach(scanstate *ss)
-{
-    if(ss) {
-        ss-&gt;state = stscan_start;
-    }
-
-    return ss;
-}
-

Copied: trunk/stscan.re (from rev 85, TRUNK/stscan.re)

Copied: trunk/test (from rev 85, TRUNK/test)

Deleted: trunk/test.c
===================================================================
--- TRUNK/test.c	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/test.c	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,1019 +0,0 @@
-/* test.c
- * 30 Dec 2004
- * Copyright (C) 2004 Scott Bronson
- * 
- * Contains the routines to check/diff/etc test output.
- *
- * This file is covered by the MIT license.
- */
-
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-
-// to get PATH_MAX:
-#include &lt;dirent.h&gt;
-
-#include &quot;re2c/read-fd.h&quot;
-
-#include &quot;test.h&quot;
-#include &quot;stscan.h&quot;
-#include &quot;tfscan.h&quot;
-#include &quot;compare.h&quot;
-#include &quot;rusage.h&quot;
-
-
-// This is the maximum line length for the eachline substitution.
-// Lines longer than this will be parsed as 2 separate lines.
-#define MAX_LINE_LENGTH BUFSIZ
-
-// utility function so you can say i.e. write_strconst(fd, &quot;/&quot;);
-#define write_strconst(fd, str) write((fd), (str), sizeof(str)-1)
-
-static int test_runs = 0;
-static int test_successes = 0;
-static int test_failures = 0;
-
-
-const char *convert_testfile_name(const char *fn)
-{
-    if(fn[0] == '-' &amp;&amp; fn[1] == '\0') {
-        return &quot;(STDIN)&quot;;
-    }
-
-	return fn;
-}
-
-
-const char* get_testfile_name(struct test *test)
-{
-    return convert_testfile_name(test-&gt;testfilename);
-}
-
-
-/** Tells if the given file descriptor has a nonzero length.
- * NOTE: it changes the file offset to the end of the file.
- *
- * Returns nonzero if file has data, zero if it doesn't.
- * Actually, it just returns the file's length.
- */
-
-int fd_has_data(int fd)
-{
-    off_t pos = lseek(fd, 0, SEEK_END);
-    if(pos &lt; 0) {
-        perror(&quot;lseek in fd_has_data&quot;);
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    return pos;
-}
-
-
-/** Tries to find the argument in the status line given.
- *
- * @return  nonzero if the argument could be found, zero if not.
- * If the argument was found, then incp and ince are updated to
- * point to its beginning and end.
- */
-
-static int locate_status_arg(const char **incp, const char **ince)
-{
-	const char *cp = *incp;
-	const char *ce = *ince;
-
-	// trim the newline from the end
-	if(ce[-1] == '\n') ce--;
-
-	// skip to colon separating name from arg
-	while(*cp != ':' &amp;&amp; *cp != '\n' &amp;&amp; cp &lt; ce) cp++;
-	if(*cp == ':') {
-		cp++;					// skip the colon
-		if(*cp == ' ') cp++;	// skip the optional space after it
-		if(cp &lt; ce) {
-			*incp = cp;
-			*ince = ce;
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-
-static char* dup_status_arg(const char *cp, const char *ce)
-{
-	char *ret = NULL;
-
-	if(locate_status_arg(&amp;cp, &amp;ce)) {
-		ret = malloc(ce - cp + 1);
-		if(ret) {
-			memcpy(ret, cp, ce-cp);
-			// replace the NL on the end with the null terminator.
-			ret[ce-cp] = '\0';
-		}
-	}
-
-	return ret;
-}
-
-
-static int copy_status_arg(const char *cp, const char *ce, char *buf, int size)
-{
-	if(locate_status_arg(&amp;cp, &amp;ce)) {
-		int len = ce - cp;
-		if(size-1 &lt; len) len = size-1;
-		memcpy(buf, cp, len);
-		buf[len] = '\0';
-		return 1;
-	}
-
-	return 0;
-}
-
-
-/** Looks through the status file and stores the items of interest
- * in the test structure.
- */
-
-void scan_status_file(struct test *test)
-{
-	char lastfile[PATH_MAX];
-	int lastfile_good = 0;
-    char buf[BUFSIZ];
-    scanstate ss;
-    int tok;
-	int state = 0;
-
-    // first rewind the status file
-    if(lseek(test-&gt;statusfd, 0, SEEK_SET) &lt; 0) {
-        fprintf(stderr, &quot;read_file lseek for status file: %s\n&quot;, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // then create our scanner
-    scanstate_init(&amp;ss, buf, sizeof(buf));
-    readfd_attach(&amp;ss, test-&gt;statusfd);
-    stscan_attach(&amp;ss);
-
-    // now, if we see the token &quot;CBRUNNING&quot; in the token stream,
-    // it means that we attempted to start the test.  If not,
-    // then the test bailed early.
-    do {
-        tok = scan_token(&amp;ss);
-
-		// look for errors...
-        if(tok &lt; 0) {
-            fprintf(stderr, &quot;Error %d pulling status tokens: %s\n&quot;, 
-                    tok, strerror(errno));
-            exit(10);
-        } else if(tok == stGARBAGE) {
-			fprintf(stderr, &quot;Garbage on line %d in the status file: '%.*s'\n&quot;,
-					ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-		} else {
-			state = tok;
-		}
-
-		switch(tok) {
-			case stSTART:
-				// nothing to do
-				break;
-
-			case stCONFIG:
-				if(test-&gt;status == test_pending) {
-					test-&gt;num_config_files += 1;
-					if(copy_status_arg(token_start(&amp;ss), token_end(&amp;ss), lastfile, sizeof(lastfile))) {
-						lastfile_good = 1;
-					} else {
-						fprintf(stderr, &quot;CONFIG needs arg on line %d of the status file: '%.*s'\n&quot;,
-								ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-					}
-				} else {
-					fprintf(stderr, &quot;CONFIG but status (%d) wasn't pending on line %d of the status file: '%.*s'\n&quot;,
-							test-&gt;status, ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-				}
-				break;
-
-			case stPREPARE:
-				// nothing to do
-				break;
-
-			case stRUNNING:
-				if(test-&gt;status == test_pending) {
-					test-&gt;status = test_was_started;
-					if(copy_status_arg(token_start(&amp;ss), token_end(&amp;ss), lastfile, sizeof(lastfile))) {
-						lastfile_good = 1;
-					} else {
-						fprintf(stderr, &quot;RUNNING needs arg on line %d of the status file: '%.*s'\n&quot;,
-								ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-					}
-				} else {
-					fprintf(stderr, &quot;RUNNING but status (%d) wasn't pending on line %d of the status file: '%.*s'\n&quot;,
-							test-&gt;status, ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-				}
-				break;
-
-			case stDONE:
-				if(test-&gt;status == test_was_started) {
-					test-&gt;status = test_was_completed;
-				} else {
-					fprintf(stderr, &quot;DONE but status (%d) wasn't RUNNING on line %d of the status file: '%.*s'\n&quot;,
-							test-&gt;status, ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-				}
-				break;
-			
-			case stABORTED:
-				test-&gt;status = (test-&gt;status &gt;= test_was_started ? test_was_aborted : config_was_aborted);
-				test-&gt;status_reason = dup_status_arg(token_start(&amp;ss), token_end(&amp;ss));
-				break;
-
-			case stDISABLED:
-				test-&gt;status = (test-&gt;status &gt;= test_was_started ? test_was_disabled : config_was_disabled);
-				test-&gt;status_reason = dup_status_arg(token_start(&amp;ss), token_end(&amp;ss));
-				break;
-
-			default:
-				fprintf(stderr, &quot;Unknown token (%d) on line %d of the status file: '%.*s'\n&quot;,
-						tok, ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-		}
-    } while(!scan_finished(&amp;ss));
-
-	if(lastfile_good) {
-		test-&gt;last_file_processed = strdup(lastfile);
-	}
-}
-
-
-/** Prints the command section of the test suitable for how the test is being run.
- *
- * If the user is just running the test, nothing is printed.  If the
- * user is diffing or dumping the test, however, the modified command
- * section needs to be printed to the appropriate command.
- */
-
-void rewrite_command_section(struct test *test, int tok, const char *ptr, int len)
-{
-    // only dump if we're asked to.
-    if(test-&gt;rewritefd &lt; 0) {
-        return;
-    }
-
-    // for now we don't modify it at all.
-    write(test-&gt;rewritefd, ptr, len);
-}
-
-
-/** Copies the command section of the test to the given fileptr and
- * also supplies it to the dump_command_section() routine.
- *
- * If you don't want to dump to a fileptr (i.e. if you're running
- * the test from a file) just pass NULL for fp.
- *
- * This routine is a whole lot like scan_sections except that it stops
- * at the end of the command section.  It leaves the result sections
- * on the stream to be parsed later.
- */
-
-void test_command_copy(struct test *test, FILE *fp)
-{
-    int oldline;
-
-    do {
-        oldline = test-&gt;testfile.line;
-        int tokno = scan_token(&amp;test-&gt;testfile);
-        if(tokno &lt; 0) {
-            fprintf(stderr, &quot;Error %d pulling status tokens: %s\n&quot;, 
-                    tokno, strerror(errno));
-            exit(10);
-        } else if(tokno == 0) {
-			// if the test file is totally empty.
-			break;
-		}
-
-
-        if(tokno != exCOMMAND) {
-            // now we attempt to push the token back on the stream...
-            scan_pushback(&amp;test-&gt;testfile);
-            test-&gt;testfile.line = oldline;
-            // The pushback reset the stream, and I restored the line number,
-            // but the scanner is still in a different state.
-            // We need it to be in a COMMAND state, so that when it feeds
-            // the new SECTION token it marks it NEW.  Reattaching resets
-            // the state to a command state, so we can just do that.
-            tfscan_attach(&amp;test-&gt;testfile);
-            break;
-        }
-
-        // print the modified data to the output stream.
-        rewrite_command_section(test, tokno, token_start(&amp;test-&gt;testfile), token_length(&amp;test-&gt;testfile));
-
-        if(fp) {
-            // print the unmodified data to the command script.
-            fwrite(token_start(&amp;test-&gt;testfile), token_length(&amp;test-&gt;testfile), 1, fp);
-        }
-    } while(!scan_finished(&amp;test-&gt;testfile));
-
-    rewrite_command_section(test, 0, NULL, 0);
-}
-
-
-/** Prepares a test section for comparison against actual results.
- *
- * The comparison is handled by compare.c/h.  We just need to set
- * it up.
- */
-
-void compare_section_start(scanstate *cmpscan, int fd, pcrs_job *joblist,
-		matchval *mv, const char *filename, const char *sectionname)
-{
-    assert(!compare_in_progress(cmpscan));
-
-    // associates the scanstate with the fd and prepares to compare.
-    if(*mv != match_unknown) {
-        fprintf(stderr, &quot;'%s' has multiple %s sections!\n&quot;,
-                filename, sectionname);
-        exit(10);
-    }
-
-    // rewind the file
-    if(lseek(fd, 0, SEEK_SET) &lt; 0) {
-        fprintf(stderr, &quot;read_file lseek for status file: %s\n&quot;, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    scanstate_reset(cmpscan);
-    readfd_attach(cmpscan, fd);
-	compare_attach(cmpscan, mv, joblist);
-
-    // we may want to check the token to see if there are any
-    // special requests (like detabbing).
-}
-
-
-/** Returns true if the given buffer contains non-whitespace characters,
- * false if the buffer consists entirely of whitespace. */
-
-static int contains_nws(const char *cp, int len)
-{
-	const char *ce = cp + len;
-
-	while(cp &lt; ce) {
-		if(!isspace(*cp)) {
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-
-/** Scans the given buffer for the exit value.
- *
- * Ignores everything except for the first digit and any digits that
- * follow it.
- *
- * If digits are found, then it updates the test structure with
- * whether the exit values match or not.
- * If no digits are found, then this routine does nothing.
- */
-
-void parse_exit_clause(struct test *test, const char *cp, int len)
-{
-	const char *ce = cp + len;
-	unsigned int num = 0;
-
-	// skip to the first digit in the buffer
-	while(!isdigit(*cp) &amp;&amp; cp &lt; ce) cp++;
-	if(cp &gt;= ce) return;
-
-	// scan the number
-	while(isdigit(*cp)) {
-		num = 10*num + (*cp - '0');
-		cp++;
-	}
-
-	test-&gt;expected_exitno = num;
-	test-&gt;exitno_match = (test-&gt;exitno == num ? match_yes : match_no);
-}
-
-
-/** Increments cp past the section name.
- *
- * Will not increment cp by more than len bytes.
- * This routine must match the token parsing found in the tfscan_start routine.
- */
-
-const char *skip_section_name(const char *cp, int len)
-{
-	const char *ce = cp + len;
-
-	// skip to colon separating section name from data
-	while(*cp != ':' &amp;&amp; *cp != '\n' &amp;&amp; cp &lt; ce) cp++;
-	if(*cp == ':') cp++;
-	return cp;
-}
-
-
-void parse_modify_clause(struct test *test, const char *cp, const char *ce)
-{
-	pcrs_job *job, **p;
-	char *string;
-	int err;
-
-	char buf[128];	// holds the pcrs command.  We will dynamically
-		// allocate a buffer if the entire substitution doesn't fit
-		// into this buffer.  The vast majority will be &lt;30 chars.
-
-	// skip any leading whitespace
-	while(isspace(*cp) &amp;&amp; cp &lt; ce) cp++;
-
-	// ensure there's still data worth parsing
-	if(*cp == '\n' || cp &gt;= ce) {
-		return;
-	}
-
-	// don't parse it if it's a comment
-	if(*cp == '#') {
-		return;
-	}
-
-	// It's retarded that I can't pass a buf/len combo to pcrs_compile_command.
-	// It's also retarded that pcrs won't tell me where it stopped parsing
-	// so that we can have multiple substitution clauses on line line.
-
-	if(ce-cp-1 &lt; sizeof(buf)) {
-		string = buf;
-	} else {
-		string = malloc(ce-cp+1);
-		if(!string) {
-			perror(&quot;malloc in parse_modify_clause&quot;);
-			exit(10);
-		}
-	}
-
-	memcpy(string, cp, ce-cp);
-	string[ce-cp] = '\0';
-	job = pcrs_compile_command(string, &amp;err);
-	if(job == NULL) {
-        fprintf(stderr, &quot;%s line %d compile error: %s (%d).\n&quot;,
-                get_testfile_name(test), test-&gt;testfile.line,
-                pcrs_strerror(err), err);
-	}
-
-	if(ce-cp-1 &lt; sizeof(buf)) {
-		// nothing to do; we used the static buffer
-	} else {
-		free(string);
-	}
-
-	if(job == NULL) {
-		return;
-	}
-
-	// link this job onto the end of the list.
-	p = &amp;test-&gt;eachline;
-	while(*p) p = &amp;(**p).next;
-	*p = job;
-}
-
-
-/** This routine parses the tokens returned by scan_sections() and
- * compares them against the actual test results.  It stores the
- * results in test-&gt;match_stdout, match_stderr, and match_result.
- *
- * The refcon needs to be an allocated scanner.  It need not be
- * attached to anything -- this routine will take care of attaching
- * and detaching it as needed.
- */
-
-void parse_section_compare(struct test *test, int sec,
-        const char *datap, int len, void *refcon)
-{
-    #define get_cur_state(ss)    ((int)(ss)-&gt;userref)
-    #define set_cur_state(ss,x)  ((ss)-&gt;userref=(void*)(x))
-
-    scanstate *cmpscan = refcon;
-    int newsec = EX_TOKEN(sec);
-
-    if(get_cur_state(cmpscan) == 0) {
-        // This is the first time this scanner has been used.
-        set_cur_state(cmpscan, exCOMMAND);
-    }
-
-    if(!is_section_token(newsec) &amp;&amp; sec != 0) {
-        // We only work with result section tokens.  Ignore all
-        // non-section-tokens except the eof token.
-        return;
-    }
-
-    if(EX_ISNEW(sec) || sec == 0) {
-        // ensure previoius section is finished
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-            case exSTDERR:
-                compare_end(cmpscan);
-                break;
-            default:
-                ;
-        }
-
-        // then fire up the new section
-        set_cur_state(cmpscan, newsec);
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-				if(test-&gt;stdout_match == match_unknown) {
-					compare_section_start(cmpscan, test-&gt;outfd, test-&gt;eachline,
-							&amp;test-&gt;stdout_match, get_testfile_name(test), &quot;STDOUT&quot;);
-				} else {
-					fprintf(stderr, &quot;%s line %d Error: duplicate STDOUT section.  Ignored.\n&quot;,
-							get_testfile_name(test), test-&gt;testfile.line);
-					// as long as scanref == null, no comparison will happen.
-					assert(!cmpscan-&gt;scanref);
-				}
-                break;
-            case exSTDERR:
-				if(test-&gt;stderr_match == match_unknown) {
-					compare_section_start(cmpscan, test-&gt;errfd, test-&gt;eachline,
-							&amp;test-&gt;stderr_match, get_testfile_name(test), &quot;STDERR&quot;);
-				} else {
-					fprintf(stderr, &quot;%s line %d Error: duplicate STDERR section.  Ignored.\n&quot;,
-							get_testfile_name(test), test-&gt;testfile.line);
-					// as long as scanref == null, no comparison will happen.
-					assert(!cmpscan-&gt;scanref);
-				}
-                break;
-            case exRESULT:
-				parse_exit_clause(test, datap, len);
-                break;
-            case exMODIFY:
-				parse_modify_clause(test, skip_section_name(datap,len), datap+len);
-                break;
-            case exCOMMAND:
-                assert(!&quot;Well, this is impossible.  How did you start a new command section??&quot;);
-                break;
-        }
-    } else {
-        // we're continuing an already started section.
-        assert(get_cur_state(cmpscan) == newsec);
-
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-            case exSTDERR:
-                compare_continue(cmpscan, datap, len);
-                break;
-            case exRESULT:
-				if(contains_nws(datap, len)) {
-					fprintf(stderr, &quot;%s line %d Error: RESULT clause contains garbage.\n&quot;,
-							get_testfile_name(test), test-&gt;testfile.line);
-					//exit(10);
-				}
-                break;
-            case exMODIFY:
-				parse_modify_clause(test, datap, datap+len);
-                break;
-            case exCOMMAND:
-                break;
-        }
-    }
-}
-
-
-/** Scans the output sections of the test and calls the supplied parser
- * for each token.
- *
- * Tokens are defined by the tfscan_start() routine.  Currently they're
- * full lines.  If the line starts with a recognized section heading,
- *
- *
- * @param scanner: used to provide the section tokens.
- */
-
-void scan_sections(struct test *test, scanstate *scanner,
-        void (*parseproc)(struct test *test, int sec, const char *datap,
-                int len, void *refcon), void *refcon)
-{
-    // if the testfile is already at its eof, it means that
-    // it didn't have any sections.  therefore, we'll assume
-    // defaults for all values.  we're done.
-    if(scan_finished(scanner)) {
-        return;
-    }
-    
-    do {
-        int tokno = scan_token(scanner);
-        if(tokno &lt; 0) {
-            fprintf(stderr, &quot;Error %d pulling status tokens: %s\n&quot;, 
-                    tokno, strerror(errno));
-            exit(10);
-        } else if(tokno == 0) {
-			break;
-		}
-
-        (*parseproc)(test, tokno, token_start(scanner),
-                token_length(scanner), refcon);
-
-    } while(!scan_finished(scanner));
-
-    // give the parser an eof token so it can finalize things.
-    (*parseproc)(test, 0, NULL, 0, refcon);
-}
-
-
-static void print_reason(struct test *test, const char *name, const char *prep)
-{
-	printf(&quot;%s %-25s &quot;, name, get_testfile_name(test));
-	if(!was_started(test-&gt;status)) {
-		printf(&quot;%s %s&quot;, prep, test-&gt;last_file_processed);
-		if(test-&gt;status_reason) {
-			printf(&quot;: &quot;);
-		}
-	}
-	if(test-&gt;status_reason) {
-		printf(&quot;%s&quot;, test-&gt;status_reason);
-	}
-	printf(&quot;\n&quot;);
-}
-
-
-/** Checks the actual results against the expected results.
- */
-
-void test_results(struct test *test)
-{
-    scanstate scanner;
-    char scanbuf[MAX_LINE_LENGTH];
-	int stdo, stde, exno;	// true if there are differences.
-	
-	if(was_aborted(test-&gt;status)) {
-		print_reason(test, &quot;ABRT&quot;, &quot;by&quot;);
-		test_failures++;
-		test-&gt;aborted = 1;
-		return;
-	}
-
-	if(was_disabled(test-&gt;status)) {
-		print_reason(test, &quot;dis &quot;, &quot;by&quot;);
-		return;
-	}
-
-    if(!was_started(test-&gt;status)) {
-		print_reason(test, &quot;ERR &quot;, &quot;error in&quot;);
-        test_failures++;
-        return;
-    }
-
-    test-&gt;exitno_match = match_unknown;
-    test-&gt;stdout_match = match_unknown;
-    test-&gt;stderr_match = match_unknown;
-
-    scanstate_init(&amp;scanner, scanbuf, sizeof(scanbuf));
-    scan_sections(test, &amp;test-&gt;testfile, parse_section_compare, &amp;scanner);
-
-    assert(test-&gt;stdout_match != match_inprogress);
-    assert(test-&gt;stderr_match != match_inprogress);
-
-    // convert any unknowns into a solid yes/no
-    if(test-&gt;exitno_match == match_unknown) {
-		test-&gt;expected_exitno = 0;
-        test-&gt;exitno_match = (test-&gt;exitno == 0 ? match_yes : match_no);
-    }
-    if(test-&gt;stdout_match == match_unknown) {
-        test-&gt;stdout_match = (fd_has_data(test-&gt;outfd) ? match_no : match_yes);
-    }
-    if(test-&gt;stderr_match == match_unknown) {
-        test-&gt;stderr_match = (fd_has_data(test-&gt;errfd) ? match_no : match_yes);
-    }
-
-    stdo = (test-&gt;stdout_match != match_yes);
-    stde = (test-&gt;stderr_match != match_yes);
-    exno = (test-&gt;exitno_match != match_yes);
-
-    if(!stdo &amp;&amp; !stde &amp;&amp; !exno) {
-        test_successes++;
-        printf(&quot;ok   %s \n&quot;, get_testfile_name(test));
-    } else {
-        test_failures++;
-        printf(&quot;FAIL %-25s &quot;, get_testfile_name(test));
-		printf(&quot;%c%c%c  &quot;,
-				(stdo ? 'O' : '.'),
-				(stde ? 'E' : '.'),
-				(exno ? 'X' : '.'));
-		if(stdo || stde) {
-			if(stdo) printf(&quot;stdout &quot;);
-			if(stdo &amp;&amp; stde) printf(&quot;and &quot;);
-			if(stde) printf(&quot;stderr &quot;);
-			printf(&quot;differed&quot;);
-		}
-		if((stdo || stde) &amp;&amp; exno) printf(&quot;, &quot;);
-		if(exno) printf(&quot;result was %d not %d&quot;, test-&gt;exitno, test-&gt;expected_exitno);
-		printf(&quot;\n&quot;);
-    }
-
-    return;
-}
-
-
-static void write_exit_no(int fd, int exitno)
-{
-    char buf[512];
-    int cnt;
-
-    cnt = snprintf(buf, sizeof(buf), &quot;RESULT: %d\n&quot;, exitno);
-    write(fd, buf, cnt);
-}
-
-
-void write_raw_file(int outfd, int infd)
-{
-    char buf[BUFSIZ];
-    int rcnt, wcnt;
-
-    // first rewind the input file
-    if(lseek(infd, 0, SEEK_SET) &lt; 0) {
-        fprintf(stderr, &quot;write_file lseek on %d: %s\n&quot;, infd, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // then write the file.
-    do {
-        do {
-            rcnt = read(infd, buf, sizeof(buf));
-        } while(rcnt &lt; 0 &amp;&amp; errno == EINTR);
-        if(rcnt &gt; 0) {
-            do {
-                wcnt = write(outfd, buf, rcnt);
-            } while(wcnt &lt; 0 &amp;&amp; errno == EINTR);
-            if(wcnt &lt; 0) {
-                // write error.  do something!
-                perror(&quot;writing in write_file&quot;);
-                break;
-            }
-        } else if (rcnt &lt; 0) {
-            // read error.  do something!
-            perror(&quot;reading in write_file&quot;);
-            break;
-        }
-    } while(rcnt);
-}
-
-
-static void write_modified_file(int outfd, int infd, pcrs_job *job)
-{
-    // this routine is fairly similar to compare_continue_lines.
-    // it would be nice to unify them.  that would take some fairly
-    // major surgery though.
-
-    scanstate scanner, *ss = &scanner;
-    char scanbuf[MAX_LINE_LENGTH];
-    const char *p;
-    char *new;
-    size_t newsize;
-    int rcnt, wcnt;
-
-    // first rewind the input file
-    if(lseek(infd, 0, SEEK_SET) &lt; 0) {
-        fprintf(stderr, &quot;write_file lseek on %d: %s\n&quot;, infd, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // create the scanner we'll use to buffer the lines
-    scanstate_init(ss, scanbuf, sizeof(scanbuf));
-    readfd_attach(ss, infd);
-
-    do {
-        p = memchr(ss-&gt;cursor, '\n', ss-&gt;limit - ss-&gt;cursor);
-        if(!p) {
-            rcnt = (*ss-&gt;read)(ss);
-            if(rcnt &lt; 0) {
-                // read error.  do something!
-                perror(&quot;reading in write_modified_file&quot;);
-                break;
-            }
-            p = memchr(ss-&gt;cursor, '\n', ss-&gt;limit - ss-&gt;cursor);
-            if(!p) {
-                p = ss-&gt;limit - 1;
-            }
-        }
-
-        p += 1;
-        new = substitute_string(job, ss-&gt;cursor, p, &amp;newsize);
-        if(!new) {
-            // substitution error!  message already printed.
-            break;
-        }
-
-        do {
-            wcnt = write(outfd, new, newsize);
-        } while(wcnt &lt; 0 &amp;&amp; errno == EINTR);
-        free(new);
-        if(wcnt &lt; 0) {
-            // write error.  do something!
-            perror(&quot;writing in write_modified_file&quot;);
-            break;
-        }
-        ss-&gt;cursor = p;
-    } while(rcnt);
-}
-
-
-static void write_file(int outfd, int infd, pcrs_job *job)
-{
-	if(!job) {
-		// use the simple, fast routine
-		write_raw_file(outfd, infd);
-	} else {
-		// use the line buffered routine
-		write_modified_file(outfd, infd, job);
-	}
-}
-
-
-/** Writes the actual results in place of the expected results.
- */
-
-void parse_section_output(struct test *test, int sec,
-        const char *datap, int len, void *refcon)
-{
-    assert(sec &gt;= 0);
-
-    switch(sec) {
-        case 0:
-            // don't need to worry about eof
-            break;
-
-        case exSTDOUT|exNEW:
-            test-&gt;stdout_match = match_yes;
-			write_strconst(test-&gt;rewritefd, &quot;STDOUT:\n&quot;);
-            write_file(test-&gt;rewritefd, test-&gt;outfd, test-&gt;eachline);
-            break;
-        case exSTDOUT:
-            // ignore all data in the expected stdout.
-            break;
-
-        case exSTDERR|exNEW:
-            test-&gt;stderr_match = match_yes;
-			write_strconst(test-&gt;rewritefd, &quot;STDERR:\n&quot;);
-            write_file(test-&gt;rewritefd, test-&gt;errfd, test-&gt;eachline);
-        case exSTDERR:
-            // ignore all data in the expected stderr
-            break;
-
-        case exRESULT|exNEW:
-            test-&gt;exitno_match = match_yes;
-            write_exit_no(test-&gt;rewritefd, test-&gt;exitno);
-            break;
-
-        case exRESULT:
-            // allow random garbage in result section to pass
-            write(test-&gt;rewritefd, datap, len);
-            break;
-
-        case exMODIFY|exNEW:
-            parse_modify_clause(test, skip_section_name(datap,len), datap+len);
-            write(test-&gt;rewritefd, datap, len);
-            break;
-
-        case exMODIFY:
-            // parse modify sections and still print them.
-            parse_modify_clause(test, datap, datap+len);
-            write(test-&gt;rewritefd, datap, len);
-            break;
-            
-        default:
-            write(test-&gt;rewritefd, datap, len);
-    }
-}
-
-
-static void dump_reason(struct test *test, const char *name)
-{
-	fprintf(stderr, &quot;ERROR Test %s&quot;, name);
-	if(!was_started(test-&gt;status)) {
-		fprintf(stderr, &quot; by %s&quot;, convert_testfile_name(test-&gt;last_file_processed));
-		if(test-&gt;status_reason) {
-			printf(&quot;: &quot;);
-		}
-	}
-	if(test-&gt;status_reason) {
-		fprintf(stderr, &quot;: %s&quot;, test-&gt;status_reason);
-	}
-	fprintf(stderr, &quot;\n&quot;);
-}
-
-
-/** Prints the actual result sections in the same order as they
- * appear in the testfile.
- */
-
-void dump_results(struct test *test)
-{
-	if(was_aborted(test-&gt;status)) {
-		dump_reason(test, &quot;was aborted&quot;);
-		test-&gt;aborted = 1;
-		return;
-	}
-
-	if(was_disabled(test-&gt;status)) {
-		dump_reason(test, &quot;is disabled&quot;);
-		return;
-
-	}
-
-    if(!was_started(test-&gt;status)) {
-        fprintf(stderr, &quot;Error: %s was not started due to errors in %s.\n&quot;,
-				get_testfile_name(test), test-&gt;last_file_processed);
-        test_failures++;
-        return;
-    }
-
-    // The command section has already been dumped.  We just
-    // need to dump the result sections.  The trick is, though,
-    // that we need to dump them in the same order as they occur
-    // in the testfile otherwise the diff will be all screwed up.
-
-    test-&gt;exitno_match = match_unknown;
-    test-&gt;stdout_match = match_unknown;
-    test-&gt;stderr_match = match_unknown;
-
-    // ensure that we haven't yet parsed any modify sections.
-    assert(!test-&gt;eachline);
-
-    scan_sections(test, &amp;test-&gt;testfile, parse_section_output, NULL);
-
-    // if any sections haven't been output, but they differ from
-    // the default, then they need to be output here at the end.
-
-    if(test-&gt;exitno_match == match_unknown &amp;&amp; test-&gt;exitno != 0) {
-        write_exit_no(test-&gt;rewritefd, test-&gt;exitno);
-    }
-    if(test-&gt;stderr_match == match_unknown &amp;&amp; fd_has_data(test-&gt;errfd)) {
-		write_strconst(test-&gt;rewritefd, &quot;STDERR:\n&quot;);
-        write_file(test-&gt;rewritefd, test-&gt;errfd, test-&gt;eachline);
-    }
-    if(test-&gt;stdout_match == match_unknown &amp;&amp; fd_has_data(test-&gt;outfd)) {
-		write_strconst(test-&gt;rewritefd, &quot;STDOUT:\n&quot;);
-        write_file(test-&gt;rewritefd, test-&gt;outfd, test-&gt;eachline);
-    }
-}
-
-
-void print_test_summary()
-{
-    printf(&quot;\n&quot;);
-    printf(&quot;%d test%s run, &quot;, test_runs, (test_runs != 1 ? &quot;s&quot; : &quot;&quot;));
-    printf(&quot;%d success%s, &quot;, test_successes, (test_successes != 1 ? &quot;es&quot; : &quot;&quot;));
-    printf(&quot;%d failure%s.&quot;, test_failures, (test_failures != 1 ? &quot;s&quot; : &quot;&quot;));
-
-	if(!quiet) {
-		printf(&quot;    &quot;);
-		print_rusage();
-	}
-	
-	printf(&quot;\n&quot;);
-}
-
-
-void test_init(struct test *test)
-{
-    test_runs++;
-    memset(test, 0, sizeof(struct test));
-    test-&gt;rewritefd = -1;
-}
-
-
-void test_free(struct test *test)
-{
-	int err;
-
-	// the buffer for the testfile scanner is allocated on the stack.
-	if(test-&gt;eachline) {
-		pcrs_free_joblist(test-&gt;eachline);
-	}
-
-	if(test-&gt;diffname) {
-		err = close(test-&gt;diff_fd);
-		if(err &lt; 0) {
-			fprintf(stderr, &quot;Could not close %s: %s\n&quot;, test-&gt;diffname, strerror(errno));
-		}
-		err = unlink(test-&gt;diffname);
-		if(err &lt; 0) {
-			fprintf(stderr, &quot;Could not remove %s: %s\n&quot;, test-&gt;diffname, strerror(errno));
-		}
-		free(test-&gt;diffname);
-	}
-
-	if(test-&gt;status_reason) {
-		free(test-&gt;status_reason);
-	}
-
-	if(test-&gt;last_file_processed) {
-		free(test-&gt;last_file_processed);
-	}
-}
-
-

Copied: trunk/test.c (from rev 85, TRUNK/test.c)

Deleted: trunk/tfscan.c
===================================================================
--- TRUNK/tfscan.c	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/tfscan.c	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,258 +0,0 @@
-/* Generated by re2c 0.5 on Sun Dec 18 12:25:00 2005 */
-
-/* tfscan.re
- * Scott Bronson
- * 30 Dec 2004
- *
- * Scanner for test files.
- * This file needs to be processed by re2c, <A HREF="http://re2c.org">http://re2c.org</A>
- *
- * This file is covered by the MIT License.
- */
-
-#include &quot;tfscan.h&quot;
-
-
-#define START(x) (ss-&gt;scanref=(void*)(x))
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a new section, it returns the token name of that section
- * with the exNEW flag turned on.  After that, it returns each
- * line in the section with the token's identifier.  Then, when it
- * finds a new section, you get a exNEW+TOKEN of the new section.
- */
-
-int tfscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    inc_line(ss);
-
-{
-	YYCTYPE yych;
-	unsigned int yyaccept;
-	goto yy0;
-yy1:	++YYCURSOR;
-yy0:
-	if((YYLIMIT - YYCURSOR) &lt; 6) YYFILL(6);
-	yych = *YYCURSOR;
-	switch(yych){
-	case '\n':	goto yy7;
-	case 'M':	goto yy4;
-	case 'R':	goto yy3;
-	case 'S':	goto yy2;
-	default:	goto yy5;
-	}
-yy2:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy29;
-	default:	goto yy6;
-	}
-yy3:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy19;
-	default:	goto yy6;
-	}
-yy4:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy9;
-	default:	goto yy6;
-	}
-yy5:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy6;
-yy6:	switch(yych){
-	case '\n':	goto yy7;
-	default:	goto yy5;
-	}
-yy7:	yych = *++YYCURSOR;
-	goto yy8;
-yy8:
-
-	{ return (int)ss-&gt;scanref; }
-yy9:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy10;
-	default:	goto yy6;
-	}
-yy10:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy11;
-	default:	goto yy6;
-	}
-yy11:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'F':	goto yy12;
-	default:	goto yy6;
-	}
-yy12:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'Y':	goto yy13;
-	default:	goto yy6;
-	}
-yy13:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy14;
-yy14:	switch(yych){
-	case '\t':	case ' ':	goto yy13;
-	case '\n':	goto yy7;
-	case ':':	goto yy15;
-	default:	goto yy5;
-	}
-yy15:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy16;
-yy16:	switch(yych){
-	case '\n':	goto yy17;
-	default:	goto yy15;
-	}
-yy17:	yych = *++YYCURSOR;
-	goto yy18;
-yy18:
-
-	{ START(exMODIFY); return exNEW|exMODIFY; }
-yy19:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'S':	goto yy20;
-	default:	goto yy6;
-	}
-yy20:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy21;
-	default:	goto yy6;
-	}
-yy21:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'L':	goto yy22;
-	default:	goto yy6;
-	}
-yy22:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy23;
-	default:	goto yy6;
-	}
-yy23:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy24;
-yy24:	switch(yych){
-	case '\t':	case ' ':	goto yy23;
-	case '\n':	goto yy7;
-	case ':':	goto yy25;
-	default:	goto yy5;
-	}
-yy25:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy26;
-yy26:	switch(yych){
-	case '\n':	goto yy27;
-	default:	goto yy25;
-	}
-yy27:	yych = *++YYCURSOR;
-	goto yy28;
-yy28:
-
-	{ START(exRESULT); return exNEW|exRESULT; }
-yy29:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy30;
-	default:	goto yy6;
-	}
-yy30:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy31;
-	case 'O':	goto yy32;
-	default:	goto yy6;
-	}
-yy31:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy40;
-	default:	goto yy6;
-	}
-yy32:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy33;
-	default:	goto yy6;
-	}
-yy33:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy34;
-	default:	goto yy6;
-	}
-yy34:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy35;
-yy35:	switch(yych){
-	case '\t':	case ' ':	goto yy34;
-	case '\n':	goto yy7;
-	case ':':	goto yy36;
-	default:	goto yy5;
-	}
-yy36:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy37;
-yy37:	switch(yych){
-	case '\n':	goto yy38;
-	default:	goto yy36;
-	}
-yy38:	yych = *++YYCURSOR;
-	goto yy39;
-yy39:
-
-	{ START(exSTDOUT); return exNEW|exSTDOUT; }
-yy40:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy41;
-	default:	goto yy6;
-	}
-yy41:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy42;
-yy42:	switch(yych){
-	case '\t':	case ' ':	goto yy41;
-	case '\n':	goto yy7;
-	case ':':	goto yy43;
-	default:	goto yy5;
-	}
-yy43:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy44;
-yy44:	switch(yych){
-	case '\n':	goto yy45;
-	default:	goto yy43;
-	}
-yy45:	yych = *++YYCURSOR;
-	goto yy46;
-yy46:
-
-	{ START(exSTDERR); return exNEW|exSTDERR; }
-}
-
-
-}
-
-
-/** Prepares the given scanner to scan a testfile.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* tfscan_attach(scanstate *ss)
-{
-    if(ss) {
-        START(exCOMMAND);
-        ss-&gt;state = tfscan_start;
-    }
-
-    return ss;
-}
-

Copied: trunk/tfscan.c (from rev 85, TRUNK/tfscan.c)

Deleted: trunk/tfscan.h
===================================================================
--- TRUNK/tfscan.h	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/tfscan.h	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,40 +0,0 @@
-/* tfscan.h
- * Scott Bronson
- */
-
-/** @file tfscan.h
- *
- * This file declares the interface to the expected results test
- * file scanner.
- */
-
-
-#include &quot;re2c/scan.h&quot;
-
-
-/** This lists all the tokens that the test file scanner may return.
- */
-
-enum {
-    // command sections are numbered between 1 and 63
-    exCOMMAND = 1,			///&lt; marks a new line in the command section.  (in the future, we might actually start parsing the command section)
-    exCOMMAND_TOKEN_END,	///&lt; never returned.  this token is always one higher than the highest-numbered command token.
-
-    // result sections are numbered from 64 through 127.
-    exSTDOUT = 64,			///&lt; marks a line in the stdout section.
-    exSTDERR,				///&lt; marks a line in the stderr section.
-    exRESULT,				///&lt; marks a line in the result (exit value) section.
-    exMODIFY,				///&lt; marks a line in the modify (per-line substitution) section.
-    exRESULT_TOKEN_END,		///&lt; never returned.  this token is always one higher than the highest-numbered section token.
-
-    exNEW = 0x100,			///&lt; flag added to the section token that specifies that this is the start of a new section.
-};
-
-
-#define EX_TOKEN(x) ((x)&amp;0xFF)
-#define EX_ISNEW(x) ((x)&amp;exNEW)
-#define is_command_token(x) (EX_TOKEN(x)&gt;=exCOMMAND &amp;&amp; EX_TOKEN(x)&lt;ex_COMMAND_TOKEN_END)
-#define is_section_token(x) (EX_TOKEN(x)&gt;=exSTDOUT &amp;&amp; EX_TOKEN(x)&lt;exRESULT_TOKEN_END)
-
-scanstate* tfscan_attach(scanstate *ss);
-

Copied: trunk/tfscan.h (from rev 85, TRUNK/tfscan.h)

Deleted: trunk/tfscan.re
===================================================================
--- TRUNK/tfscan.re	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/tfscan.re	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,60 +0,0 @@
-/* tfscan.re
- * Scott Bronson
- * 30 Dec 2004
- *
- * Scanner for test files.
- * This file needs to be processed by re2c, <A HREF="http://re2c.org">http://re2c.org</A>
- *
- * This file is covered by the MIT License.
- */
-
-#include &quot;tfscan.h&quot;
-
-
-#define START(x) (ss-&gt;scanref=(void*)(x))
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a new section, it returns the token name of that section
- * with the exNEW flag turned on.  After that, it returns each
- * line in the section with the token's identifier.  Then, when it
- * finds a new section, you get a exNEW+TOKEN of the new section.
- */
-
-int tfscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    inc_line(ss);
-
-/*!re2c
-
-WS      = [ \t];
-ANYN    = [\000-\377]\[\n];
-
-&quot;STDOUT&quot; WS* &quot;:&quot; ANYN* &quot;\n&quot;  { START(exSTDOUT); return exNEW|exSTDOUT; }
-&quot;STDERR&quot; WS* &quot;:&quot; ANYN* &quot;\n&quot;  { START(exSTDERR); return exNEW|exSTDERR; }
-&quot;RESULT&quot; WS* &quot;:&quot; ANYN* &quot;\n&quot;  { START(exRESULT); return exNEW|exRESULT; }
-&quot;MODIFY&quot; WS* &quot;:&quot; ANYN* &quot;\n&quot;  { START(exMODIFY); return exNEW|exMODIFY; }
-
-ANYN* &quot;\n&quot;                  { return (int)ss-&gt;scanref; }
-
-*/
-}
-
-
-/** Prepares the given scanner to scan a testfile.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* tfscan_attach(scanstate *ss)
-{
-    if(ss) {
-        START(exCOMMAND);
-        ss-&gt;state = tfscan_start;
-    }
-
-    return ss;
-}
-

Deleted: trunk/tmtest.conf
===================================================================
--- TRUNK/tmtest.conf	2005-12-21 02:17:48 UTC (rev 83)
+++ trunk/tmtest.conf	2006-02-27 23:10:08 UTC (rev 86)
@@ -1,56 +0,0 @@
-# tmtest.conf
-# Scott Bronson
-# 31 Dec 2004
-
-
-# This file tells how to run tests on tmtest itself.
-# See tmtestetc or tmtestrc for examples of globally-installed
-# configuration files.
-
-
-# This can be a little confusing because one copy of tmtest runs another
-# copy and checks its output.  We'll call the executable doing the testing
-# the superexec, and the program being tested the subexec.
-#
-# Because the user launched the superexec, we have no control over which
-# executable is used to run the tests.  Hopefully it's reasonably stable.
-#
-# This configuration file, tmtest.conf, tells the superexec how to run the
-# test battery.  Local settings are read from /etc/tmtest.conf, ~/.tmtestrc,
-# etc., then this file is loaded.
-#
-# The subtests do not read any configuration files outside of the test
-# directory except for one, tmtest.sub.conf.
-
-
-# turn on debugging
-# set -x
-
-
-# All tests are written to be pedantic.  We want them to exit at the
-# first sign of trouble and have the result code reported in RESULT.
-
-set -e
-
-
-
-# Add the current directory at the front of the PATH environment variable.
-# This means that while the test is running, any executables in this
-# directory will take priority over similarly-named executables anywhere
-# else (like /usr/bin or ~/bin).  This ensures that we lauch the unstable
-# copy of tmtest to handle each test.
-
-PATH=&quot;$MYDIR:$PATH&quot;;
-
-
-# All testfiles include $args in the arguments to the subexec.
-# (if they don't, it's a bug in the test).
-#
-# This allows us to specify default commands for all tests being run.
-# For instance, forcing the config file ensures that no config files
-# outside the test directory will be read.  This way we can be sure
-# that the tests are not succeeding due to some local configuration;
-# their environment is as clean as we can possibly make it.
-
-args=&quot;--config=$MYPATH/test/tmtest.sub.conf&quot;
-

Copied: trunk/tmtest.conf (from rev 85, TRUNK/tmtest.conf)




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000002.html">[Tmtest-commits] [85] TRUNK: Make a simple rename, break the build.
</A></li>
	<LI>Next message: <A HREF="000004.html">[Tmtest-commits] [87] create releases directory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3">[ date ]</a>
              <a href="thread.html#3">[ thread ]</a>
              <a href="subject.html#3">[ subject ]</a>
              <a href="author.html#3">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tmtest-commits">More information about the Tmtest-commits
mailing list</a><br>
</body></html>
