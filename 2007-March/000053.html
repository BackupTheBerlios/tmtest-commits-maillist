<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tmtest-commits] [136] trunk: Use upstream mutest instead of	embedding zutest.
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tmtest-commits/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:tmtest-commits%40lists.berlios.de?Subject=Re%3A%20%5BTmtest-commits%5D%20%5B136%5D%20trunk%3A%20Use%20upstream%20mutest%20instead%20of%0A%09embedding%20zutest.&In-Reply-To=%3C200703010001.l2101I18021650%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000054.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tmtest-commits] [136] trunk: Use upstream mutest instead of	embedding zutest.</H1>
    <B>tmtest-commits at lists.berlios.de</B> 
    <A HREF="mailto:tmtest-commits%40lists.berlios.de?Subject=Re%3A%20%5BTmtest-commits%5D%20%5B136%5D%20trunk%3A%20Use%20upstream%20mutest%20instead%20of%0A%09embedding%20zutest.&In-Reply-To=%3C200703010001.l2101I18021650%40sheep.berlios.de%3E"
       TITLE="[Tmtest-commits] [136] trunk: Use upstream mutest instead of	embedding zutest.">tmtest-commits at lists.berlios.de
       </A><BR>
    <I>Thu Mar  1 01:01:18 CET 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000054.html">[Tmtest-commits] [137] trunk/: Need to use a publicly-accessible	repo for the mutest
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#53">[ date ]</a>
              <a href="thread.html#53">[ thread ]</a>
              <a href="subject.html#53">[ subject ]</a>
              <a href="author.html#53">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Revision: 136
Author:   bronson
Date:     2007-03-01 01:01:04 +0100 (Thu, 01 Mar 2007)

Log Message:
-----------
Use upstream mutest instead of embedding zutest.

Modified Paths:
--------------
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/main.c
    trunk/pathstack.c
    trunk/test/02-running/03-Unit-Fails.test
    trunk/test/02-running/50-OpenFDsTest.test
    trunk/units.c
    trunk/units.h

Removed Paths:
-------------
    trunk/zutest.c
    trunk/zutest.h

Property Changed:
----------------
    trunk/

Property changes on: trunk
___________________________________________________________________
Name: svn:externals
   + mutest svn+<A HREF="ssh://holt.dreamhost.com/home/bronson/svn/mutest/trunk">ssh://holt.dreamhost.com/home/bronson/svn/mutest/trunk</A>


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/Makefile	2007-03-01 00:01:04 UTC (rev 136)
@@ -39,8 +39,8 @@
 CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c template.c
 CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h
 # unit test files
-CSRC+=units.c zutest.c
-CHDR+=units.h zutest.h
+CSRC+=units.c mutest/mutest.c
+CHDR+=units.h mutest/mutest.h
 
 # It makes it rather hard to debug when Make deletes the intermediate files.
 INTERMED=stscan.c
@@ -66,8 +66,8 @@
 	tmtest test
 	
 # Sometimes the app won't compile but we still want to run the unit tests...
-units: compare.c pathstack.c units.c units.h zutest.c zutest.h $(SCANH) $(SCANC) Makefile
-	$(CC) -g -Wall compare.c pathstack.c pathconv.c units.c zutest.c $(SCANC) -o units -DUNITS_MAIN
+units: compare.c pathstack.c units.c units.h mutest/mutest.c mutest/main.c mutest/mutest.h $(SCANH) $(SCANC) Makefile
+	$(CC) -g -Wall compare.c pathstack.c pathconv.c units.c mutest/mutest.c mutest/main.c $(SCANC) -o units -DUNITS_MAIN
 
 run-units: units
 	./units
@@ -105,7 +105,7 @@
 endif
 
 clean:
-	rm -f tmtest template.c tags zutest
+	rm -f tmtest template.c tags
 
 distclean: clean
 	rm -f stscan.[co]
@@ -129,6 +129,4 @@
 	
 reupdate:
 	ls re2c/*.[ch] | (ODIR=`pwd`; cd ../oe; xargs cp --target-directory $$ODIR/re2c)
-
-zutest: zutest.c zutest.h Makefile
-	gcc -Wall -Werror -g zutest.c -DZUTEST_MAIN -o zutest
+	

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/TODO	2007-03-01 00:01:04 UTC (rev 136)
@@ -61,6 +61,8 @@
 - Add the zutest unit tests to the tmtest test battery.
 - Make zutest able to run both quiet (only failures printed) and verbose
   (everything printed and then some).
+- Try to re-enable some of the disabled tests.  Especially the openfds
+  test; it's helped in the past to ensure that we don't leak fds.
 
 0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.

Modified: trunk/compare.c
===================================================================
--- trunk/compare.c	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/compare.c	2007-03-01 00:01:04 UTC (rev 136)
@@ -360,11 +360,11 @@
 
 void compare_tests()
 {
-	zutest( test_empty() );
-	zutest( test_standard() );
-	zutest( test_large() );
-	zutest( test_newlines() );
-	zutest( test_inc() );
-	zutest( test_inc_newlines() );
+	mutest( test_empty() );
+	mutest( test_standard() );
+	mutest( test_large() );
+	mutest( test_newlines() );
+	mutest( test_inc() );
+	mutest( test_inc_newlines() );
 };
 

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/main.c	2007-03-01 00:01:04 UTC (rev 136)
@@ -1049,11 +1049,11 @@
 				break;
 
 			case 'U':
-				run_unit_tests(run_all_unit_tests);
+				run_unit_tests(all_tests);
 				exit(0);
 
 			case 257:
-				run_unit_tests_showing_failures(run_all_unit_tests);
+				run_unit_tests_showing_failures(all_tests);
 				exit(0);
 
 			case 'V':

Modified: trunk/pathstack.c
===================================================================
--- trunk/pathstack.c	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/pathstack.c	2007-03-01 00:01:04 UTC (rev 136)
@@ -320,9 +320,9 @@
 
 void pathstack_tests()
 {
-	zutest( test_pathstack() );
-	zutest( test_small_pathstack() );
-	zutest( test_empty_pathstack() );
+	mutest( test_pathstack() );
+	mutest( test_small_pathstack() );
+	mutest( test_empty_pathstack() );
 }
 
 #endif

Modified: trunk/test/02-running/03-Unit-Fails.test
===================================================================
--- trunk/test/02-running/03-Unit-Fails.test	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/test/02-running/03-Unit-Fails.test	2007-03-01 00:01:04 UTC (rev 136)
@@ -10,77 +10,77 @@
 # This doesn't work either
 # $tmtest --show-unit-fails &gt; &gt;(sed s/0x[A-Z0-9][A-Z0-9]*/0xHEXDIGIT/g) 2&gt;&amp;1
 
-$tmtest --show-unit-fails 2&gt;&amp;1 | sed s/0x[A-Z0-9][A-Z0-9]*/0xHEXDIGIT/g | sed s/zutest.c:[0-9]\*:/zutest.c:NNN:/
+$tmtest --show-unit-fails 2&gt;&amp;1 | sed s/0x[A-Z0-9][A-Z0-9]*/0xHEXDIGIT/g | sed s/mutest\\/mutest.c:[0-9]\*:/mutest.c:NNN:/
 
 STDOUT:
-zutest.c:NNN: In test_assert_int, assert a == b failed. a==4 and b==3!
-zutest.c:NNN: In test_assert_int, assert a != c failed. a==4 and c==4!
-zutest.c:NNN: In test_assert_int, assert a &gt; c failed. a==4 and c==4!
-zutest.c:NNN: In test_assert_int, assert b &gt; c failed. b==3 and c==4!
-zutest.c:NNN: In test_assert_int, assert b &gt;= a failed. b==3 and a==4!
-zutest.c:NNN: In test_assert_int, assert c &lt; a failed. c==4 and a==4!
-zutest.c:NNN: In test_assert_int, assert c &lt; b failed. c==4 and b==3!
-zutest.c:NNN: In test_assert_int, assert a &lt;= b failed. a==4 and b==3!
-zutest.c:NNN: In test_assert_int, assert a == 0 failed. a==4!
-zutest.c:NNN: In test_assert_int, assert z != 0 failed. z==0!
-zutest.c:NNN: In test_assert_int, assert z &gt; 0 failed. z==0!
-zutest.c:NNN: In test_assert_int, assert n &gt; 0 failed. n==-1!
-zutest.c:NNN: In test_assert_int, assert a &lt;= 0 failed. a==4!
-zutest.c:NNN: In test_assert_int, assert z &lt; 0 failed. z==0!
-zutest.c:NNN: In test_assert_int, assert a &lt; 0 failed. a==4!
-zutest.c:NNN: In test_assert_int, assert n &gt;= 0 failed. n==-1!
-zutest.c:NNN: In test_assert_hex, assert a == b failed. a==0xHEXDIGIT and b==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert a != c failed. a==0xHEXDIGIT and c==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert a &gt; c failed. a==0xHEXDIGIT and c==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert b &gt; c failed. b==0xHEXDIGIT and c==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert b &gt;= a failed. b==0xHEXDIGIT and a==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert c &lt; a failed. c==0xHEXDIGIT and a==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert c &lt; b failed. c==0xHEXDIGIT and b==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert a &lt;= b failed. a==0xHEXDIGIT and b==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert a == 0 failed. a==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert z != 0 failed. z==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert z &gt; 0 failed. z==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert n &gt; 0 failed. n==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert a &lt;= 0 failed. a==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert z &lt; 0 failed. z==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert a &lt; 0 failed. a==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_hex, assert n &gt;= 0 failed. n==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert n != NULL failed. n==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert ap == NULL failed. ap==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert ap == bp failed. ap==0xHEXDIGIT and bp==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert ap != cp failed. ap==0xHEXDIGIT and cp==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert ap &gt; cp failed. ap==0xHEXDIGIT and cp==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert bp &gt; cp failed. bp==0xHEXDIGIT and cp==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert bp &gt;= ap failed. bp==0xHEXDIGIT and ap==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert cp &lt; ap failed. cp==0xHEXDIGIT and ap==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert cp &lt; bp failed. cp==0xHEXDIGIT and bp==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_ptr, assert ap &lt;= bp failed. ap==0xHEXDIGIT and bp==0xHEXDIGIT!
-zutest.c:NNN: In test_assert_float, assert a == b failed. a==0.000400 and b==0.000300!
-zutest.c:NNN: In test_assert_float, assert a != c failed. a==0.000400 and c==0.000400!
-zutest.c:NNN: In test_assert_float, assert a &gt; c failed. a==0.000400 and c==0.000400!
-zutest.c:NNN: In test_assert_float, assert b &gt; c failed. b==0.000300 and c==0.000400!
-zutest.c:NNN: In test_assert_float, assert b &gt;= a failed. b==0.000300 and a==0.000400!
-zutest.c:NNN: In test_assert_float, assert c &lt; a failed. c==0.000400 and a==0.000400!
-zutest.c:NNN: In test_assert_float, assert c &lt; b failed. c==0.000400 and b==0.000300!
-zutest.c:NNN: In test_assert_float, assert a &lt;= b failed. a==0.000400 and b==0.000300!
-zutest.c:NNN: In test_assert_float, assert a == b failed. a==0.000400 and b==0.000300!
-zutest.c:NNN: In test_assert_float, assert a != c failed. a==0.000400 and c==0.000400!
-zutest.c:NNN: In test_assert_float, assert a &gt; c failed. a==0.000400 and c==0.000400!
-zutest.c:NNN: In test_assert_float, assert b &gt; c failed. b==0.000300 and c==0.000400!
-zutest.c:NNN: In test_assert_float, assert b &gt;= a failed. b==0.000300 and a==0.000400!
-zutest.c:NNN: In test_assert_float, assert c &lt; a failed. c==0.000400 and a==0.000400!
-zutest.c:NNN: In test_assert_float, assert c &lt; b failed. c==0.000400 and b==0.000300!
-zutest.c:NNN: In test_assert_float, assert a &lt;= b failed. a==0.000400 and b==0.000300!
-zutest.c:NNN: In test_assert_strings, assert a eq b failed. a is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
-zutest.c:NNN: In test_assert_strings, assert a ne c failed. a is &quot;Bogozity&quot; and c is &quot;Bogozity&quot;!
-zutest.c:NNN: In test_assert_strings, assert a gt c failed. a is &quot;Bogozity&quot; and c is &quot;Bogozity&quot;!
-zutest.c:NNN: In test_assert_strings, assert b gt c failed. b is &quot;Arclamp&quot; and c is &quot;Bogozity&quot;!
-zutest.c:NNN: In test_assert_strings, assert b ge a failed. b is &quot;Arclamp&quot; and a is &quot;Bogozity&quot;!
-zutest.c:NNN: In test_assert_strings, assert c lt a failed. c is &quot;Bogozity&quot; and a is &quot;Bogozity&quot;!
-zutest.c:NNN: In test_assert_strings, assert c lt b failed. c is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
-zutest.c:NNN: In test_assert_strings, assert a le b failed. a is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
-zutest.c:NNN: In test_assert_strings, assert a is empty failed. a is: Bogozity
-zutest.c:NNN: In test_assert_strings, assert n is empty failed. n is NULL!
-zutest.c:NNN: In test_assert_strings, assert e is nonempty failed. e[0] is 0!
-zutest.c:NNN: In test_assert_strings, assert n is nonempty failed. n is NULL!
+mutest.c:NNN: In test_assert_int, assert a == b failed. a==4 and b==3!
+mutest.c:NNN: In test_assert_int, assert a != c failed. a==4 and c==4!
+mutest.c:NNN: In test_assert_int, assert a &gt; c failed. a==4 and c==4!
+mutest.c:NNN: In test_assert_int, assert b &gt; c failed. b==3 and c==4!
+mutest.c:NNN: In test_assert_int, assert b &gt;= a failed. b==3 and a==4!
+mutest.c:NNN: In test_assert_int, assert c &lt; a failed. c==4 and a==4!
+mutest.c:NNN: In test_assert_int, assert c &lt; b failed. c==4 and b==3!
+mutest.c:NNN: In test_assert_int, assert a &lt;= b failed. a==4 and b==3!
+mutest.c:NNN: In test_assert_int, assert a == 0 failed. a==4!
+mutest.c:NNN: In test_assert_int, assert z != 0 failed. z==0!
+mutest.c:NNN: In test_assert_int, assert z &gt; 0 failed. z==0!
+mutest.c:NNN: In test_assert_int, assert n &gt; 0 failed. n==-1!
+mutest.c:NNN: In test_assert_int, assert a &lt;= 0 failed. a==4!
+mutest.c:NNN: In test_assert_int, assert z &lt; 0 failed. z==0!
+mutest.c:NNN: In test_assert_int, assert a &lt; 0 failed. a==4!
+mutest.c:NNN: In test_assert_int, assert n &gt;= 0 failed. n==-1!
+mutest.c:NNN: In test_assert_hex, assert a == b failed. a==0xHEXDIGIT and b==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert a != c failed. a==0xHEXDIGIT and c==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert a &gt; c failed. a==0xHEXDIGIT and c==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert b &gt; c failed. b==0xHEXDIGIT and c==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert b &gt;= a failed. b==0xHEXDIGIT and a==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert c &lt; a failed. c==0xHEXDIGIT and a==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert c &lt; b failed. c==0xHEXDIGIT and b==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert a &lt;= b failed. a==0xHEXDIGIT and b==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert a == 0 failed. a==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert z != 0 failed. z==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert z &gt; 0 failed. z==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert n &gt; 0 failed. n==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert a &lt;= 0 failed. a==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert z &lt; 0 failed. z==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert a &lt; 0 failed. a==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_hex, assert n &gt;= 0 failed. n==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert n != NULL failed. n==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert ap == NULL failed. ap==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert ap == bp failed. ap==0xHEXDIGIT and bp==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert ap != cp failed. ap==0xHEXDIGIT and cp==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert ap &gt; cp failed. ap==0xHEXDIGIT and cp==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert bp &gt; cp failed. bp==0xHEXDIGIT and cp==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert bp &gt;= ap failed. bp==0xHEXDIGIT and ap==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert cp &lt; ap failed. cp==0xHEXDIGIT and ap==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert cp &lt; bp failed. cp==0xHEXDIGIT and bp==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_ptr, assert ap &lt;= bp failed. ap==0xHEXDIGIT and bp==0xHEXDIGIT!
+mutest.c:NNN: In test_assert_float, assert a == b failed. a==0.000400 and b==0.000300!
+mutest.c:NNN: In test_assert_float, assert a != c failed. a==0.000400 and c==0.000400!
+mutest.c:NNN: In test_assert_float, assert a &gt; c failed. a==0.000400 and c==0.000400!
+mutest.c:NNN: In test_assert_float, assert b &gt; c failed. b==0.000300 and c==0.000400!
+mutest.c:NNN: In test_assert_float, assert b &gt;= a failed. b==0.000300 and a==0.000400!
+mutest.c:NNN: In test_assert_float, assert c &lt; a failed. c==0.000400 and a==0.000400!
+mutest.c:NNN: In test_assert_float, assert c &lt; b failed. c==0.000400 and b==0.000300!
+mutest.c:NNN: In test_assert_float, assert a &lt;= b failed. a==0.000400 and b==0.000300!
+mutest.c:NNN: In test_assert_float, assert a == b failed. a==0.000400 and b==0.000300!
+mutest.c:NNN: In test_assert_float, assert a != c failed. a==0.000400 and c==0.000400!
+mutest.c:NNN: In test_assert_float, assert a &gt; c failed. a==0.000400 and c==0.000400!
+mutest.c:NNN: In test_assert_float, assert b &gt; c failed. b==0.000300 and c==0.000400!
+mutest.c:NNN: In test_assert_float, assert b &gt;= a failed. b==0.000300 and a==0.000400!
+mutest.c:NNN: In test_assert_float, assert c &lt; a failed. c==0.000400 and a==0.000400!
+mutest.c:NNN: In test_assert_float, assert c &lt; b failed. c==0.000400 and b==0.000300!
+mutest.c:NNN: In test_assert_float, assert a &lt;= b failed. a==0.000400 and b==0.000300!
+mutest.c:NNN: In test_assert_strings, assert a eq b failed. a is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
+mutest.c:NNN: In test_assert_strings, assert a ne c failed. a is &quot;Bogozity&quot; and c is &quot;Bogozity&quot;!
+mutest.c:NNN: In test_assert_strings, assert a gt c failed. a is &quot;Bogozity&quot; and c is &quot;Bogozity&quot;!
+mutest.c:NNN: In test_assert_strings, assert b gt c failed. b is &quot;Arclamp&quot; and c is &quot;Bogozity&quot;!
+mutest.c:NNN: In test_assert_strings, assert b ge a failed. b is &quot;Arclamp&quot; and a is &quot;Bogozity&quot;!
+mutest.c:NNN: In test_assert_strings, assert c lt a failed. c is &quot;Bogozity&quot; and a is &quot;Bogozity&quot;!
+mutest.c:NNN: In test_assert_strings, assert c lt b failed. c is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
+mutest.c:NNN: In test_assert_strings, assert a le b failed. a is &quot;Bogozity&quot; and b is &quot;Arclamp&quot;!
+mutest.c:NNN: In test_assert_strings, assert a is empty failed. a is: Bogozity
+mutest.c:NNN: In test_assert_strings, assert n is empty failed. n is NULL!
+mutest.c:NNN: In test_assert_strings, assert e is nonempty failed. e[0] is 0!
+mutest.c:NNN: In test_assert_strings, assert n is nonempty failed. n is NULL!
 All OK.  14 tests run, 14 successes (252 assertions).

Modified: trunk/test/02-running/50-OpenFDsTest.test
===================================================================
--- trunk/test/02-running/50-OpenFDsTest.test	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/test/02-running/50-OpenFDsTest.test	2007-03-01 00:01:04 UTC (rev 136)
@@ -9,6 +9,8 @@
 #    open: 7
 #    open: 10
 
+DISABLED: Number of open fds keeps changing.
+
 $tmtest -o -q - &lt;&lt;-'EOL' | INDENT
 	for i in `seq 3 255`; do
 		exec 2&gt;/dev/null

Modified: trunk/units.c
===================================================================
--- trunk/units.c	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/units.c	2007-03-01 00:01:04 UTC (rev 136)
@@ -2,25 +2,9 @@
 #include &lt;stddef.h&gt;
 
 
-void run_all_unit_tests()
+void all_tests()
 {
-	zutest_tests();
+	mutest_tests();
 	compare_tests();
 	pathstack_tests();
 }
-
-
-#ifdef UNITS_MAIN
-int main(int argc, char **argv)
-{
-	if(argc &gt; 1) {
-		// &quot;zutest -f&quot; prints all the failures in the zutest unit tests.
-		// This allows you to check the output of each macro.
-		run_unit_tests_showing_failures(run_all_unit_tests);
-	} else {
-		run_unit_tests(run_all_unit_tests);
-	}
-	// this will never be reached
-	return 0;
-}
-#endif

Modified: trunk/units.h
===================================================================
--- trunk/units.h	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/units.h	2007-03-01 00:01:04 UTC (rev 136)
@@ -1,4 +1,4 @@
-#include &quot;zutest.h&quot;
+#include &quot;mutest/mutest.h&quot;
 
 void compare_tests();
 void pathstack_tests();

Deleted: trunk/zutest.c
===================================================================
--- trunk/zutest.c	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/zutest.c	2007-03-01 00:01:04 UTC (rev 136)
@@ -1,407 +0,0 @@
-/* zutest.c
- * Scott Bronson
- * 6 Mar 2006
- * 
- * This file is released under the MIT License.
- * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
- *
- * Version 0.7,  16 Feb 2007 -- turn dependency tree into functions
- * Version 0.6,  26 Apr 2006 -- first version worth releasing
- * Released under the MIT License.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;string.h&gt;
-#include &quot;zutest.h&quot;
-
-
-/** @file zutest.c
- *
- * This file contains all of the test mechanisms provided by the
- * Zutest unit testing framework.
- *
- * A single function is called a test.  If any of the asserts fail
- * within a test, the test itself is stopped and printed as a failure
- * but all other tests in the current test suite, and all other test
- * suites, will still be run.
- * 
- * You need to ensure that it's impossible for Assert macros to be
- * called without first ensuring that test_enter is called.
- * 
- * A single test is typically:
- *   
- *   Generally each step in a test must be processed in order
- * (later steps depend on earlier).  This is why tmtest bails
- * on the entire test when the first assert fails -- chances are
- * that the failure will prevent any further processing in this
- * test from producing meaningful results, and is probably not
- * unlikely to cause a full crash.  Therefore when an assert fails,
- * the current test is stopped and the next test is started.
- *
- * Q: Why not collect tests in data structures like other unit test
- * program do?
- * A: Zutest used to do this.  However, you can't call a data structure
- * with different parameters.  For instance, ensuring a suite of tests
- * works with any sized buffer:
- *     test_buffer(1024);
- *     test_buffer(13);
- *     test_buffer(0);
- * And you can't set a breakpoint on a data structure or step through
- * it in a debugger.  So, while it might be conceptually cleaner to
- * specify your tests purely declarative, in practice it's significantly
- * less convenient.
- *
- * TODO: move test setup into the tests themselves.
- * TODO: print test results, test suites, etc as they run.
- *    Add a quiet flag that will suppress printing unless a test fails.
- *    quiet=0, full printing
- *    quiet=1, test results not printed
- *    quiet=2, suite results not printed
- *    quiet=3, summary not printed.
- */
-
-
-int zutest_assertions = 0;		///&lt; A goofy statistic, updated by the assertion macros
-int zutest_tests_run = 0;		///&lt; The number of tests that we have run.  successes+failures==tests_run (if not, then there's a bug somewhere).
-int zutest_successes = 0;		///&lt; The number of successful tests run
-int zutest_failures = 0;		///&lt; The number of failed tests run.
-jmp_buf zutest_test_bail;		///&lt; If an assertion fails, and we're not inverted, this is where we end up.
-static jmp_buf *inversion;		///&lt; If an assertion fails, and we're inverted, this is where we end up.  This is NULL except when running Zutest's internal unit tests.  See test_fail().
-static int show_failures = 0; 	///&lt; Set this to 1 to print the failures.  This allows you to view the output of each failure to ensure it looks OK.
-
-
-void zutest_fail(const char *file, int line, const char *func, 
-		const char *msg, ...)
-{
-	va_list ap;
-	if(!inversion || show_failures) {
-		fprintf(stderr, &quot;%s:%d: In %s, assert &quot;, file, line, func);
-		va_start(ap, msg);
-		vfprintf(stderr, msg, ap);
-		va_end(ap);
-		fputc('\n', stderr);
-	}
-
-	// If inversion is set, then an assert correctly failed.
-	if(inversion) {
-		longjmp(*inversion, 1);
-	}
-
-	longjmp(zutest_test_bail, 1);
-}
-
-
-void print_zutest_results()
-{
-	if(zutest_failures == 0) {
-		printf(&quot;All OK.  %d test%s run, %d successe%s (%d assertion%s).\n&quot;,
-				zutest_successes, (zutest_successes == 1 ? &quot;&quot; : &quot;s&quot;),
-				zutest_successes, (zutest_successes == 1 ? &quot;&quot; : &quot;s&quot;),
-				zutest_assertions, (zutest_assertions == 1 ? &quot;&quot; : &quot;s&quot;));
-		return;
-	}
-
-	printf(&quot;ERROR: %d failure%s in %d test%s run!\n&quot;,
-			zutest_failures, (zutest_failures == 1 ? &quot;&quot; : &quot;s&quot;), 
-			zutest_tests_run, (zutest_tests_run == 1 ? &quot;&quot; : &quot;s&quot;));
-}
-
-
-/** Runs all the unit tests in all the passed-in test suites.
- */
-
-void run_unit_tests(zutest_proc proc)
-{
-	(*proc)();
-	print_zutest_results();
-	exit(zutest_failures &lt; 100 ? zutest_failures : 100);
-}
-
-
-void run_unit_tests_showing_failures(zutest_proc proc)
-{
-	show_failures = 1;
-	run_unit_tests(proc);
-}
-
-
-/**
- * Examines the command-line arguments.  If &quot;--run-unit-tests&quot; is
- * the first argument, then it runs the unit tests (further arguments
- * may affect how the tests are processed).  This routine exits with
- * a nonzero result code if any test fails; otherwise it exits with 0.
- * It never returns.
- *
- * If --run-unit-tests is not on the command line, this routine returns
- * without doing anything.
- */
-
-void unit_test_check(int argc, char **argv, zutest_proc proc)
-{
-	if(argc &gt; 1 &amp;&amp; strcmp(argv[1],&quot;--run-unit-tests&quot;) == 0) {
-		run_unit_tests(proc);
-	}
-}
-
-
-
-/* This code runs the zutest unit tests to ensure that zutest itself
- * is working properly.
- */
-
-
-/** This macro is used to reverse the sense of the tests. 
- *
- * To properly test Zutest, we need to ensure that the Assert macros
- * handle failures too.  Therefore, we occasionally want to reverse
- * the sense of the macro, where a failure indicates a successful test
- * and a passing assert means that the test has failed.
- *
- * This macro inverts the sense of the contained assertion.
- * test_failure(AssertEq(a,b)) causes the test to pass
- * only when the assertion fails (i.e. when a != b).
- */
-
-#define test_failure(test) 				\
-	do { 								\
-		jmp_buf jb; 					\
-		int val = setjmp(jb); 			\
-		if(val == 0) { 					\
-			inversion = &jb;			\
-			do { test; } while(0);		\
-			inversion = NULL;			\
-			Fail(&quot;This test should have failed: &quot; #test);	\
-		}								\
-		inversion = NULL;				\
-	} while(0)
-
-
-
-void test_assert_int()
-{
-	int a=4, b=3, c=4, z=0, n=-1;
-
-	AssertEq(a,c);
-	AssertNe(a,b);
-	AssertGt(a,b);
-	AssertGe(a,b);
-	AssertGe(a,c);
-	AssertLt(b,a);
-	AssertLe(b,a);
-	AssertLe(c,a);
-
-	test_failure( AssertEq(a,b) );
-	test_failure( AssertNe(a,c) );
-	test_failure( AssertGt(a,c) );
-	test_failure( AssertGt(b,c) );
-	test_failure( AssertGe(b,a) );
-	test_failure( AssertLt(c,a) );
-	test_failure( AssertLt(c,b) );
-	test_failure( AssertLe(a,b) );
-
-	AssertZero(z);
-	test_failure( AssertZero(a) );
-	AssertNonzero(a);
-	test_failure( AssertNonzero(z) );
-
-	AssertPositive(a);
-	test_failure( AssertPositive(z) );
-	test_failure( AssertPositive(n) );
-
-	AssertNonPositive(n);
-	AssertNonPositive(z);
-	test_failure( AssertNonPositive(a) );
-
-	AssertNegative(n);
-	test_failure( AssertNegative(z) );
-	test_failure( AssertNegative(a) );
-
-	AssertNonNegative(a);
-	AssertNonNegative(z);
-	test_failure( AssertNonNegative(n) );
-}
-
-
-void test_assert_hex()
-{
-	int a=4, b=3, c=4, z=0, n=-1;
-
-	AssertEqHex(a,c);
-	AssertNeHex(a,b);
-	AssertGtHex(a,b);
-	AssertGeHex(a,b);
-	AssertGeHex(a,c);
-	AssertLtHex(b,a);
-	AssertLeHex(b,a);
-	AssertLeHex(c,a);
-
-	test_failure( AssertEqHex(a,b) );
-	test_failure( AssertNeHex(a,c) );
-	test_failure( AssertGtHex(a,c) );
-	test_failure( AssertGtHex(b,c) );
-	test_failure( AssertGeHex(b,a) );
-	test_failure( AssertLtHex(c,a) );
-	test_failure( AssertLtHex(c,b) );
-	test_failure( AssertLeHex(a,b) );
-
-	AssertZeroHex(z);
-	test_failure( AssertZeroHex(a) );
-	AssertNonzeroHex(a);
-	test_failure( AssertNonzeroHex(z) );
-
-	AssertPositiveHex(a);
-	test_failure( AssertPositiveHex(z) );
-	test_failure( AssertPositiveHex(n) );
-
-	AssertNonPositiveHex(n);
-	AssertNonPositiveHex(z);
-	test_failure( AssertNonPositiveHex(a) );
-
-	AssertNegativeHex(n);
-	test_failure( AssertNegativeHex(z) );
-	test_failure( AssertNegativeHex(a) );
-
-	AssertNonNegativeHex(a);
-	AssertNonNegativeHex(z);
-	test_failure( AssertNonNegativeHex(n) );
-}
-
-
-void test_assert_ptr()
-{
-	int a, b;
-	int *ap = &a;
-	int *bp = &b;
-	int *cp = &a;
-	int *n = NULL;
-
-	AssertPtr(ap);
-	AssertNull(n);
-
-	test_failure( AssertPtr(n) );
-	test_failure( AssertNull(ap) );
-
-	AssertPtrEq(ap,cp);
-	AssertPtrNe(ap,bp);
-	AssertPtrGt(ap,bp);
-	AssertPtrGe(ap,bp);
-	AssertPtrGe(ap,cp);
-	AssertPtrLt(bp,ap);
-	AssertPtrLe(bp,ap);
-	AssertPtrLe(cp,ap);
-
-	test_failure( AssertPtrEq(ap,bp) );
-	test_failure( AssertPtrNe(ap,cp) );
-	test_failure( AssertPtrGt(ap,cp) );
-	test_failure( AssertPtrGt(bp,cp) );
-	test_failure( AssertPtrGe(bp,ap) );
-	test_failure( AssertPtrLt(cp,ap) );
-	test_failure( AssertPtrLt(cp,bp) );
-	test_failure( AssertPtrLe(ap,bp) );
-}
-
-
-void test_assert_float()
-{
-	float a=0.0004, b=0.0003, c=0.0004;
-
-	AssertFloatEq(a,c);
-	AssertFloatNe(a,b);
-	AssertFloatGt(a,b);
-	AssertFloatGe(a,b);
-	AssertFloatGe(a,c);
-	AssertFloatLt(b,a);
-	AssertFloatLe(b,a);
-	AssertFloatLe(c,a);
-
-	test_failure( AssertFloatEq(a,b) );
-	test_failure( AssertFloatNe(a,c) );
-	test_failure( AssertFloatGt(a,c) );
-	test_failure( AssertFloatGt(b,c) );
-	test_failure( AssertFloatGe(b,a) );
-	test_failure( AssertFloatLt(c,a) );
-	test_failure( AssertFloatLt(c,b) );
-	test_failure( AssertFloatLe(a,b) );
-
-	AssertDoubleEq(a,c);
-	AssertDoubleNe(a,b);
-	AssertDoubleGt(a,b);
-	AssertDoubleGe(a,b);
-	AssertDoubleGe(a,c);
-	AssertDoubleLt(b,a);
-	AssertDoubleLe(b,a);
-	AssertDoubleLe(c,a);
-
-	test_failure( AssertDoubleEq(a,b) );
-	test_failure( AssertDoubleNe(a,c) );
-	test_failure( AssertDoubleGt(a,c) );
-	test_failure( AssertDoubleGt(b,c) );
-	test_failure( AssertDoubleGe(b,a) );
-	test_failure( AssertDoubleLt(c,a) );
-	test_failure( AssertDoubleLt(c,b) );
-	test_failure( AssertDoubleLe(a,b) );
-}
-
-
-void test_assert_strings()
-{
-	const char *a = &quot;Bogozity&quot;;
-	const char *b = &quot;Arclamp&quot;;
-	const char *c = &quot;Bogozity&quot;;
-	const char *e = &quot;&quot;;
-	const char *n = NULL;
-
-	AssertStrEq(a,c);
-	AssertStrNe(a,b);
-	AssertStrGt(a,b);
-	AssertStrGe(a,b);
-	AssertStrGe(a,c);
-	AssertStrLt(b,a);
-	AssertStrLe(b,a);
-	AssertStrLe(c,a);
-
-	test_failure( AssertStrEq(a,b) );
-	test_failure( AssertStrNe(a,c) );
-	test_failure( AssertStrGt(a,c) );
-	test_failure( AssertStrGt(b,c) );
-	test_failure( AssertStrGe(b,a) );
-	test_failure( AssertStrLt(c,a) );
-	test_failure( AssertStrLt(c,b) );
-	test_failure( AssertStrLe(a,b) );
-
-	AssertStrEmpty(e);
-	test_failure( AssertStrEmpty(a) );
-	test_failure( AssertStrEmpty(n) );
-
-	AssertStrNonEmpty(a);
-	test_failure( AssertStrNonEmpty(e) );
-	test_failure( AssertStrNonEmpty(n) );
-}
-
-
-void zutest_tests()
-{
-	zutest( test_assert_int() );
-	zutest( test_assert_hex() );
-	zutest( test_assert_ptr() );
-	zutest( test_assert_float() );
-	zutest( test_assert_strings() );
-};
-
-
-#ifdef ZUTEST_MAIN
-int main(int argc, char **argv)
-{
-	if(argc &gt; 1) {
-		// &quot;zutest -f&quot; prints all the failures in the zutest unit tests.
-		// This allows you to check the output of each macro.
-		run_unit_tests_showing_failures(zutest_tests);
-	} else {
-		run_unit_tests(zutest_tests);
-	}
-	// this will never be reached
-	return 0;
-}
-#endif

Deleted: trunk/zutest.h
===================================================================
--- trunk/zutest.h	2007-02-27 19:24:34 UTC (rev 135)
+++ trunk/zutest.h	2007-03-01 00:01:04 UTC (rev 136)
@@ -1,280 +0,0 @@
-/* zutest.h
- * Scott Bronson
- * 6 Mar 2006
- *
- * TODO: make tests self-documenting.  The test name is the same as the
- * function name, but they should also have a short and long description.
- * TODO: make zutest suites able to be arranged in a hierarchy.
- * 
- * This file is released under the MIT License.
- * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
- * 
- * Version 0.7,  16 Feb 2007 -- turn dependency tree into functions
- * Version 0.62, 22 Jan 2007 -- clean up failure messages
- * Version 0.61, 30 Apr 2006 -- first version worth releasing
- */
-
-
-/* @file zutest.h
- *
- * This file contains the declarations and all the Assert macros
- * required to use Zutest in your own applications.
- *
- * Zutest is a ground-up rewrite of Asim Jalis's &quot;CuTest&quot; library.
- *
- * To compile Zutest to run its own unit tests, do this:
- * 
- * &lt;pre&gt;
- * 	$ cc -DZUTEST_MAIN zutest.c -o zutest
- * 	$ ./zutest
- * 	4 tests run, 4 successes (132 assertions).
- * &lt;/pre&gt;
- *
- * If your non-gcc compiler complains about a missing __func__ macro,
- * add -D__func__='&quot;test&quot;' to the compiler's command line.
- *
- * See ::zutest_tests for instructions on how to add zutest's
- * built-in unit tests to your application's test suite.
- */
-
-
-#ifndef ZUTEST_H
-#define ZUTEST_H
-
-// This include is unfortunate...  TODO: try to get this out of here.
-#include &lt;setjmp.h&gt;
-
-
-//#define ZUTBECAUSE &quot; failed because &quot;
-#define ZUTBECAUSE &quot; failed. &quot;
-
-// Note that Fail doesn't increment zutest_assertions (the number of assertions
-// that have been made) because it doesn't assert anything.  It only fails.
-// If you call fail, you might want to increment zutest_assertions
-// manually if you care about this number.  Normally you won't care.
-#define Fail(...) zutest_fail(__FILE__, __LINE__, __func__, __VA_ARGS__)
-
-// If the expression returns false, it is printed in the failure message.
-#define Assert(x) do { zutest_assertions++; \
-		if(!(x)) { Fail(#x); } } while(0)
-
-// If the expression returns false, the given format string is printed.
-// This is the same as Assert, just with much more helpful error messages.
-// For instance: AssertFmt(isdigit(x), &quot;isdigit but x=='%c'&quot;, x);
-#define AssertFmt(x,...) do { zutest_assertions++; \
-		if(!(x)) { Fail(__VA_ARGS__); } } while(0)
-
-// integers, longs, chars...
-#define AssertEq(x,y) AssertOp(x,==,y)
-#define AssertNe(x,y) AssertOp(x,!=,y)
-#define AssertGt(x,y) AssertOp(x,&gt;,y)
-#define AssertGe(x,y) AssertOp(x,&gt;=,y)
-#define AssertLt(x,y) AssertOp(x,&lt;,y)
-#define AssertLe(x,y) AssertOp(x,&lt;=,y)
-
-#define AssertZero(x) AssertOpToZero(x,==)
-#define AssertNonzero(x) AssertOpToZero(x,!=)
-#define AssertNonZero(x) AssertNonzero(x)
-#define AssertPositive(x) AssertOpToZero(x,&gt;);
-#define AssertNegative(x) AssertOpToZero(x,&lt;);
-#define AssertNonNegative(x) AssertOpToZero(x,&gt;=);
-#define AssertNonPositive(x) AssertOpToZero(x,&lt;=);
-
-// Also integers but failure values are printed in hex rather than decimal.
-#define AssertEqHex(x,y) AssertHexOp(x,==,y)
-#define AssertNeHex(x,y) AssertHexOp(x,!=,y)
-#define AssertGtHex(x,y) AssertHexOp(x,&gt;,y)
-#define AssertGeHex(x,y) AssertHexOp(x,&gt;=,y)
-#define AssertLtHex(x,y) AssertHexOp(x,&lt;,y)
-#define AssertLeHex(x,y) AssertHexOp(x,&lt;=,y)
-
-#define AssertZeroHex(x) AssertHexOpToZero(x,==)
-#define AssertNonzeroHex(x) AssertHexOpToZero(x,!=)
-#define AssertNonZeroHex(x) AssertNonzeroHex(x)
-#define AssertPositiveHex(x) AssertHexOpToZero(x,&gt;);
-#define AssertNegativeHex(x) AssertHexOpToZero(x,&lt;);
-#define AssertNonNegativeHex(x) AssertHexOpToZero(x,&gt;=);
-#define AssertNonPositiveHex(x) AssertHexOpToZero(x,&lt;=);
-
-// Pointers...
-#define AssertPtr(p)  AssertFmt(p != NULL, \
-		#p&quot; != NULL&quot; ZUTBECAUSE #p&quot;==0x%lX!&quot;, (unsigned long)p)
-#define AssertNull(p) AssertFmt(p == NULL, \
-		#p&quot; == NULL&quot; ZUTBECAUSE #p&quot;==0x%lX!&quot;, (unsigned long)p)
-#define AssertNonNull(p) AssertPtr(p)
-
-#define AssertPtrNull(p) AssertNull(p)
-#define AssertPtrNonNull(p) AssertNonNull(p)
-#define AssertPtrEq(x,y) AssertPtrOp(x,==,y)
-#define AssertPtrNe(x,y) AssertPtrOp(x,!=,y)
-#define AssertPtrGt(x,y) AssertPtrOp(x,&gt;,y)
-#define AssertPtrGe(x,y) AssertPtrOp(x,&gt;=,y)
-#define AssertPtrLt(x,y) AssertPtrOp(x,&lt;,y)
-#define AssertPtrLe(x,y) AssertPtrOp(x,&lt;=,y)
-
-// These work with floats and doubles
-// (everything is handled internally as double)
-#define AssertFloatEq(x,y) AssertFloatOp(x,==,y)
-#define AssertFloatNe(x,y) AssertFloatOp(x,!=,y)
-#define AssertFloatGt(x,y) AssertFloatOp(x,&gt;,y)
-#define AssertFloatGe(x,y) AssertFloatOp(x,&gt;=,y)
-#define AssertFloatLt(x,y) AssertFloatOp(x,&lt;,y)
-#define AssertFloatLe(x,y) AssertFloatOp(x,&lt;=,y)
-// supply Doubles so people don't worry about precision when they see Float
-#define AssertDoubleEq(x,y) AssertFloatOp(x,==,y)
-#define AssertDoubleNe(x,y) AssertFloatOp(x,!=,y)
-#define AssertDoubleGt(x,y) AssertFloatOp(x,&gt;,y)
-#define AssertDoubleGe(x,y) AssertFloatOp(x,&gt;=,y)
-#define AssertDoubleLt(x,y) AssertFloatOp(x,&lt;,y)
-#define AssertDoubleLe(x,y) AssertFloatOp(x,&lt;=,y)
-
-// Strings (uses strcmp)...
-#define AssertStrEq(x,y) AssertStrOp(x,eq,==,y)
-#define AssertStrNe(x,y) AssertStrOp(x,ne,!=,y)
-#define AssertStrGt(x,y) AssertStrOp(x,gt,&gt;,y)
-#define AssertStrGe(x,y) AssertStrOp(x,ge,&gt;=,y)
-#define AssertStrLt(x,y) AssertStrOp(x,lt,&lt;,y)
-#define AssertStrLe(x,y) AssertStrOp(x,le,&lt;=,y)
-
-// ensures a string is non-null but zero-length
-#define AssertStrEmpty(p) do { zutest_assertions++; \
-		if(!(p)) { Fail(#p&quot; is empty&quot; ZUTBECAUSE #p &quot; is NULL!&quot;); } \
-		if((p)[0]) { Fail(#p&quot; is empty&quot; ZUTBECAUSE #p &quot; is: %s&quot;,p); } \
-	} while(0)
-// ensures a string is non-null and non-zero-length
-#define AssertStrNonEmpty(p) do { zutest_assertions++; \
-		if(!(p)) { Fail(#p&quot; is nonempty&quot; ZUTBECAUSE #p &quot; is NULL!&quot;); } \
-		if(!(p)[0]) { Fail(#p&quot; is nonempty&quot; ZUTBECAUSE #p&quot;[0] is 0!&quot;); } \
-	} while(0)
-
-// I think that &quot;Equal&quot; looks better than &quot;Eq&quot;.
-// This is probably proof that these macros need to be totally overhauled...
-#define AssertEqual(x,y) AssertEq(x,y)
-#define AssertEqualHex(x,y) AssertHexEq(x,y)
-#define AssertPtrEqual(x,y) AssertPtrEq(x,y)
-#define AssertFloatEqual(x,y) AssertFloatEq(x,y)
-#define AssertDoubleEqual(x,y) AssertFloatEq(x,y)
-#define AssertStrEqual(x,y) AssertStrEq(x,y)
-
-//
-// helper macros, not intended to be called directly.
-//
-
-#define AssertExpType(x,op,y,type,fmt) \
-	AssertFmt((type)x op (type)y, #x&quot; &quot;#op&quot; &quot;#y ZUTBECAUSE \
-	#x&quot;==&quot;fmt&quot; and &quot;#y&quot;==&quot;fmt&quot;!&quot;, (type)x,(type)y)
-// The failure &quot;x==0 failed because x==1 and 0==0&quot; s too wordy so we'll
-// special-case checking against 0: x==0 failed because x==1).
-#define AssertExpToZero(x,op,type,fmt) \
-	AssertFmt((type)x op 0,#x&quot; &quot;#op&quot; 0&quot; ZUTBECAUSE #x&quot;==&quot;fmt&quot;!&quot;, (type)x)
-
-#define AssertOp(x,op,y) AssertExpType(x,op,y,long,&quot;%ld&quot;)
-#define AssertHexOp(x,op,y) AssertExpType(x,op,y,long,&quot;0x%lX&quot;)
-#define AssertOpToZero(x,op) AssertExpToZero(x,op,long,&quot;%ld&quot;)
-#define AssertHexOpToZero(x,op) AssertExpToZero(x,op,long,&quot;0x%lX&quot;)
-#define AssertPtrOp(x,op,y) AssertExpType(x,op,y,unsigned long,&quot;0x%lX&quot;)
-#define AssertFloatOp(x,op,y) AssertExpType(x,op,y,double,&quot;%lf&quot;)
-#define AssertStrOp(x,opn,op,y) AssertFmt(strcmp(x,y) op 0, \
-	#x&quot; &quot;#opn&quot; &quot;#y ZUTBECAUSE #x&quot; is \&quot;%s\&quot; and &quot;#y&quot; is \&quot;%s\&quot;!&quot;,x,y)
-
-
-
-
-/** Fails the current test.
- *
- * This function may only be called from within a ::zutest_proc.
- *
- * If none of the built-in Assert macros fit your fancy, you can do the
- * check on your own and call zutest_fail in the event that it fails.
- * 
- * Example:
- * 
- * &lt;pre&gt;
- * if(my_error) {
- *    zutest_fail(__FILE__, __LINE__, __func__, &quot;Error Message %d&quot;, 1);
- * }
- * &lt;/pre&gt;
- *
- * But, really, it's easier just to call the Fail() macro.
- */
-
-void zutest_fail(const char *file, int line, const char *func,
-		const char *msg, ...);
-		
-		
-#define zutest(test) do { zutest_tests_run += 1; 	\
-		if(!setjmp(zutest_test_bail)) { 			\
-			do { test; } while(0); 					\
-			zutest_successes += 1; 					\
-		} else { 									\
-			zutest_failures += 1; 					\
-		} } while(0)
-		
-
-/* above this line is stuff only needed within the tests */
-/* ------------------ */
-/* below this line is stuff only needed to run the tests */
-
-
-
-
-/** Keeps track of how many assertions have been made.
- * This needs to be updated manually each time an assertion
- * is made.  The Zutest built-in assertion macros all
- * update this variable properly.
- */
-
-extern int zutest_assertions;
-extern int zutest_tests_run;
-extern int zutest_successes;
-extern int zutest_failures;
-extern jmp_buf zutest_test_bail;
-
-typedef void (*zutest_proc)();
-
-/** Runs all the tests in a suite. */
-void run_zutest_suite(zutest_proc proc);
-/** Runs all the tests in all the suites passed in. */
-void run_zutest_suites(zutest_proc proc);
-
-void print_zutest_results();
-
-
-/** 
- *
- * Call this on the very first line of your application.  If the user
- * ran your program with the first arg of &quot;--run-unit-tests&quot;, this will
- * run the tests and exit.  Otherwise your program will run as normal.
- * If you would rather create a dedicated executable, just call
- * run_zutest_suites() directly.
- */
-
-void unit_test_check(int argc, char **argv, zutest_proc proc);
-
-/**
- *
- * This runs all the unit tests supplied and then exits.  Use this
- * if you want to handle the arguments yourself.
- */
-
-void run_unit_tests(zutest_proc proc);
-void run_unit_tests_showing_failures(zutest_proc proc);
-
-
-/** Zutest's built-in test suite.
- *
- * This allows you to add the Zutest unit test suite to your application's
- * test suites.  This way, you can ensure that Zutest's unit tests pass
- * before running your application's.  This is for the especially pedantic. :)
- *
- * Unfortunately, there is one test that cannot be run if you do this:
- * ensuring that zutest properly handles empty test suites.
- * Other than this one test, adding zutest_tests
- * to your application's test suite is equivalent to causing zutest to
- * compile and run its unit tests as described in zutest.h.
- */
-
-void zutest_tests();
-
-
-#endif




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000054.html">[Tmtest-commits] [137] trunk/: Need to use a publicly-accessible	repo for the mutest
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#53">[ date ]</a>
              <a href="thread.html#53">[ thread ]</a>
              <a href="subject.html#53">[ subject ]</a>
              <a href="author.html#53">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tmtest-commits">More information about the Tmtest-commits
mailing list</a><br>
</body></html>
