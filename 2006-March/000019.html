<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tmtest-commits] [102] releases: Release 0.94
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tmtest-commits/2006-March/index.html" >
   <LINK REL="made" HREF="mailto:tmtest-commits%40lists.berlios.de?Subject=Re%3A%20%5BTmtest-commits%5D%20%5B102%5D%20releases%3A%20Release%200.94&In-Reply-To=%3C200603030013.k230DRhq021580%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000018.html">
   <LINK REL="Next"  HREF="000020.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tmtest-commits] [102] releases: Release 0.94</H1>
    <B>tmtest-commits at berlios.de</B> 
    <A HREF="mailto:tmtest-commits%40lists.berlios.de?Subject=Re%3A%20%5BTmtest-commits%5D%20%5B102%5D%20releases%3A%20Release%200.94&In-Reply-To=%3C200603030013.k230DRhq021580%40sheep.berlios.de%3E"
       TITLE="[Tmtest-commits] [102] releases: Release 0.94">tmtest-commits at berlios.de
       </A><BR>
    <I>Fri Mar  3 01:13:27 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000018.html">[Tmtest-commits] [101] releases/0.92: Minor update to 0.92 to make it distributable and
</A></li>
        <LI>Next message: <A HREF="000020.html">[Tmtest-commits] [103] trunk: Tmtest would get confused by .
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19">[ date ]</a>
              <a href="thread.html#19">[ thread ]</a>
              <a href="subject.html#19">[ subject ]</a>
              <a href="author.html#19">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Revision: 102
Author:   bronson
Date:     2006-03-03 01:12:52 +0100 (Fri, 03 Mar 2006)

Log Message:
-----------
Release 0.94

Added Paths:
-----------
    releases/0.94/
    releases/0.94/BUGS
    releases/0.94/CHANGES
    releases/0.94/Makefile
    releases/0.94/TODO
    releases/0.94/compare.c
    releases/0.94/compare.h
    releases/0.94/curdir.c
    releases/0.94/examples/docs/Modify3.test
    releases/0.94/examples/docs/testfile/
    releases/0.94/examples/tutorial/20-ArgSuppressNL.test
    releases/0.94/main.c
    releases/0.94/make-dist
    releases/0.94/re2c/read.c
    releases/0.94/re2c/scan.h
    releases/0.94/stscan.c
    releases/0.94/template.sh
    releases/0.94/test/00-cmdline/10-CfgDir.test
    releases/0.94/test/00-cmdline/11-CfgMissing.test
    releases/0.94/test/00-cmdline/12-CfgEmpty.test
    releases/0.94/test/01-testfile/02-StdOutNK.test
    releases/0.94/test/01-testfile/03-StdErrNK.test
    releases/0.94/test/01-testfile/08-GarbageInStdout.test
    releases/0.94/test/01-testfile/10-DumpScript.test
    releases/0.94/test/01-testfile/11-InnerConfig.test
    releases/0.94/test/01-testfile/20-TestVars.test
    releases/0.94/test/01-testfile/21-TestVarsABS.test
    releases/0.94/test/01-testfile/22-TestVarsRel.test
    releases/0.94/test/02-running/21-QuoteFile.test
    releases/0.94/test/02-running/22-Signal.test
    releases/0.94/test/02-running/40-Replace.test
    releases/0.94/test/02-running/41-Indent.test
    releases/0.94/test/03-results/01-YstderrOut.test
    releases/0.94/test/03-results/01-YstdoutOut.test
    releases/0.94/test/03-results/14-NoNLWarn.test
    releases/0.94/test/03-results/15-EmptyWithErr.test
    releases/0.94/test/03-results/15-EmptyWithOut.test
    releases/0.94/test/03-results/16-EmptyWithErrNoNL.test
    releases/0.94/test/03-results/16-EmptyWithOutNoNL.test
    releases/0.94/test/03-results/17-NoStderr.test
    releases/0.94/test/03-results/18-NoNLWarnOut.test
    releases/0.94/test/03-results/30-Binary.test
    releases/0.94/test/03-results/31-BinaryFail.test
    releases/0.94/test/03-results/32-BinaryLarge.test
    releases/0.94/test/03-results/33-BinaryHuge.test
    releases/0.94/test/04-diff/01-Diff.test
    releases/0.94/test/04-diff/02-MultiDiff.test
    releases/0.94/test/04-diff/05-AbortDiff.test
    releases/0.94/test/04-diff/09-MultiLevelDiff.test
    releases/0.94/test/04-diff/10-Patch.test
    releases/0.94/test/04-diff/11-MultiPatch.test
    releases/0.94/test/04-diff/12-MultiLevelPatch.test
    releases/0.94/test/04-diff/13-MultiLevelPatch.test
    releases/0.94/test/04-diff/18-NeedNLWarn.test
    releases/0.94/test/04-diff/20-DiffNoNL.test
    releases/0.94/test/04-diff/21-PatchNoNL.test
    releases/0.94/test/04-diff/22-PatchNoNL2.test
    releases/0.94/test/04-diff/23-PatchNoNL3.test
    releases/0.94/test/04-diff/tmtest.conf
    releases/0.94/test/README
    releases/0.94/test/tmtest.sub.conf
    releases/0.94/test.c
    releases/0.94/test.h
    releases/0.94/tfscan.c
    releases/0.94/tmlib.sh
    releases/0.94/tmtest.conf
    releases/0.94/tmtest.pod
    releases/0.94/vars.c
    releases/0.94/vars.h
    releases/tmtest-0.92.tar.gz
    releases/tmtest-0.94.tar.gz

Removed Paths:
-------------
    releases/0.94/BUGS
    releases/0.94/CHANGES
    releases/0.94/Makefile
    releases/0.94/TODO
    releases/0.94/compare.c
    releases/0.94/compare.h
    releases/0.94/curdir.c
    releases/0.94/examples/docs/Modify3.test
    releases/0.94/examples/tutorial/20-ArgSuppressNL.test
    releases/0.94/main.c
    releases/0.94/re2c/read.c
    releases/0.94/re2c/scan.h
    releases/0.94/stscan.c
    releases/0.94/template.sh
    releases/0.94/test/01-testfile/08-GarbageInStdout.test
    releases/0.94/test/01-testfile/10-DumpScript.test
    releases/0.94/test/02-running/21-QuoteFile.test
    releases/0.94/test/04-diff/01-Diff.test
    releases/0.94/test/04-diff/02-MultiDiff.test
    releases/0.94/test/04-diff/05-AbortDiff.test
    releases/0.94/test/04-diff/09-MultiLevelDiff.test
    releases/0.94/test/04-diff/10-Patch.test
    releases/0.94/test/04-diff/11-MultiPatch.test
    releases/0.94/test/04-diff/12-MultiLevelPatch.test
    releases/0.94/test/04-diff/13-MultiLevelPatch.test
    releases/0.94/test/04-diff/indent.sh
    releases/0.94/test/README
    releases/0.94/test/tmtest.sub.conf
    releases/0.94/test.c
    releases/0.94/test.h
    releases/0.94/tfscan.c
    releases/0.94/tmlib.sh
    releases/0.94/tmtest.conf
    releases/0.94/tmtest.pod
    releases/0.94/vars.c
    releases/0.94/vars.h
Copied: releases/0.94 (from rev 88, trunk)

Deleted: releases/0.94/BUGS
===================================================================
--- trunk/BUGS	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/BUGS	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,43 +0,0 @@
-If you run tmtest -d on a disabled test, it produces a tiny diff with the
-word &quot;Disabled&quot; in its stderr.  If you blindly pipe this diff to patch,
-it will destroy the output section of your test file.  This is easy enough
-to fix -- just re-enable the test and patch it again.  This will be
-fixed in tmtest 1.2 when we parse the status file asynchronously.  We
-will notice that the test is disabled and refuse to produce the diff.
-
-
-Bash Gotchas:
-
-
-Bash3 has removed the ability to set LINENO, so you may see the
-wrong line number be printed if there's an error.  If you want to
-see the correct line numbers, use Bash2.  It's an unfortunate
-regression but since it only affects tests scripts being piped
-on stdin it won't affect many people.
-
-
-The &lt;&lt;-EOL operator strips ALL tabs from the front of each line.
-This is bad because it means you can't nest heredocs:
-
-	cmd1 &lt;&lt;-EOL
-		cmd2 &lt;&lt;-EOL
-			cmd3
-		EOL
-	EOL
-
-The first heredoc flattens everything and then the EOLs get mixed up.
-What bash *SHOULD* do (and what tmtest did before it was integrated
-with Bash) is discover the whitespace sequence indenting the
-first line of a heredoc, then remove exactly that sequence from all
-subsequent lines.  If a line doesn't begin with that sequence, then
-it is unchanged.  This is safer and more useful than just blowing away
-all tabs wholesale!
-
-
-Bashisms:
-
-Why does &amp;&gt; redirect both stdout and stderr to a file, but &amp;| doesn't
-redirect both stdout and stderr to a pipe?
-
-Why is the unset command totally unrelated to the set command?
-

Copied: releases/0.94/BUGS (from rev 99, trunk/BUGS)

Deleted: releases/0.94/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/CHANGES	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,19 +0,0 @@
-- write some tests to ensure diff works with files that don't end in CR.
-- move INDENT from 04-diff into the stdlib.  Add to docs.
-----
-- Bash3 has made it so that the RE can no longer appear on the same line as
-  the MODIFY command.  I updated all tests and accelerated MODIFY deprecation.
-- Added -n (--no-trailing-newline) capability to STDOUT and STDERR sections.
-- Rewrote the re2c parser in C so we should now be totally binary transparent.
-- Got rid of all AUTHOR and DATE automation.  Too heavyhanded.
-- Standardized licensing: everything under my control is MIT, package is LGPL.
-- When installing locally, it's ~/.tmlib.sh instead of ~/share/tmtest/tmlib.sh
-- Bump to 0.92
-- install now installs config files too.
-- Added the --config option to override default config files.
-- Added timing information to test summary.  Disable with new -q option.
-- Created tmlib, a &quot;standard library&quot; for tests.
-- We now stop running all tests if any test aborts.  DISABLE stops the current
-  test but lets all other tests finish; ABORT stops testing altogether.
-- Tests now start with /tmp as the cwd, not the testdir.
-  The testdir is supplied in $TESTDIR (or $MYDIR inside the testfile)

Copied: releases/0.94/CHANGES (from rev 100, trunk/CHANGES)

Deleted: releases/0.94/Makefile
===================================================================
--- trunk/Makefile	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/Makefile	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,114 +0,0 @@
-# tmtest Makefile
-# Scott Bronson
-# 28 Dec 2004
-#
-# This software is distributed under the LGPL.  See COPYING for more.
-
-
-VERSION=0.92
-
-# override this when installing: &quot;make install prefix=/usr/local&quot;
-#prefix=/usr
-prefix=$(HOME)
-
-
-bindir=$(prefix)/bin
-lib_src=tmlib.sh
-
-ifeq ($(prefix), $(HOME))
-	libdir=$(prefix)
-	stdlib=$(libdir)/.tmlib.sh
-	conf_dst=$(HOME)/.tmtestrc
-else
-	libdir=$(prefix)/share/tmtest
-	stdlib=$(libdir)/tmlib.sh
-	conf_dst=/etc/tmtest.conf
-endif
-
-
-COPTS=-g -Wall -Werror
-
-# utilities:
-CSRC+=curdir.c qscandir.c pcrs.c rel2abs.c
-CHDR+=curdir.h qscandir.h pcrs.h rel2abs.h
-# scanner files
-CSRC+=re2c/read.c re2c/read-fd.c re2c/scan.c
-CHDR+=re2c/read.h re2c/read-fd.h re2c/scan.h
-# program files:
-CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c
-CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h matchval.h
-
-# It makes it rather hard to debug when Make deletes the intermediate files.
-INTERMED=stscan.c
-
-
-tmtest: $(CSRC) $(CHDR) template.c Makefile $(INTERMED)
-	$(CC) $(COPTS) $(CSRC) -lpcre template.c -o tmtest &quot;-DVERSION=$(VERSION)&quot;
-
-template.c: template.sh cstrfy Makefile
-	./cstrfy -n exec_template &lt; template.sh &gt; template.c
-
-%.c: %.re
-	re2c $(REOPTS) $&lt; &gt; $@
-	perl -pi -e 's/^\#line.*$$//' $@
-
-%.o: %.c
-	$(CC) -g -c $&lt; -o $@
-
-.PHONY: test
-test: tmtest
-	./tmtest test
-
-run: tmtest
-	./tmtest
-
-install: tmtest
-	install -d -m755 $(bindir)
-	install tmtest $(bindir)
-	install -d -m755 $(libdir)
-	install tmlib.sh $(stdlib)
-ifeq ($(wildcard $(conf_dst)),$(conf_dst))
-	# configuration already exists, don't overwrite it.
-	@echo &quot;---&gt; Not installing new config file over '$(conf_dst).'&quot;
-	@echo &quot;---&gt; Please merge changes in 'sample.conf' by hand or run 'make uninstall' first.&quot;
-else
-	# global configuration file doesn't exist so install it
-	install sample.conf $(conf_dst)
-	@perl -pi -e 's/USER/$(shell whoami)/g' $(conf_dst)
-	@perl -pi -e 's:STDLIB:$(stdlib):g' $(conf_dst)
-endif
-
-# NOTE: This will remove the configuration file too!
-uninstall: tmtest
-	rm $(bindir)/tmtest
-	rm $(stdlib)
-ifeq ($(prefix), $(HOME))
-	rm $(HOME)/.tmtestrc
-else
-	rm /etc/tmtest.conf
-endif
-
-clean:
-	rm -f tmtest template.c tags
-
-# Ensure re2c is installed to regenerate the scanners before making distclean
-distclean: clean
-	rm -f stscan.[co]
-
-tags: $(CSRC) $(CHDR) $(INTERMED)
-	ctags -R
-
-doc:
-	doxygen
-	which pods2html &gt; /dev/null || echo &quot;You must install Pod::Tree off CPAN&quot;
-	pods2html . docs/html
-	$(MAKE) graphs
-
-%.png: %.dot
-	dot -Tpng $&lt; -o $@
-
-rediff:
-	diff ../oe/re2c/ re2c
-	
-reupdate:
-	ls re2c/*.[ch] | (ODIR=`pwd`; cd ../oe; xargs cp --target-directory $$ODIR/re2c)

Copied: releases/0.94/Makefile (from rev 99, trunk/Makefile)

Deleted: releases/0.94/TODO
===================================================================
--- trunk/TODO	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/TODO	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,98 +0,0 @@
-0.94:
-- An empty test with a STDOUT clause should fail without the -n right?
-  I mean, there's no newline in the actual output, but there is in the
-  expected...
-- Add tests for binary transparency.
-- write tests for nesting testfiles with --config.
-        // If the user specifies a config file, we only check directories
-        // not above the given config file.  i.e. if user specifies
-        // &quot;tmtest -c /a/b/cc /a/t/u/t.test&quot;, we will look for config files
-        // in /a/t/tmtest.conf and /a/t/u/tmtest.conf.
-- Add the ability to specify test arguments on the command line.
-  I'm picturing something where VAR=val on the command line would be
-  inserted without change into the template.  That way you can use the
-  command line to override default settings in the testfile.
-  - This would allow us to test almost every test to ensure it
-    supports the --config argument (make them DISABLED or something).
-
-0.96:
-- stdin is all buggered up.  why is it that &quot;cat&quot; with no args will print
-  the rest of the test script?  And why is it that if you fork, diff freezes?
-  They're related problems I suspect.
-    Is it because I'm forgetting to close all open filehandles before forking?
-- Tighten up printing a folder name when there are no testfiles in it.
-  No need for double spacing.
-- Add the ability to run multiple tests from one testfile.
-  See tmtest 0.8 for a potential implementation of this.
-  All we'd need to add is a framework to notify the user that multiple
-  tests are in progress; bash can take care of the rest.
-- Shouldn't run every test in a dir if the DISABLED directive is in a config
-  file.
-  Should discover what dir the DISABLED directive came from and refuse
-  to run anything below that.
-  - Yes, if a config file returns DISABLED, then that folder and all its
-    subfolders are skipped.  Just make the test itself call the DISABLED
-	command if you want testing to continue in that subfolder.
-
-0.98:
-- Change the I/O scheme to be event based.  Get rid of the tempfiles.
-  Convert to using the async io library.  Don't use temporary files.
-  This would allow us to recognize that the test is disabled before
-  producing a partial diff, blowing away output sections.
-- Use i/o lib for everything.  No need for temp files.
-  This means that we stream everything EXCEPT stderr, which we memory
-  buffer.  If your stderr is more than 100K or so in size, just redirect
-  it to stdout.
-
-2.0:
-- get rid of all the exit(10) calls in test.c.  We need a better way to
-  abort the test.
-  should get rid of a whole bunch in main.c as well.
-  this should prevent us from dropping turds in /tmp all the time too.
-- Get rid of MODIFY clauses.  It's unnecessary complexity.
-  And it's a LOT.  First remove it from the tests, then from the code.
-
-?:
-- add gcov support so you can see what sort of coverage your tests provide.
-- Provide some sort of automatable XML output?
-- Could take tests from tarfiles.  We would decompress the tarfile into
-  a temporary directory, run the test, and delete the tarfile.  This will
-  make it easier to maintain tests that all need to be run in a certain
-  directory hierarchy.
-- add the ability to run valgrind over each test and print success/failure
-  of that.  (gives deep valgrind coverage)
-  - One problem with this will be all the false warnings.
-
-No longer a problem when we dump pcrs:
-- allow multiple s/// expressions on a single line.  will probably require
-  modifications to pcrs_compile_command, so make it support buf/len at the
-  same time.  These might be non-trivial changes...
-- it's stupid to dup the str just to null-terminate it so it can be passed
-  to pcrs.  Modify pcrs to compile buffers too.
-- Unify the line modifier in compare.c and test.c.  It's hackish now.
-- Wow, the pcrs error messages truly suck.  Is there any way to improve them?
-  &quot;(pcrs:) Syntax error while parsing command (-11).&quot;
-- add a CLEAR_EACHLINE or CLEAR_MODIFY option to to turn off all substitutions.
-  It would be easy to do.  I'm just not convinced that anyone would find it
-  useful.
-
-????:
-- There should be a way to repeatedly run a single test with only tiny
-  differences.  i.e. test all permeutations of DISABLE DISABLE:
-  DISABLED DISABLED:  Hopefully that will clean up 05-08-Disable/Abort.test
-- Add a timeout that will terminate stalled tests.  You can set the timeout
-  in the config file or the test itself.
-
-maybe never:
-- Add STDOUT: trimws and STDERR: trimws - to trim whitespace from
-  the front of each output line.
-  I wanted to add this to simulate the &quot;STDOUT=&lt;&lt;-EOL&quot; heredoc sequence
-  of the original tests (that is nestable, unlinke Bash's.  But now I
-  realize that this problem is pretty much solved from the other direction.
-  Instead of removing indentation from the heredoc, simply add indentation
-  using a MODIFY section (as detailed in the FAQ).
-- Add a &quot;FAILURE-OK&quot; flag for when failure IS an option.  This would print
-  that the test failed, but would not highlight it, and would not count
-  either positively or negatively toward the test results.  That way you
-  can include experimental tests in a production test stack (say you're
-  developing a test and want to know if it's a good idea...)

Copied: releases/0.94/TODO (from rev 99, trunk/TODO)

Deleted: releases/0.94/compare.c
===================================================================
--- trunk/compare.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/compare.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,305 +0,0 @@
-/* compare.c
- * Scott Bronson
- * 31 Dec 2004
- *
- * This file is distrubuted under the MIT License
- * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
- *
- *
- * File comparison.
- *
- * This uses all re2c's mechanisms for creating buffers and loading
- * them with data, but it's not an re2c scanner.
- *
- * Here's what you do:
- * - Create a scanstate that reads from one of the files (or
- *   whatever) that you want to compare and pass it to compare_start.
- * - Call compare_continue with any size data block from the other
- *   file you want to compare.  Keep calling until you're out of
- *   data.  Check compare_in_progress to see if it failed prematurely.
- * - Finally, when you're out of data in the other file, call
- *   compare_end.  It will verify that it's at eof on the first
- *   file.
- * - Read the final result from the matchval.
- *
- * Well, the line buffering for the pcrs library has utterly destroyed
- * the simplicity of this file.
- *
- */
-
-#include &lt;string.h&gt;
-#include &quot;compare.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;assert.h&gt;
-
-
-typedef struct {
-	matchval *output;
-	pcrs_job *jobs;
-	const char *pbuf;
-	int pcursor;
-	int plimit;
-    int no_trailing_newline;
-    int nl_suppressed;
-} compare_state;
-
-
-static int compare_fill(scanstate *ss)
-{
-    return (*ss-&gt;read)(ss);
-}
-
-
-static void compare_halt(scanstate *ss, matchval newval)
-{
-	compare_state *cmp = (compare_state*)ss-&gt;scanref;
-    *cmp-&gt;output = newval;
-	if(cmp-&gt;pbuf) free((char*)cmp-&gt;pbuf);
-	free(cmp);
-    ss-&gt;scanref = NULL;
-}
-
-
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *jobs, int nonl)
-{
-	compare_state *cmp = malloc(sizeof(compare_state));
-	if(cmp == NULL) {
-		perror(&quot;compare_attach&quot;);
-		exit(10);
-	}
-	memset(cmp, 0, sizeof(compare_state));
-
-    *mv = match_inprogress;
-
-	cmp-&gt;output = mv;
-	cmp-&gt;jobs = jobs;
-    cmp-&gt;no_trailing_newline = nonl;
-    cmp-&gt;nl_suppressed = 0;;
-    ss-&gt;scanref = cmp;
-}
-
-
-
-static void compare_continue_bytes(scanstate *ss, const char *ptr, int len)
-{
-    int n;
-
-    while(len &gt; 0) {
-        n = ss-&gt;limit - ss-&gt;cursor;
-        if(!n) {
-            n = compare_fill(ss);
-            if(n &lt; 0) {
-                // there was an error while trying to fill the buffer
-                // TODO: this should be propagated to the client somehow.
-                perror(&quot;compare_continue_bytes&quot;);
-                exit(10);
-            }
-            if(n == 0) {
-                compare_halt(ss, match_no);
-                return;
-            }
-        }
-
-        if(len &lt; n) {
-            n = len;
-        }
-
-        // compare
-        if(memcmp(ptr, ss-&gt;cursor, n) != 0) {
-            compare_halt(ss, match_no);
-            return;
-        }
-        ptr += n;
-        ss-&gt;cursor += n;
-        len -= n;
-    }
-}
-
-
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize)
-{
-	char *old, *new;
-	int nsubs;
-	int cnt;
-
-	cnt = 0;
-	old = (char*)cp;
-	*newsize = ce - cp;
-
-	while(job) {
-		// Now, run the line through the substitutions.
-		nsubs = pcrs_execute(job, old, *newsize, &amp;new, newsize);
-		if(nsubs &lt; 0) {
-			fprintf(stderr, &quot;error while substituting expr %d: %s (%d).\n&quot;,
-					cnt, pcrs_strerror(nsubs), nsubs);
-            if(new) {
-                free(new);
-                new = NULL;
-            }
-			break;
-		}
-
-		assert(strlen(new) == *newsize);
-
-		if(old != cp) {
-			// free the intermediate result.
-			free(old);
-		}
-		old = new;
-		job = job-&gt;next;
-		cnt += 1;
-	}
-
-    return new;
-}
-
-
-// This routine is hellish because neither stream is line buffered.
-// Therefore, we line buffer the file and compare in chunks against
-// the input.  &quot;pbuf&quot; is the substitution-modified buffer allocated
-// by the pcre library.
-
-static void compare_continue_lines(scanstate *ss, compare_state *cmp,
-		const char *ptr, size_t len)
-{
-	int n;
-	const char *p;
-    char *new;
-    size_t newsize;
-
-	while(len &gt; 0) {
-		n = cmp-&gt;plimit - cmp-&gt;pcursor;
-		assert(n &gt;= 0);
-		if(n) {
-			// there's more data in the pbuf.  use it for comparison.
-			if(len &lt; n) n = len;
-			if(memcmp(ptr, cmp-&gt;pbuf+cmp-&gt;pcursor, n) != 0) {
-				compare_halt(ss, match_no);
-				return;
-			}
-			cmp-&gt;pcursor += n;
-			ptr += n;
-			len -= n;
-			assert(len &gt;= 0);
-			if(!len) break;
-		}
-
-		// we've emptied the pbuf so we need to regenerate it.
-		// first see if there's anther line in the line buffer.
-		p = memchr(ss-&gt;cursor, '\n', ss-&gt;limit - ss-&gt;cursor);
-		if(!p) {
-			// there's no newline in the buffer.  try to refill.
-			n = compare_fill(ss);
-			if(n &lt; 0) {
-				// there was an error while trying to fill the buffer
-				// TODO: this should be propagated to the client somehow.
-				perror(&quot;compare_continue_lines&quot;);
-				exit(10);
-			}
-			if(n == 0) {
-                compare_halt(ss, match_no);
-                return;
-			}
-
-			p = memchr(ss-&gt;cursor, '\n', ss-&gt;limit - ss-&gt;cursor);
-			if(!p) {
-				// we'll just have to treat the entire buffer as a full
-				// line and hope for the best.  Subtract one because
-				// the very next line will add one.
-				p = ss-&gt;limit - 1;
-			}
-		}
-
-		// move p past the newline so it's at the end of the current line.
-		p += 1;
-		new = substitute_string(cmp-&gt;jobs, ss-&gt;cursor, p, &amp;newsize);
-        if(!new) {
-            // there must have been an error
-            compare_halt(ss, match_no);
-            return;
-        }
-
-        if(cmp-&gt;pbuf) free((char*)cmp-&gt;pbuf);
-        cmp-&gt;pbuf = new;
-        cmp-&gt;pcursor = 0;
-        cmp-&gt;plimit = newsize;
-		ss-&gt;cursor = p;
-	}
-}
-
-
-void compare_continue(scanstate *ss, const char *ptr, int len)
-{
-	compare_state *cmp = (compare_state*)ss-&gt;scanref;
-
-    if(!ss-&gt;scanref) {
-        // we already decided the files don't match
-        // so don't waste time comparing more.
-        return;
-    }
-
-    assert(len &gt;= 0);
-
-    if(cmp-&gt;no_trailing_newline) {
-        // If the incoming buffer ends in a nl, we need to suppress it
-        // for the comparison.  Note that this won't work well for
-        // MODIFY clauses but I don't care because MODIFY will never
-        // work with -n and, anyway, MODIFY is about to disappear.
-
-        if(cmp-&gt;nl_suppressed) {
-            compare_continue_bytes(ss, &quot;\n&quot;, 1);
-            cmp-&gt;nl_suppressed = 0;
-        }
-
-        if(ptr[len-1] == '\n') {
-            cmp-&gt;nl_suppressed = 1;
-            len -= 1;
-        }
-    }
-
-	if(cmp-&gt;jobs) {
-		compare_continue_lines(ss, cmp, ptr, len);
-	} else {
-		compare_continue_bytes(ss, ptr, len);
-	}
-}
-
-
-void compare_end(scanstate *ss)
-{
-	compare_state *cmp = (compare_state*)ss-&gt;scanref;
-
-    if(!ss-&gt;scanref) {
-        // we already decided the files don't match
-        // so don't waste time comparing more.
-        return;
-    }
-
-	assert(cmp-&gt;pcursor &lt;= cmp-&gt;plimit);
-	assert(ss-&gt;cursor &lt;= ss-&gt;limit);
-
-	if(cmp-&gt;jobs) {
-		// if there's more data in the pbuf then fail.
-		if(cmp-&gt;plimit - cmp-&gt;pcursor != 0) {
-			compare_halt(ss, match_no);
-			return;
-		}
-	}
-
-	// if we have no data left in the scan buffer
-	if(ss-&gt;cursor == ss-&gt;limit) {
-		// and our input file is at eof
-		if(compare_fill(ss) == 0) {
-			// then the two data streams match
-			compare_halt(ss, match_yes);
-			return;
-		}
-	}
-
-    // otherwise, they don't.
-    compare_halt(ss, match_no);
-}
-
-

Copied: releases/0.94/compare.c (from rev 99, trunk/compare.c)

Deleted: releases/0.94/compare.h
===================================================================
--- trunk/compare.h	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/compare.h	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,27 +0,0 @@
-/* compare.h
- * Scott Bronson
- * 31 Dec 2004
- *
- * File comparison prototypes.
- *
- * See compare.c for license.
- */
-
-#include &quot;pcrs.h&quot;
-#include &quot;matchval.h&quot;
-#include &quot;re2c/scan.h&quot;
-
-
-/** Returns zero if the compare has stopped (i.e. the files differed).
- */
-
-#define compare_in_progress(ss) ((ss)-&gt;scanref)
-
-
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *joblist, int nonl);
-void compare_continue(scanstate *ss, const char *ptr, int len);
-void compare_end(scanstate *cmp);
-
-// no better place to put this for now...
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize);
-

Copied: releases/0.94/compare.h (from rev 99, trunk/compare.h)

Deleted: releases/0.94/curdir.c
===================================================================
--- trunk/curdir.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/curdir.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,140 +0,0 @@
-/* curdir.c
- * 29 Jan 2005
- * Copyright (C) 2005 Scott Bronson
- *
- * This file is distrubuted under the MIT License
- * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
- *
- * Some simple path handling routines
- *
- * Unfortunately this file got hacked to shreds when tmtest was
- * made to run with /tmp as the constant cwd.  It's pretty
- * incomprehensible and in dire need of a rewrite.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;assert.h&gt;
-
-#include &quot;curdir.h&quot;
-
-
-static char curdir[CURDIR_SIZE];
-static char *curpart;
-
-
-int curinit(const char *path)
-{
-	if(path) {
-		if(strlen(path)+1 &gt; sizeof(curdir)) {
-			return -1;
-		}
-		strcpy(curdir, path);
-		curpart = NULL;	// don't use partials when inited from a path
-	} else {
-		if(!getcwd(curdir, sizeof(curdir))) {
-			return -1;
-		}
-		curpart = curdir + strlen(curdir) + 1;
-		*curpart = '\0';
-	}
-
-	return 0;
-}
-
-
-/**
- * @returns the number of directories you just pushed.
- * You'll need to pass this value to curpop if you want to pop
- * the same number of directories when you're done.
- */
-
-int curpush(const char *dir)
-{
-	int clen = strlen(curdir);
-	int dlen = strlen(dir);
-	int keep = 1;
-	const char *cp;
-
-	assert(dir);
-	assert(dir[0]);
-	assert(dir[0] != '/');
-
-	// count the number of '/' characters in dir
-	for(cp=dir; (cp=strchr(cp,'/'))!=0; cp++) {
-		keep++;
-	}
-
-	if(clen + dlen + 2 &gt; sizeof(curdir)) {
-		return -1;
-	}
-
-	strcat(curdir, &quot;/&quot;);
-	strcat(curdir, dir);
-
-	return keep;
-}
-
-
-void curpop(int keep)
-{
-	assert(keep&gt;0);
-
-	while(keep) {
-		char *cp = strrchr(curdir, '/');
-		assert(curpart &lt;= cp+1);
-		if(!cp) {
-			// we've run out of slashes.
-			assert(!&quot;out of slashes -- that's bad.&quot;);
-			return;
-		}
-
-		cp[0] = '\0';	// get rid of the slash.
-		cp[1] = '\0';	// blank out curpart or any other ptrs to this dir.
-		keep -= 1;
-	}
-}
-
-
-/** Resets the curdir so that curabsolute() and currelative()
- *  return what they did after curinit() was first called.
- */
-
-void curreset()
-{
-	if(curpart) {
-		curpart[-1] = '\0';
-		curpart[0] = '\0';
-	}
-}
-
-
-void cursave(struct cursave *save)
-{
-	strcpy(save-&gt;buf, curdir);
-	save-&gt;part = curpart;
-}
-
-
-void currestore(struct cursave *save)
-{
-	strcpy(curdir, save-&gt;buf);
-	curpart = save-&gt;part;
-}
-
-
-const char *curabsolute()
-{
-	return curdir;
-}
-
-
-const char *currelative()
-{
-	return curpart ? curpart : curdir;
-}
-
-
-

Copied: releases/0.94/curdir.c (from rev 99, trunk/curdir.c)

Deleted: releases/0.94/examples/docs/Modify3.test
===================================================================
--- trunk/examples/docs/Modify3.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/examples/docs/Modify3.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,7 +0,0 @@
-# This is from <A HREF="http://tmtest.berlios.de/wiki/index.php/MODIFY">http://tmtest.berlios.de/wiki/index.php/MODIFY</A>
-
-date
-MODIFY:
-  s/... +... +[0-9][0-9] +[0-9]?[0-9]:[0-9][0-9]:[0-9][0-9] +... +20[0-9][0-9]/date date date/
-STDOUT:
-date date date

Copied: releases/0.94/examples/docs/Modify3.test (from rev 98, trunk/examples/docs/Modify3.test)

Copied: releases/0.94/examples/docs/testfile (from rev 99, trunk/examples/docs/testfile)

Deleted: releases/0.94/examples/tutorial/20-ArgSuppressNL.test
===================================================================
--- trunk/examples/tutorial/20-ArgSuppressNL.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/examples/tutorial/20-ArgSuppressNL.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,3 +0,0 @@
-echo -n &quot;No newline&quot;
-STDOUT:
-No newline
\ No newline at end of file

Copied: releases/0.94/examples/tutorial/20-ArgSuppressNL.test (from rev 100, trunk/examples/tutorial/20-ArgSuppressNL.test)

Deleted: releases/0.94/main.c
===================================================================
--- trunk/main.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/main.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,904 +0,0 @@
-/* main.c
- * 28 Dec 2004
- * Copyright (C) 2004 Scott Bronson
- * 
- * The main routine for tmtest.
- *
- * This file is distrubuted under the MIT License
- * See <A HREF="http://en.wikipedia.org/wiki/MIT_License">http://en.wikipedia.org/wiki/MIT_License</A> for more.
- */
-
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;sys/wait.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;getopt.h&gt;
-#include &lt;assert.h&gt;
-
-#include &quot;re2c/read-fd.h&quot;
-
-#include &quot;test.h&quot;
-#include &quot;curdir.h&quot;
-#include &quot;qscandir.h&quot;
-#include &quot;vars.h&quot;
-#include &quot;tfscan.h&quot;
-#include &quot;rel2abs.h&quot;
-
-
-#define DIFFPROG &quot;/usr/bin/diff&quot;
-#define SHPROG   &quot;/bin/bash&quot;
-
-
-enum {
-    outmode_test,
-    outmode_dump,
-    outmode_diff
-};
-
-int outmode = outmode_test;
-int allfiles = 0;
-int dumpscript = 0;
-int quiet = 0;
-char *config_file;	// absolute path to the user-specified config file
-					// null if user didn't specify a config file.
-
-
-#define TESTDIR &quot;/tmp/tmtest-XXXXXX&quot;
-char g_testdir[sizeof(TESTDIR)];
-
-#define OUTNAME &quot;stdout&quot;
-#define ERRNAME &quot;stderr&quot;
-#define STATUSNAME &quot;status&quot;
-char g_outname[sizeof(TESTDIR)+sizeof(OUTNAME)];
-char g_errname[sizeof(TESTDIR)+sizeof(ERRNAME)];
-char g_statusname[sizeof(TESTDIR)+sizeof(STATUSNAME)];
-
-// file in tmpdir that holds stdout
-#define DIFFNAME &quot;diff&quot;
-
-
-int g_outfd;
-int g_errfd;
-int g_statusfd;
-
-
-
-// exit values:
-enum {
-    no_error = 0,
-    argument_error,
-    runtime_error,
-    interrupted_error,
-    internal_error,
-	initialization_error,
-};
-
-
-#define xstringify(x) #x
-#define stringify(x) xstringify(x)
-
-
-#define is_dash(s) ((s)[0] == '-' &amp;&amp; (s)[1] == '\0')
-
-
-/** Returns zero if s1 ends with s2, nonzero if not.
- */
-
-int strcmpend(const char *s1, const char *s2)
-{
-    size_t n1 = strlen(s1);
-    size_t n2 = strlen(s2);
-
-    if(n2 &lt;= n1) {
-        return strncmp(s1+n1-n2, s2, n2);
-    } else {
-        return 1;
-    }
-}
-
-
-/** Prints the given template to the given file, performing substitutions.
- */
-
-void print_template(struct test *test, const char *tmpl,  FILE *fp)
-{
-    char varbuf[32];
-    const char *cp, *ocp, *ce;
-    int len;
-
-    for(ocp=cp=tmpl; (cp=strchr(cp,'%')); cp++) {
-        if(cp[1] == '(') {
-            // perform a substitution
-            fwrite(ocp, cp - ocp, 1, fp);
-            cp += 2;
-            ce = strchr(cp,')');
-            if(!ce) {
-                fprintf(stderr, &quot;Unterminated template variable: '%.20s'\n&quot;, cp);
-                exit(runtime_error);
-            }
-            len = ce - cp;
-            if(len &lt;= 0) {
-                fprintf(stderr, &quot;Garbage template variable: '%.20s'\n&quot;, cp);
-                exit(runtime_error);
-            }
-            // truncate variable name if it doesn't fit into varbuf.
-            if(len &gt; sizeof(varbuf)-1) {
-                len = sizeof(varbuf)-1;
-            }
-            memcpy(varbuf, cp, len);
-            varbuf[len] = '\0';
-            if(printvar(test,fp,varbuf) != 0) {
-                // printvar has already printed the error message
-                exit(runtime_error);
-            }
-            ocp = cp = ce+1;
-        }
-    }
-
-    fputs(ocp, fp);
-}
-
-
-/** Checks the actual results against the expected results.
- *
- * Returns 0 if all results match, or a code telling what
- * part didn't match.
- */
-
-
-void reset_fd(int fd, const char *fname)
-{
-    if(lseek(fd, 0, SEEK_SET) &lt; 0) {
-        fprintf(stderr, &quot;Couldn't seek to start of %s: %s\n&quot;,
-                fname, strerror(errno));
-        exit(runtime_error);
-    }
-
-    if(ftruncate(fd, 0) &lt; 0) {
-        fprintf(stderr, &quot;Couldn't reset file %s: %s\n&quot;,
-                fname, strerror(errno));
-        exit(runtime_error);
-    }
-}
-
-
-int wait_for_child(int child, const char *name)
-{
-    int pid;
-    int signal;
-    int status;
-
-    // wait patiently for child to finish.
-    pid = waitpid(child, &amp;status, 0);
-    if(pid &lt; 0) {
-        fprintf(stderr, &quot;Error waiting for %s to finish: %s\n&quot;,
-                strerror(errno), name);
-        exit(runtime_error);
-    }
-
-    if(WIFSIGNALED(status)) {
-        signal = WTERMSIG(status);
-        if(signal == SIGINT) {
-            // If test was interrupted with a sigint then raise it on ourselves.
-            // Otherwise it can be hard to interrupt a test battery.
-			kill(getpid(), SIGINT);
-        }
-        // it's probably a SIGABRT if child hit an assertion.
-        // we'll just return 256.
-        return 256;
-    }
-
-    if(!WIFEXITED(status)) {
-        fprintf(stderr, &quot;Unknown status returned by %s: %d\n&quot;, name, status);
-        exit(runtime_error);
-    }
-
-    return WEXITSTATUS(status);
-}
-
-
-int open_file(char *fn, const char *name, int flags)
-{
-	strcpy(fn, g_testdir);
-	strcat(fn, &quot;/&quot;);
-	strcat(fn, name);
-
-    int fd = open(fn, flags|O_RDWR|O_CREAT/*|O_EXCL*/, S_IRUSR|S_IWUSR);
-    if(fd &lt; 0) {
-        fprintf(stderr, &quot;couldn't open %s: %s\n&quot;, fn, strerror(errno));
-        exit(runtime_error);	// TODO
-    }
-
-    return fd;
-}
-
-
-int write_stdin_to_tmpfile(struct test *test)
-{
-	char *buf;
-	int fd;
-
-	buf = malloc(sizeof(TESTDIR) + sizeof(DIFFNAME));
-	if(!buf) {
-		perror(&quot;malloc&quot;);
-		exit(10);	// TODO
-	}
-
-	test-&gt;diffname = buf;
-	fd = open_file(buf, DIFFNAME, 0);
-	assert(strlen(buf) == sizeof(TESTDIR)+sizeof(DIFFNAME)-1);
-	write_raw_file(fd, 0);
-	close(fd);
-
-	return fd;
-}
-
-
-/** Forks off a diff process and sets it up to receive the dumped test.
- */
-
-int start_diff(struct test *test)
-{
-    int pipes[2];
-    int child;
-	const char *filename = NULL;
-
-    assert(test-&gt;testfilename);
-	// if the test is coming from stdin, we need to copy it to a
-	// real file before we can diff against it.
-    if(is_dash(test-&gt;testfilename)) {
-		// first, write all of our stdin to a tmpfile.
-		write_stdin_to_tmpfile(test);
-		// then, read the test from this file instead of stdin.
-		filename = test-&gt;diffname;
-		assert(filename);
-    }
-
-    if(pipe(pipes) &lt; 0) {
-        perror(&quot;creating diff pipe&quot;);
-        exit(runtime_error);
-    }
-
-    child = fork();
-    if(child &lt; 0) {
-        perror(&quot;forking diff&quot;);
-        exit(runtime_error);
-    }
-    if(child == 0) {
-        if(dup2(pipes[0], 0) &lt; 0) {
-            perror(&quot;dup2ing test output to child's stdin&quot;);
-            exit(runtime_error);
-        }
-        close(pipes[0]);
-        close(pipes[1]);
-
-		if(!filename) {
-			// figure out the filename that diff will use
-			if(test-&gt;testfilename[0] == '/') {
-				filename = test-&gt;testfilename;
-			} else {
-				// since we don't have an absolute path, we need to
-				// cd to the original wd and run the diff with
-				// a relative path.  it takes a bit of computation...
-				curpush(test-&gt;testfilename);
-				filename = strdup(currelative());
-				if(!filename) {
-					perror(&quot;strdup in start_diff&quot;);
-					exit(runtime_error);
-				}
-				curreset();
-				if(0 != chdir(curabsolute())) {
-					fprintf(stderr, &quot;Could not chdir 1 to %s: %s\n&quot;, curabsolute(), strerror(errno));
-					exit(runtime_error);
-				}
-			}
-		}
-
-        execl(DIFFPROG, DIFFPROG, &quot;-u&quot;, filename, &quot;-&quot;, (char*)NULL);
-        perror(&quot;executing &quot; DIFFPROG &quot; for test&quot;);
-        exit(runtime_error);
-    }
-
-    close(pipes[0]);
-    test-&gt;rewritefd = pipes[1];
-
-    return child;
-}
-
-
-/** Waits for the forked diff process to finish.
- */
-
-void finish_diff(struct test *test, int diffpid)
-{
-    close(test-&gt;rewritefd);
-
-    int status = wait_for_child(diffpid, &quot;diff&quot;);
-
-    if(status != 0 &amp;&amp; status != 1) {
-        fprintf(stderr, &quot;diff returned %d!\n&quot;, status);
-        exit(runtime_error);
-    }
-}
-
-
-/** Runs the named testfile.
- *
- * If warn_suffix is true and the ffilename doesn't end in &quot;.test&quot;
- * then we'll print a warning to stderr.  This is used when
- * processing the cmdline args so the user will know why a file
- * explicitly named didn't run.
- *
- * When config files are executing, they use the standard stdout
- * and stderr.  That way, the user sees any output while the test
- * is running (should help with debugging).  However, when the
- * test itself is running, its output is redirected into outfd/errfd.
- *
- * It may appear that outmode_dump mixes stdio and Unix I/O, but it
- * doesn't really.  We only print to stdio when testing, and we only
- * dump the file when dumping.  They cannot both happen simultaneously.
- *
- * @returns 1 if we should keep testing, 0 if we should stop now.
- */
-
-int run_test(const char *name, int warn_suffix)
-{
-    struct test test;
-    char buf[BUFSIZ];   // scan buffer for the testfile
-    int pipes[2];
-    int child;
-	int keepontruckin;
-    int diffpid;
-    int fd = -1;
-    FILE *tochild;
-
-    // defined in the exec.c file generated by exec.tmpl.
-    extern const char exec_template[];
-
-    if(!is_dash(name) &amp;&amp; !allfiles &amp;&amp; (strcmpend(name, &quot;.test&quot;) != 0)) {
-        if(warn_suffix) {
-            fprintf(stderr, &quot;%s was skipped because it doesn't end in '.test'.\n&quot;, name);
-        }
-        return 1;
-    }
-
-	// so that we can safely single quote filenames in the shell.
-	if(strchr(name, '\'') || strchr(name, '&quot;')) {
-		fprintf(stderr, &quot;%s was skipped because its file name contains a quote character.\n&quot;, name);
-		return 1;
-	}
-
-    test_init(&amp;test);
-    test.testfilename = name;
-    test.outfd = g_outfd;
-    test.errfd = g_errfd;
-    test.statusfd = g_statusfd;
-
-    // initialize the test mode
-    switch(outmode) {
-        case outmode_test:
-            // nothing to do
-            break;
-        case outmode_dump:
-            test.rewritefd = STDOUT_FILENO;
-            break;
-        case outmode_diff:
-            diffpid = start_diff(&amp;test);
-            break;
-        default:
-            assert(!&quot;Unhandled outmode 1 in run_test()&quot;);
-    }
-
-    // reset the stdout and stderr capture files.
-    reset_fd(test.outfd, &quot;stdout&quot;);
-    reset_fd(test.errfd, &quot;stderr&quot;);
-    reset_fd(test.statusfd, &quot;status&quot;);
-
-    // set up the pipe to feed input to the child.
-    // ignore sigpipes since we don't want a signal raised if child
-    // quits early (which almost always happens since it exits before
-    // it reads its expected stdout/stderr).
-    if(pipe(pipes) &lt; 0) {
-        perror(&quot;creating test pipe&quot;);
-        exit(runtime_error);
-    }
-
-    // fork child process
-    child = fork();
-    if(child &lt; 0) {
-        perror(&quot;forking test&quot;);
-        exit(runtime_error);
-    }
-    if(child == 0) {
-        if(dup2(pipes[0], 0) &lt; 0) {
-            perror(&quot;dup2ing input to test's stdin&quot;);
-            exit(runtime_error);
-        }
-        close(pipes[0]);
-        close(pipes[1]);
-        execl(SHPROG, SHPROG, &quot;-s&quot;, (char*)NULL);
-        perror(&quot;executing &quot; SHPROG &quot; for test&quot;);
-        exit(runtime_error);
-    }
-
-    // create the testfile scanner.  it will either scan from
-    // the testfile itself or from stdin if filename is &quot;-&quot;.
-    scanstate_init(&amp;test.testfile, buf, sizeof(buf));
-	if(test.diffname) {
-		if(lseek(test.diff_fd, 0, SEEK_SET) &lt; 0) {
-			fprintf(stderr, &quot;Couldn't seek to start of %s: %s\n&quot;,
-					test.diffname, strerror(errno));
-			exit(runtime_error);
-		}
-        readfd_attach(&amp;test.testfile, test.diff_fd);
-	} else if(is_dash(name)) {
-        readfd_attach(&amp;test.testfile, STDIN_FILENO);
-    } else {
-		if(name[0] == '/') {
-			fd = open(name, O_RDONLY);
-		} else {
-			int keep = curpush(name);
-			if(keep &lt;= 0) {
-				fprintf(stderr, &quot;Path is too long.&quot;);
-				exit(runtime_error);
-			}
-			fd = open(curabsolute(), O_RDONLY);
-			curpop(keep);
-		}
-        if(fd &lt; 0) {
-            fprintf(stderr, &quot;Could not open %s: %s\n&quot;,
-                    curabsolute(), strerror(errno));
-            exit(runtime_error); // TODO
-        }
-        readfd_attach(&amp;test.testfile, fd);
-    }
-    tfscan_attach(&amp;test.testfile);
-
-    if(dumpscript) {
-        print_template(&amp;test, exec_template, stdout);
-        exit(0);  // screw the kid
-    }
-
-    // set up the pipes for the parent
-    close(pipes[0]);
-    tochild = fdopen(pipes[1], &quot;w&quot;);
-    if(!tochild) {
-        perror(&quot;calling fdopen on pipe&quot;);
-        exit(runtime_error);
-    }
-
-    // write the test script to the kid
-    print_template(&amp;test, exec_template, tochild);
-    fclose(tochild);
-
-    // wait for the test to finish
-    test.exitno = wait_for_child(child, &quot;test&quot;);
-
-	// read the status file to determine what happened
-	// and store the information in the test struct.
-	scan_status_file(&amp;test);
-
-    // process and output the test results
-    switch(outmode) {
-        case outmode_test:
-            test_results(&amp;test);
-            break;
-        case outmode_dump:
-            dump_results(&amp;test);
-            break;
-        case outmode_diff:
-            dump_results(&amp;test);
-            finish_diff(&amp;test, diffpid);
-            break;
-        default:
-            assert(!&quot;Unhandled outmode 2 in run_test()&quot;);
-    }
-
-    // if we had to open the testfile to read it, we now close it.
-    // because the scanner is statically allocated, there's no
-    // need to destroy it.
-    if(fd &gt;= 0) {
-        close(fd);
-    }
-	keepontruckin = !test.aborted;
-    test_free(&amp;test);
-
-	return keepontruckin;
-}
-
-
-/** This routine filters out any dirents that begin with '.'.
- *  We don't want to process any hidden files or special directories.
- */
-
-int select_nodots(const struct dirent *d)
-{
-    return d-&gt;d_name[0] != '.';
-}
-
-
-// forward declaration for recursion
-int process_dir();
-
-
-/** Processes a directory specified using an absolute path.
- *
- * We need to save and restore curpath to do this.
- *
- * @returns 1 if we should continue testing, 0 if we should abort.
- */
-
-int process_absolute_file(const char *path, int warn_suffix)
-{
-	struct cursave save;
-	int keepontruckin;
-
-	cursave(&amp;save);
-	curinit(&quot;/&quot;);
-
-	if(outmode == outmode_test) {
-		printf(&quot;\nProcessing %s\n&quot;, path);
-	}
-	keepontruckin = run_test(path, warn_suffix);
-
-	currestore(&amp;save);
-	return keepontruckin;
-}
-
-
-/** Processes a directory specified using an absolute path.
- *
- * We need to save and restore curpath to do this.
- */
-
-int process_absolute_dir(const char *path)
-{
-	struct cursave save;
-	int keepontruckin;
-
-	cursave(&amp;save);
-	curinit(path);
-
-	if(outmode == outmode_test) {
-		printf(&quot;\nProcessing %s\n&quot;, path);
-	}
-	keepontruckin = process_dir();
-
-	currestore(&amp;save);
-
-	return keepontruckin;
-}
-
-
-/** Process all entries in a directory.
- *
- * See run_test() for an explanation of warn_suffix.
- */
-
-int process_ents(char **ents, int warn_suffix)
-{
-    struct stat st;
-    mode_t *modes;
-    int i, n;
-	int keepontruckin;
-
-    for(n=0; ents[n]; n++)
-        ;
-
-    modes = malloc(n * sizeof(mode_t));
-    if(!modes) {
-        fprintf(stderr, &quot;Could not allocate %d mode_t objects.\n&quot;, n);
-        exit(runtime_error);
-    }
-    
-    // first collect the stat info for each entry
-    for(i=0; i&lt;n; i++) {
-        if(!is_dash(ents[i])) {
-			const char *cp = ents[i];
-			int keep = 0;
-			if(ents[i][0] != '/') {
-				keep = curpush(ents[i]);
-				if(keep &lt;= 0) {
-					fprintf(stderr, &quot;Path is too long.&quot;);
-					exit(runtime_error);
-				}
-				cp = curabsolute();
-			}
-            if(stat(cp, &amp;st) &lt; 0) {
-                fprintf(stderr, &quot;%s: %s\n&quot;, cp, strerror(errno));
-                exit(runtime_error);
-            }
-			if(ents[i][0] != '/') curpop(keep);
-            modes[i] = st.st_mode;
-        }
-    }
-
-    // process all files in dir
-    for(i=0; i&lt;n; i++) {
-        if(is_dash(ents[i]) || S_ISREG(modes[i])) {
-			if(ents[i][0] == '/') {
-				keepontruckin = process_absolute_file(ents[i], warn_suffix);
-			} else {
-				keepontruckin = run_test(ents[i], warn_suffix);
-			}
-			if(!keepontruckin) {
-				goto abort;
-			}
-            modes[i] = 0;
-        }
-    }
-
-    // process all subdirs
-    for(i=0; i&lt;n; i++) {
-        if(is_dash(ents[i]) || modes[i] == 0) continue;
-        if(S_ISDIR(modes[i])) {
-			if(ents[i][0] == '/') {
-				keepontruckin = process_absolute_dir(ents[i]);
-			} else {
-				int keep = curpush(ents[i]);
-				if(keep &lt;= 0) {
-					fprintf(stderr, &quot;Path is too long.&quot;);
-					exit(runtime_error);
-				}
-				if(outmode == outmode_test) {
-					printf(&quot;\nProcessing ./%s\n&quot;, currelative());
-				}
-				keepontruckin = process_dir();
-				curpop(keep);
-			}
-			if(!keepontruckin) {
-				goto abort;
-			}
-        }
-    }
-
-abort:
-    free(modes);
-	return keepontruckin;
-}
-
-
-/** Runs all tests in the current directory and all its subdirectories.
- */
-
-int process_dir()
-{
-    char **ents;
-    int i;
-	int keepontruckin;
-
-    ents = qscandir(curabsolute(), select_nodots, qdirentcoll);
-    if(!ents) {
-        // qscandir has already printed the error message
-        exit(runtime_error);
-    }
-
-    keepontruckin = process_ents(ents, 0);
-
-    for(i=0; ents[i]; i++) {
-        free(ents[i]);
-    }
-    free(ents);
-
-	return keepontruckin;
-}
-
-
-static void checkerr(int err, const char *op, const char *name)
-{
-	if(err &lt; 0) {
-		fprintf(stderr, &quot;There was an error %s %s: %s\n&quot;,
-				op, name, strerror(errno));
-		// not much else we can do other than complain...
-	}
-}
-
-
-void stop_tests()
-{
-	checkerr(close(g_outfd), &quot;closing&quot;, g_outname);
-	checkerr(close(g_errfd), &quot;closing&quot;, g_errname);
-	checkerr(close(g_statusfd), &quot;closing&quot;, g_statusname);
-
-	checkerr(unlink(g_outname), &quot;deleting&quot;, g_outname);
-	checkerr(unlink(g_errname), &quot;deleting&quot;, g_errname);
-	checkerr(unlink(g_statusname), &quot;deleting&quot;, g_statusname);
-
-	checkerr(rmdir(g_testdir), &quot;removing directory&quot;, g_testdir);
-}
-
-
-static void sig_int(int blah)
-{
-	stop_tests();
-	exit(interrupted_error);
-}
-
-
-/** Prepare system for running tests.
- *
- * We do all I/O for all tests through only three file descriptors.
- * We seek to the beginning of each file before running each test.
- * This should save some inode thrashing.
- */
-
-void start_tests()
-{
-	char *cp;
-
-    signal(SIGPIPE, SIG_IGN);
-    signal(SIGINT, sig_int);
-
-	strcpy(g_testdir, TESTDIR);
-	if(!mkdtemp(g_testdir)) {
-		fprintf(stderr, &quot;Could not call mkdtemp() on %s: %s\n&quot;, g_testdir, strerror(errno));
-		exit(initialization_error);
-	}
-
-	// errors are handled by open_file.
-    g_outfd = open_file(g_outname, OUTNAME, 0);
-	assert(strlen(g_outname) == sizeof(g_outname)-1);
-    g_errfd = open_file(g_errname, ERRNAME, 0);
-	assert(strlen(g_errname) == sizeof(g_errname)-1);
-    g_statusfd = open_file(g_statusname, STATUSNAME, O_APPEND);
-	assert(strlen(g_statusname) == sizeof(g_statusname)-1);
-
-	if(curinit(NULL) != 0) {
-		fprintf(stderr, &quot;Could not get the cwd: %s\n&quot;, strerror(errno));
-		exit(initialization_error);
-	}
-
-	// tmtest always runs with the CWD pointed to the temporary directory
-	cp = getenv(&quot;TMPDIR&quot;);
-	if(!cp) cp = &quot;/tmp&quot;;
-	if(chdir(cp) != 0) {
-		fprintf(stderr, &quot;Could not chdir 2 to %s: %s\n&quot;, cp, strerror(errno));
-		exit(initialization_error);
-	}
-}
-
-
-void set_config_file(const char *cfg)
-{
-	char cwd[PATH_MAX];
-	char out[PATH_MAX];
-	char *path;
-
-	if(!getcwd(cwd, PATH_MAX)) {
-		perror(&quot;Couldn't get current working directory&quot;);
-		exit(runtime_error);
-	}
-
-	path = rel2abs(cfg, cwd, out, PATH_MAX);
-	if(!path) {
-		fprintf(stderr, &quot;Got %d figuring out absolute path for \&quot;%s\&quot;: %s&quot;,
-				errno, cfg, strerror(errno));
-		exit(runtime_error);
-	}
-
-	config_file = strdup(out);
-	if(!config_file) {
-		perror(&quot;strdup&quot;);
-		exit(runtime_error);
-	}
-}
-
-
-void usage()
-{
-	printf(
-			&quot;Usage: tmtest [OPTION]... [DLDIR]\n&quot;
-			&quot;  -o: output the test file with the new output.\n&quot;
-			&quot;  -d: output a diff between the expected and actual outputs.\n&quot;
-			&quot;  -V --version: print the version of this program.\n&quot;
-			&quot;  -h --help: prints this help text\n&quot;
-			&quot;Run tmtest with no arguments to run all tests in the current directory.\n&quot;
-		  );
-}
-
-
-void process_args(int argc, char **argv)
-{
-    char buf[256], *cp;
-    int optidx, i, c;
-
-	optidx = 0;
-	static struct option longopts[] = {
-		// name, has_arg (1=reqd,2=opt), flag, val
-		{&quot;all-files&quot;, 0, &amp;allfiles, 1},
-		{&quot;config&quot;, 1, 0, 'c'},
-		{&quot;diff&quot;, 0, 0, 'd'},
-		{&quot;dump-script&quot;, 0, &amp;dumpscript, 1},
-		{&quot;help&quot;, 0, 0, 'h'},
-		{&quot;output&quot;, 0, 0, 'o'},
-		{&quot;quiet&quot;, 0, 0, 'q'},
-		{&quot;version&quot;, 0, 0, 'V'},
-		{0, 0, 0, 0},
-	};
-
-	// dynamically create the option string from the long
-	// options.  Why oh why doesn't glibc do this for us???
-	cp = buf;
-	for(i=0; longopts[i].name; i++) {
-		if(!longopts[i].flag) {
-			*cp++ = longopts[i].val;
-			if(longopts[i].has_arg &gt; 0) *cp++ = ':';
-			if(longopts[i].has_arg &gt; 1) *cp++ = ':';
-		}
-	}
-	*cp++ = '\0';
-
-	while(1) {
-		c = getopt_long(argc, argv, buf, longopts, &amp;optidx);
-		if(c == -1) break;
-
-		switch(c) {
-			case 'c':
-				set_config_file(optarg);
-				break;
-
-            case 'd':
-                outmode = outmode_diff;
-                break;
-
-			case 'h':
-				usage();
-				exit(0);
-
-			case 'o':
-                outmode = outmode_dump;
-				break;
-
-			case 'q':
-				quiet++;
-				break;
-
-			case 'V':
-				printf(&quot;tmtest version %s\n&quot;, stringify(VERSION));
-				exit(0);
-
-			case '?':
-				// getopt_long already printed the error message
-				exit(argument_error);
-
-			case 0:
-				// an option was automatically set
-				break;
-
-			default:
-				fprintf(stderr, &quot;getopt_long returned something weird: %d\n&quot;, c);
-				exit(internal_error);
-		}
-	}
-}
-
-
-int main(int argc, char **argv)
-{
-	process_args(argc, argv);
-
-    start_tests();
-    if(optind &lt; argc) {
-        process_ents(argv+optind, 1);
-    } else {
-        if(outmode == outmode_test) {
-            printf(&quot;\nProcessing .\n&quot;);
-        }
-        process_dir();
-    }
-    stop_tests();
-
-    if(outmode == outmode_test) {
-        print_test_summary();
-    }
-
-	return 0;
-}
-

Copied: releases/0.94/main.c (from rev 99, trunk/main.c)

Copied: releases/0.94/make-dist (from rev 89, trunk/make-dist)

Deleted: releases/0.94/re2c/read.c
===================================================================
--- trunk/re2c/read.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/re2c/read.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,52 +0,0 @@
-/* re2c.c
- * Scott Bronson
- * 28 Dec 2004
- */
-
-#include &lt;string.h&gt;
-#include &lt;assert.h&gt;
-#include &quot;scan.h&quot;
-
-
-
-/** Rearrange the scan buffer.  Only called by readprocs.
- *
- * This moves all in-flight data to the bottom of the buffer
- * to free up more room.
- *
- * Your readproc should read as much as it can between ss-&gt;limit
- * and ss-&gt;buf+ss-&gt;bufsiz.  It should adjust ss-&gt;limit to point
- * to the new end of data (the end of the buffer if it was able to
- * execute a complete read).
- *
- * Returns the number of bytes available to read in the buffer.
- */
-
-/* TODO: could optimize for the fast case (no data that needs
- * to be shifted).  However, there's no burning need -- it wouldn't
- * offer much speedup  Bigger buffers would help a lot more.
- * NOTE: the middle line of this macro is incomplete!  Don't use!
-
-#define read_shiftbuf(ss) (ss-&gt;token == ss-&gt;limit ? \
-    (ss-&gt;token = ss-&gt;cursor = ss-&gt;bufptr, 0) : \
-    _read_shiftbuf(ss)) 
-
- */
-
-int read_shiftbuf(scanstate *ss)
-{
-    int cnt = ss-&gt;token - ss-&gt;bufptr;
-    if(cnt) {
-        memmove((void*)ss-&gt;bufptr, ss-&gt;token, ss-&gt;limit - ss-&gt;token);
-        ss-&gt;token = ss-&gt;bufptr;
-        ss-&gt;cursor -= cnt;
-        if(ss-&gt;marker) ss-&gt;marker -= cnt;
-        ss-&gt;limit -= cnt;
-        assert(ss-&gt;limit &gt;= ss-&gt;bufptr);
-        assert(ss-&gt;cursor &gt;= ss-&gt;bufptr);
-        assert(ss-&gt;cursor &lt;= ss-&gt;limit);
-    }
-
-    return ss-&gt;bufsiz - (ss-&gt;bufptr - ss-&gt;limit);
-}
-

Copied: releases/0.94/re2c/read.c (from rev 94, trunk/re2c/read.c)

Deleted: releases/0.94/re2c/scan.h
===================================================================
--- trunk/re2c/scan.h	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/re2c/scan.h	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,311 +0,0 @@
-/* scan.h
- * Scott Bronson
- * 27 Dec 2004
- *
- * This part of support code to make writing re2c scanners much easier.
- *
- * TODO: probably want to split the re2c-specific code from the general
- * code.  This file is overall very useful, but it's got a few limitations
- * imposed by re2c that should probably be placed in its own layer.
- * That way, future versions of re2c won't have to suffer the same
- * limitations.
- */
-
-/** @file scan.h
- *
- * This is the central file for the readers.  They provide data
- * for scanners.
- *
- * TERMINOLOGY
- *
- * allocate: scanstates can be dynamically (dynamicscan_create()) or
- * statically (scanstate_init()) allocated.  The buffers they use to
- * hold data may also be either dynamic or static.  Of course, any
- * time you allocate something dynamically, you must call the
- * corresponding free routine when you're done with it.
- *
- * attach: when the scanner is first initialized (scanstate_init())
- * or allocated (dynamicscan_create()), it is blank.  Trying to
- * pass it to a scanner would result in an assert or a crash.
- * You need to first attach a READER to provide data.
- *
- * initialize: prepare an already-allocated scanner for use.
- * After initializing it, you must ATTACH the scanner to a
- * READER.
- *
- * reader: reads data into the scanstate for the scanner.
- * Examples are readmem.c (read from a contiguous block in
- * memory), readfp.c (read from a FILE*), readfd.c (read
- * from a Unix file descriptor), etc.
- *
- * scanner: the function that actually performs the scanning.
- * It may or may not be written with the assistance of re2c.
- * It accepts a scanstate data structure and returns the next
- * token in the stream.
- *
- * scanstate: the data structure that retains complete state for the
- * scanner.  Scanners are thread safe: they never, ever use global
- * state.
- */
-
-
-#ifndef R2SCAN_H
-#define R2SCAN_H
-
-
-// for re2c...
-#define YYCTYPE     char
-#define YYCURSOR    (ss-&gt;cursor)
-#define YYLIMIT     (ss-&gt;limit)
-#define YYMARKER    (ss-&gt;marker)
-
-/** Fills the scan buffer with more data.
- *
- * This routine needs to force a return if 0 bytes were read because
- * otherwise the re2c scanner will end up scanning garbage way off
- * the end of the buffer.  There's no (good) way to tell the scanner
- * &quot;the file is at eof so just finish the token that you're on&quot; (right?).
- * It will always lose the token at the end of the file unless the file
- * ends in a token delimiter (usually a newline).
- *
- * We ignore n because there can be less than n bytes left in the file,
- * yet one or more tokens will still match.  Therefore, we should always
- * read as much data as we can, and we should return success even if we
- * have less than n bytes in the buffer.  N is totally useless.
- *
- * The last line is the limitation.  If it weren't there, YYFILL would
- * return with an empty buffer so re2c would know it's at EOF and
- * shut down gracefully.  But re2c can't handle that.
- *
- * If you're using the re2c lib but writing your own re2c scanners,
- * call ss-&gt;read directly.
- */
-
-#define YYFILL(n)   do { \
-		int r = (*ss-&gt;read)(ss); \
-		if(r &lt; 0) return r; \
-		if((ss)-&gt;cursor &gt;= (ss)-&gt;limit) return 0; \
-	} while(0);
-
-
-// forward declaration
-struct scanstate;
-
-
-/** Prototype of read function
- *
- * You only need to know this if you're writing your own read functions.
- *
- * This function is used to fetch more data for the scanner.  It must
- * first shift the pointers in ss to make room (see read_shiftbuffer())
- * then load new data into the unused bytes at the end of the buffer.
- *
- * I chose the shift technique over a ringbuffer because we should rarely
- * have to shift data.  If you find that your file has gigantic tokens
- * and you're burning a lot of cpu shifting partial tokens from the end
- * of the buffer to the start, you might want to use a ring buffer instead
- * of a shift buffer.  However, re2c itself can't handle ringbuffers or
- * split tokens (nor can most scanners that I'm aware of), so shift
- * buffers are the best we can do.
- *
- * This routine returns 0 when there's no more data (EOF).
- * If it returns a value less than 0, that value will be returned
- * to the caller instead of a token.  This can indicate an error
- * condition, or just a situation such as EWOULDBLOCK.
- *
- * Because of the way re2c handles buffering, it's possible for the
- * read routine to be called multiple times after it has returned eof.
- * This isn't an error.  If your read routine is called when
- * ss-&gt;at_eof is true, you should just return without doing anything.
- *
- * All charptrs in the scanstate structure are declared const to help
- * ensure that you don't
- * accidentally end up modifying the buffer as it's being scanned.
- * This means that your read routine must cast them to be mutable
- * (char*) before reading them.  Only the readproc should modify the
- * data that's in the scan buffer.
- *
- * The caller assumes that the read routine will always fill the buffer
- * up as much as possible.  Therefore, if the buffer isn't entirely full,
- * then it knows that the EOF is probably at the end of the data.  This
- * is a fine assumption for files but not so good for pipes, network
- * sockets, anything that is packetized or works in realtime.  It would
- * take a rewrite of re2c to remove this limitation. So, yes, your
- * scanner can assume that the read routine will always fill the buffer
- * up as much as it possibly can.
- */
-
-typedef int (*readproc)(struct scanstate *ss);
-
-
-/** Prototype of scanner function
- *
- * A scanner is simply a function that accepts a scanstate
- * object and returns the next token in that stream.
- * The function will typically be generated with the
- * assistance of re2c, but it doesn't have to be!
- *
- * Once you have created the scanstate data structure,
- * pass it to the scanner.  If the scanner returns 0,
- * you hit EOF.  If the scanner returns a negative number,
- * then some sort of error was encountered.  Or, if you're
- * doing nonblocking I/O, then it just might mean that this
- * there's not enough data available to determine the next
- * token.
- */
-
-typedef int (*scanproc)(struct scanstate *ss);
-
-
-
-/** Represents the current state for a single scanner.
- *
- * This structure is used by a scanner to preserve its state.
- *
- * All charptrs are declared const to help ensure that you don't
- * accidentally end up modifying the buffer as it's being scanned.
- * This means that any time you want to read the buffer, you need
- * to cast the pointers to be nonconst.
- */
-
-struct scanstate {
-    const char *cursor; ///&lt; The current character being looked at by the scanner
-    const char *limit;  ///&lt; The last valid character in the current buffer.  If the previous read was short, then this will not point to the end of the actual buffer (bufptr + bufsiz).
-    const char *marker; ///&lt; Used internally by re2c engine to handle backtracking.
-
-    // (these do a poor job of simulating capturing parens)
-    const char *token;  ///&lt; The start of the current token (manually updated by the scanner).
-    int line;           ///&lt; The scanner may or may not maintain the current line number in this field.
-    int at_eof;         ///&lt; You almost certainly don't want to be using this (unless you're writing a readproc).  Use scan_finished() instead.  This field gets set when the readproc realizes it has hit eof.  by convention 1 means eof, 2 means yes, at_eof is true, but because of an unrecoverable read error (todo: this should be formalized).
-
-    const char *bufptr; ///&lt; The buffer currently in use
-    int bufsiz;         ///&lt; The maximum number of bytes that the buffer can hold
-
-    void *readref;      ///&lt; Data specific to the reader (i.e. for readfp_attach() it's a FILE*).
-    readproc read;      ///&lt; The routine the scanner calls when the buffer needs to be reread.
-
-    void *scanref;      ///&lt; Data specific to the scanner
-    scanproc state;     ///&lt; The entrypoint for the scanning routine.  The name is now anachronistic but might still fit (some scanners are made up of multiple individual scan routines -- they store their state here).
-
-    void *userref;      ///&lt; Never touched by any of our routines (except scanstate_init, which clears both fields).  This can be used to associate a parser with this scanner.
-    void *userproc;     ///&lt; That's just a suggestion though.  These fields are totally under your control.
-};
-typedef struct scanstate scanstate;
-
-
-void scanstate_init(scanstate *ss, const char *bufptr, int bufsiz);
-void scanstate_reset(scanstate *ss);
-
-
-/** Returns true when there's no more data to be scanned.
- *
- * How what this macro does:
- *
- * If there's still more data in the buffer, then we're not finished.
- * If there's no data in the buffer and we're at EOF, then we're finished.
- * If there's no data in the buffer but we're not at eof, then we need
- * to execute a read to see if there's more data available.  If so, we're
- * not finished.  Otherwise, we're all done.
- */
-
-#define scan_finished(ss) \
-    (((ss)-&gt;cursor &lt; (ss)-&gt;limit) ? 0 : \
-		 ((ss)-&gt;at_eof || ((*(ss)-&gt;read)(ss) &lt;= 0)) \
-    )
-
-
-/** Fetches the next token in the stream from the scanner.
- */
-
-#define scan_token(ss) ((*((ss)-&gt;state))(ss))
-#define scan_next_token(ss) ((*((ss)-&gt;state))(ss))
-
-
-/** Returns a pointer to the first character of the
- *  most recently scanned token.
- */
-
-#define token_start(ss) ((ss)-&gt;token)
-#define current_token_start(ss) ((ss)-&gt;token)
-
-/** Returns a pointer to one past the last character of the
- *  most recently scanned token.
- *
- *  token_end(ss) - token_start(ss) == token_length(ss)
- */
-
-#define token_end(ss) ((ss)-&gt;cursor)
-#define current_token_end(ss) ((ss)-&gt;cursor)
-
-/** Returns the length of the most recently scanned token.
- */
-
-#define token_length(ss) ((ss)-&gt;cursor - (ss)-&gt;token)
-#define current_token_length(ss) ((ss)-&gt;cursor - (ss)-&gt;token)
-
-/** Returns the current token in a malloc'd buffer.
- * (just calls strdup(3) internally).
- */
-
-#define token_dup(ss) strndup(token_start(ss), token_length(ss))
-#define current_token_dup(ss) token_dup(ss)
-
-
-/** Pushes the current token back onto the stream
- *
- * Calling scan_pushback returns the scanner to the state it had
- * just before returning the current token.  If you decide that
- * you don't want to handle this token, you can push it back and
- * it will be returned again the next time scan_token() is called.
- *
- * Note that this only works once.  You cannot push multiple tokens back
- * into the scanner.  Also, the scanner may have internal state of its
- * own that does not get reset.  If so, the scanner may or may not provide
- * a routine to back its internal state up as well.  Beware!!
- *
- * Finally, this doesn't back the line number up.  If you're pushing
- * a token back and you care about having the correct line nubmer,
- * then you'll have to manually restore the line number to what it
- * was before you scanned the token that you're pushing back.
- *
- * i.e.
- *
- *     // First ensure that the scanner you're using doesn't
- *     // have internal state that will be screwed up if you
- *     // re-scan the current token!
- *
- *     oldline = ss-&gt;line;
- *     tok = scan_token(ss);
- *     if(tok == push_me_back) {
- *         scan_pushback(ss);
- *         ss-&gt;line = oldline;
- *     }
- *
- * Yes, it takes some effort to call this function safely.
- * But it can be worth it when you need it.
- */
-
-#define scan_pushback(ss) ((ss)-&gt;cursor = (ss)-&gt;token)
-
-
-/** Sets the current line number in the scanner to the given value.
- */
-
-#define scan_set_line(ss,n) (ss-&gt;line=(n));
-
-
-/** Increments the current line number by 1.
- */
-
-#define scan_inc_line(ss)   (ss-&gt;line++);
-
-
-/**
- * Prepares the scanner to scan a new token.
- * This should be called at the beginning of every scanproc.
- */
-
-#define scanner_enter(ss) ((ss)-&gt;token = (ss)-&gt;cursor)
-
-#endif
-

Copied: releases/0.94/re2c/scan.h (from rev 93, trunk/re2c/scan.h)

Deleted: releases/0.94/stscan.c
===================================================================
--- trunk/stscan.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/stscan.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,446 +0,0 @@
-/* Generated by re2c 0.9.10 on Mon Feb 27 18:07:08 2006 */
-
-/* stscan.re
- * Scott Bronson
- *
- * This file is covered by the MIT license.
- *
- * Scanner for status files files.
- * This file needs to be processed by re2c, <A HREF="http://re2c.org">http://re2c.org</A>
- */
-
-#include &quot;stscan.h&quot;
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a recognized token, it returns that token with the text
- * of the entire line.  Otherwise, it returns stGARBAGE.
- *
- * Note that this scanner only returns complete lines.  If the file
- * doesn't end with a newline, then the last line will be lost.
- * I think.
- */
-
-int stscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    scan_inc_line(ss);
-
-
-
-{
-	YYCTYPE yych;
-	goto yy0;
-	++YYCURSOR;
-yy0:
-	if((YYLIMIT - YYCURSOR) &lt; 8) YYFILL(8);
-	yych = *YYCURSOR;
-	switch(yych){
-	case 0x0A:	goto yy10;
-	case 'A':	goto yy7;
-	case 'C':	goto yy3;
-	case 'D':	goto yy6;
-	case 'P':	goto yy4;
-	case 'R':	goto yy5;
-	case 'S':	goto yy2;
-	default:	goto yy8;
-	}
-yy2:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy77;
-	default:	goto yy9;
-	}
-yy3:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy67;
-	default:	goto yy9;
-	}
-yy4:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy55;
-	default:	goto yy9;
-	}
-yy5:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy44;
-	default:	goto yy9;
-	}
-yy6:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy23;
-	case 'O':	goto yy24;
-	default:	goto yy9;
-	}
-yy7:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'B':	goto yy12;
-	default:	goto yy9;
-	}
-yy8:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy9;
-yy9:	switch(yych){
-	case 0x0A:	goto yy10;
-	default:	goto yy8;
-	}
-yy10:	++YYCURSOR;
-	goto yy11;
-yy11:
-
-{ return stGARBAGE; }
-
-yy12:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy13;
-	default:	goto yy9;
-	}
-yy13:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy14;
-	default:	goto yy9;
-	}
-yy14:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy15;
-	default:	goto yy9;
-	}
-yy15:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy16;
-	default:	goto yy9;
-	}
-yy16:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy17;
-	default:	goto yy9;
-	}
-yy17:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy18;
-yy18:	switch(yych){
-	case 0x09:	case ' ':	goto yy17;
-	case 0x0A:	goto yy10;
-	case ':':	goto yy19;
-	default:	goto yy8;
-	}
-yy19:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy20;
-yy20:	switch(yych){
-	case 0x0A:	goto yy21;
-	default:	goto yy19;
-	}
-yy21:	++YYCURSOR;
-	goto yy22;
-yy22:
-
-{ return stABORTED; }
-
-yy23:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'S':	goto yy33;
-	default:	goto yy9;
-	}
-yy24:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy25;
-	default:	goto yy9;
-	}
-yy25:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy26;
-	default:	goto yy9;
-	}
-yy26:	yych = *++YYCURSOR;
-	switch(yych){
-	case 0x09:	case ' ':	goto yy29;
-	case 0x0A:	goto yy27;
-	default:	goto yy8;
-	}
-yy27:	++YYCURSOR;
-	goto yy28;
-yy28:
-
-{ return stDONE; }
-
-yy29:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy30;
-yy30:	switch(yych){
-	case 0x09:	case ' ':	goto yy29;
-	case 0x0A:	goto yy27;
-	default:	goto yy31;
-	}
-yy31:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy32;
-yy32:	switch(yych){
-	case 0x0A:	goto yy27;
-	default:	goto yy31;
-	}
-yy33:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy34;
-	default:	goto yy9;
-	}
-yy34:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'B':	goto yy35;
-	default:	goto yy9;
-	}
-yy35:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'L':	goto yy36;
-	default:	goto yy9;
-	}
-yy36:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy37;
-	default:	goto yy9;
-	}
-yy37:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy38;
-	default:	goto yy9;
-	}
-yy38:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy39;
-yy39:	switch(yych){
-	case 0x09:	case ' ':	goto yy38;
-	case 0x0A:	goto yy10;
-	case ':':	goto yy40;
-	default:	goto yy8;
-	}
-yy40:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy41;
-yy41:	switch(yych){
-	case 0x0A:	goto yy42;
-	default:	goto yy40;
-	}
-yy42:	++YYCURSOR;
-	goto yy43;
-yy43:
-
-{ return stDISABLED; }
-
-yy44:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy45;
-	default:	goto yy9;
-	}
-yy45:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy46;
-	default:	goto yy9;
-	}
-yy46:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy47;
-	default:	goto yy9;
-	}
-yy47:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy48;
-	default:	goto yy9;
-	}
-yy48:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'G':	goto yy49;
-	default:	goto yy9;
-	}
-yy49:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy50;
-yy50:	switch(yych){
-	case 0x09:	case ' ':	goto yy49;
-	case 0x0A:	goto yy10;
-	case ':':	goto yy51;
-	default:	goto yy8;
-	}
-yy51:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy52;
-yy52:	switch(yych){
-	case 0x0A:	goto yy53;
-	default:	goto yy51;
-	}
-yy53:	++YYCURSOR;
-	goto yy54;
-yy54:
-
-{ return stRUNNING; }
-
-yy55:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy56;
-	default:	goto yy9;
-	}
-yy56:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'P':	goto yy57;
-	default:	goto yy9;
-	}
-yy57:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy58;
-	default:	goto yy9;
-	}
-yy58:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy59;
-	default:	goto yy9;
-	}
-yy59:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy60;
-	default:	goto yy9;
-	}
-yy60:	yych = *++YYCURSOR;
-	switch(yych){
-	case 0x09:	case ' ':	goto yy63;
-	case 0x0A:	goto yy61;
-	default:	goto yy8;
-	}
-yy61:	++YYCURSOR;
-	goto yy62;
-yy62:
-
-{ return stPREPARE; }
-
-yy63:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy64;
-yy64:	switch(yych){
-	case 0x09:	case ' ':	goto yy63;
-	case 0x0A:	goto yy61;
-	default:	goto yy65;
-	}
-yy65:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy66;
-yy66:	switch(yych){
-	case 0x0A:	goto yy61;
-	default:	goto yy65;
-	}
-yy67:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy68;
-	default:	goto yy9;
-	}
-yy68:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'F':	goto yy69;
-	default:	goto yy9;
-	}
-yy69:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy70;
-	default:	goto yy9;
-	}
-yy70:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'G':	goto yy71;
-	default:	goto yy9;
-	}
-yy71:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy72;
-yy72:	switch(yych){
-	case 0x09:	case ' ':	goto yy71;
-	case 0x0A:	goto yy10;
-	case ':':	goto yy73;
-	default:	goto yy8;
-	}
-yy73:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy74;
-yy74:	switch(yych){
-	case 0x0A:	goto yy75;
-	default:	goto yy73;
-	}
-yy75:	++YYCURSOR;
-	goto yy76;
-yy76:
-
-{ return stCONFIG; }
-
-yy77:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy78;
-	default:	goto yy9;
-	}
-yy78:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy79;
-	default:	goto yy9;
-	}
-yy79:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy80;
-	default:	goto yy9;
-	}
-yy80:	yych = *++YYCURSOR;
-	switch(yych){
-	case 0x09:	case ' ':	goto yy83;
-	case 0x0A:	goto yy81;
-	default:	goto yy8;
-	}
-yy81:	++YYCURSOR;
-	goto yy82;
-yy82:
-
-{ return stSTART; }
-
-yy83:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy84;
-yy84:	switch(yych){
-	case 0x09:	case ' ':	goto yy83;
-	case 0x0A:	goto yy81;
-	default:	goto yy85;
-	}
-yy85:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy86;
-yy86:	switch(yych){
-	case 0x0A:	goto yy81;
-	default:	goto yy85;
-	}
-}
-
-
-}
-
-
-/** Prepares the given scanner to scan a status file.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* stscan_attach(scanstate *ss)
-{
-    if(ss) {
-        ss-&gt;state = stscan_start;
-    }
-
-    return ss;
-}
-

Copied: releases/0.94/stscan.c (from rev 89, trunk/stscan.c)

Deleted: releases/0.94/template.sh
===================================================================
--- trunk/template.sh	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/template.sh	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,38 +0,0 @@
-echo START &gt;&amp;%(STATUSFD)
-
-ABORT ()  { echo &quot;ABORTED: $*&quot; &gt;&amp;%(STATUSFD); exit 0; }
-ABORT: () { ABORT $*; }
-
-ATEXIT ()  { echo &quot;ATEXIT: $*&quot; &gt;&amp;%(STATUSFD); }
-ATEXIT: () { ATEXIT $*; }
-
-DISABLED  () { echo &quot;DISABLED: $*&quot; &gt;&amp;%(STATUSFD); exit 0; }
-DISABLED: () { DISABLED $*; }
-DISABLE   () { DISABLED $*; }
-DISABLE:  () { DISABLED $*; }
-
-TESTDIR='%(TESTDIR)'
-TESTFILE='%(TESTFILE)'
-
-%(CONFIG_FILES)
-
-echo PREPARE &gt;&amp;%(STATUSFD)
-
-STDOUT () { exit 0; }
-STDOUT: () { exit 0; }
-STDERR () { exit 0; }
-STDERR: () { exit 0; }
-RESULT () { exit 0; }
-RESULT: () { exit 0; }
-MODIFY () { exit 0; }
-MODIFY: () { exit 0; }
-
-echo 'RUNNING: %(TESTFILE)' &gt;&amp;%(STATUSFD)
-MYDIR='%(TESTDIR)'
-MYFILE='%(TESTFILE)'
-exec &gt;&amp;%(OUTFD) 2&gt;&amp;%(ERRFD)
-exec %(OUTFD)&gt;&amp;-
-exec %(ERRFD)&gt;&amp;-
-%(TESTEXEC)
-
-echo DONE &gt;&amp;%(STATUSFD)

Copied: releases/0.94/template.sh (from rev 100, trunk/template.sh)

Copied: releases/0.94/test/00-cmdline/10-CfgDir.test (from rev 99, trunk/test/00-cmdline/10-CfgDir.test)

Copied: releases/0.94/test/00-cmdline/11-CfgMissing.test (from rev 99, trunk/test/00-cmdline/11-CfgMissing.test)

Copied: releases/0.94/test/00-cmdline/12-CfgEmpty.test (from rev 99, trunk/test/00-cmdline/12-CfgEmpty.test)

Copied: releases/0.94/test/01-testfile/02-StdOutNK.test (from rev 99, trunk/test/01-testfile/02-StdOutNK.test)

Copied: releases/0.94/test/01-testfile/03-StdErrNK.test (from rev 99, trunk/test/01-testfile/03-StdErrNK.test)

Deleted: releases/0.94/test/01-testfile/08-GarbageInStdout.test
===================================================================
--- trunk/test/01-testfile/08-GarbageInStdout.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/01-testfile/08-GarbageInStdout.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,16 +0,0 @@
-# Scott Bronson
-# 26 Feb 2006
-#
-# Ensures that we recognize when the stdout clause contains garbage.
-
-tmtest -q - &lt;&lt;-EOL
-    echo crapola
-	STDOUT: crapola
-    crapola
-EOL
-STDERR:
-(STDIN) line 2: unknown arguments &quot;crapola&quot;
-STDOUT:
-FAIL (STDIN)                   O..  stdout differed
-
-1 test run, 0 successes, 1 failure.

Copied: releases/0.94/test/01-testfile/08-GarbageInStdout.test (from rev 99, trunk/test/01-testfile/08-GarbageInStdout.test)

Deleted: releases/0.94/test/01-testfile/10-DumpScript.test
===================================================================
--- trunk/test/01-testfile/10-DumpScript.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/01-testfile/10-DumpScript.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,59 +0,0 @@
-# Ensures that the dumpscript is what we expect.
-# This is just so we don't surprise ourselves...  Any time you modify
-# template.sh, you should expect test to fail.
-
-tmtest $args --dump-script - &lt;&lt;-EOL
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 2
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 3
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 4
-EOL
-
-MODIFY:
-  s/DATE='.*'/Date='BLAH BLAH'/
-  s/^(.)/	$1/
-
-STDOUT:
-	echo START &gt;&amp;7
-
-	ABORT ()  { echo &quot;ABORTED: $*&quot; &gt;&amp;7; exit 0; }
-	ABORT: () { ABORT $*; }
-
-	ATEXIT ()  { echo &quot;ATEXIT: $*&quot; &gt;&amp;7; }
-	ATEXIT: () { ATEXIT $*; }
-
-	DISABLED  () { echo &quot;DISABLED: $*&quot; &gt;&amp;7; exit 0; }
-	DISABLED: () { DISABLED $*; }
-	DISABLE   () { DISABLED $*; }
-	DISABLE:  () { DISABLED $*; }
-
-	TESTDIR='/tmp'
-	TESTFILE='/tmp/-'
-
-
-
-	echo PREPARE &gt;&amp;7
-
-	STDOUT () { exit 0; }
-	STDOUT: () { exit 0; }
-	STDERR () { exit 0; }
-	STDERR: () { exit 0; }
-	RESULT () { exit 0; }
-	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
-
-	echo 'RUNNING: /tmp/-' &gt;&amp;7
-	MYDIR='/tmp'
-	MYFILE='/tmp/-'
-	exec &gt;&amp;3 2&gt;&amp;5
-	exec 3&gt;&amp;-
-	exec 5&gt;&amp;-
-	LINENO=0
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 2
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 3
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 4
-
-
-	echo DONE &gt;&amp;7

Copied: releases/0.94/test/01-testfile/10-DumpScript.test (from rev 100, trunk/test/01-testfile/10-DumpScript.test)

Copied: releases/0.94/test/01-testfile/11-InnerConfig.test (from rev 99, trunk/test/01-testfile/11-InnerConfig.test)

Copied: releases/0.94/test/01-testfile/20-TestVars.test (from rev 99, trunk/test/01-testfile/20-TestVars.test)

Copied: releases/0.94/test/01-testfile/21-TestVarsABS.test (from rev 99, trunk/test/01-testfile/21-TestVarsABS.test)

Copied: releases/0.94/test/01-testfile/22-TestVarsRel.test (from rev 99, trunk/test/01-testfile/22-TestVarsRel.test)

Deleted: releases/0.94/test/02-running/21-QuoteFile.test
===================================================================
--- trunk/test/02-running/21-QuoteFile.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/02-running/21-QuoteFile.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,31 +0,0 @@
-# Ensures that a test disabled by a config file doesn't run.
-
-MKDIR dir
-cd &quot;$dir&quot;
-
-cat &gt; &quot;vl'hurg.test&quot; &lt;&lt;-EOs
-	echo hi
-	STDOUT:
-	hi
-EOs
-
-cat &gt; '12&quot;.test' &lt;&lt;-EOs
-	echo hi
-	STDOUT:
-	hi
-EOs
-
-tmtest $CFG -q
-rm &quot;vl'hurg.test&quot; '12&quot;.test'
-
-
-MODIFY:
-  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
-STDOUT:
-
-Processing .
-
-0 tests run, 0 successes, 0 failures.
-STDERR:
-12&quot;.test was skipped because its file name contains a quote character.
-vl'hurg.test was skipped because its file name contains a quote character.

Copied: releases/0.94/test/02-running/21-QuoteFile.test (from rev 99, trunk/test/02-running/21-QuoteFile.test)

Copied: releases/0.94/test/02-running/22-Signal.test (from rev 92, trunk/test/02-running/22-Signal.test)

Copied: releases/0.94/test/02-running/40-Replace.test (from rev 99, trunk/test/02-running/40-Replace.test)

Copied: releases/0.94/test/02-running/41-Indent.test (from rev 99, trunk/test/02-running/41-Indent.test)

Copied: releases/0.94/test/03-results/01-YstderrOut.test (from rev 99, trunk/test/03-results/01-YstderrOut.test)

Copied: releases/0.94/test/03-results/01-YstdoutOut.test (from rev 99, trunk/test/03-results/01-YstdoutOut.test)

Copied: releases/0.94/test/03-results/14-NoNLWarn.test (from rev 99, trunk/test/03-results/14-NoNLWarn.test)

Copied: releases/0.94/test/03-results/15-EmptyWithErr.test (from rev 98, trunk/test/03-results/15-EmptyWithErr.test)

Copied: releases/0.94/test/03-results/15-EmptyWithOut.test (from rev 98, trunk/test/03-results/15-EmptyWithOut.test)

Copied: releases/0.94/test/03-results/16-EmptyWithErrNoNL.test (from rev 98, trunk/test/03-results/16-EmptyWithErrNoNL.test)

Copied: releases/0.94/test/03-results/16-EmptyWithOutNoNL.test (from rev 98, trunk/test/03-results/16-EmptyWithOutNoNL.test)

Copied: releases/0.94/test/03-results/17-NoStderr.test (from rev 99, trunk/test/03-results/17-NoStderr.test)

Copied: releases/0.94/test/03-results/18-NoNLWarnOut.test (from rev 99, trunk/test/03-results/18-NoNLWarnOut.test)

Copied: releases/0.94/test/03-results/30-Binary.test (from rev 95, trunk/test/03-results/30-Binary.test)

Copied: releases/0.94/test/03-results/31-BinaryFail.test (from rev 95, trunk/test/03-results/31-BinaryFail.test)

Copied: releases/0.94/test/03-results/32-BinaryLarge.test (from rev 95, trunk/test/03-results/32-BinaryLarge.test)

Copied: releases/0.94/test/03-results/33-BinaryHuge.test (from rev 99, trunk/test/03-results/33-BinaryHuge.test)

Deleted: releases/0.94/test/04-diff/01-Diff.test
===================================================================
--- trunk/test/04-diff/01-Diff.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/01-Diff.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,30 +0,0 @@
-# Diff
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d
-
-# updated for 2.0 on 27 Jan 2005
-
-
-tmtest -d - &lt;&lt;-EOL
-    echo &quot;right output&quot;
-    STDOUT:
-    wrong output
-EOL
-
-
-MODIFY:
-    s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-    s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,5 @@
-     echo &quot;right output&quot;
-     STDOUT:
-     wrong output
-+STDOUT:
-+right output

Copied: releases/0.94/test/04-diff/01-Diff.test (from rev 99, trunk/test/04-diff/01-Diff.test)

Deleted: releases/0.94/test/04-diff/02-MultiDiff.test
===================================================================
--- trunk/test/04-diff/02-MultiDiff.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/02-MultiDiff.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,42 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests that diff works on multiple files (tmtest -d file1 file2)
-# updated for 2.0 on 29 Jan 2005
-
-
-
-MKFILE t1 &lt;&lt;-EOF
-	echo &quot;test 1 right output&quot;
-	STDOUT:
-	test 1 wrong output
-EOF
-
-MKFILE t2 &lt;&lt;-EOF
-	echo &quot;test 2 right output&quot;
-	STDOUT:
-	test 2 wrong output
-EOF
-
-tmtest --all-files -d &quot;$t1&quot; &quot;$t2&quot;
-
-
-MODIFY:
-  s/^\-\-\-.*\/tmp\/tmtest.*/--- \/tmp\/testfile DATE TIME TZ/,
-  s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-STDOUT:
---- /tmp/testfile DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo &quot;test 1 right output&quot;
- STDOUT:
--test 1 wrong output
-+test 1 right output
---- /tmp/testfile DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo &quot;test 2 right output&quot;
- STDOUT:
--test 2 wrong output
-+test 2 right output

Copied: releases/0.94/test/04-diff/02-MultiDiff.test (from rev 99, trunk/test/04-diff/02-MultiDiff.test)

Deleted: releases/0.94/test/04-diff/05-AbortDiff.test
===================================================================
--- trunk/test/04-diff/05-AbortDiff.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/05-AbortDiff.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,30 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a diff is aborted.
-
-
-
-tmtest -d - &lt;&lt;-EOL
-	ABORT
-	echo &quot;right output&quot;
-	STDOUT:
-	right output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,4 +1,2 @@
- ABORT
- echo &quot;right output&quot;
--STDOUT:
--right output
-STDERR:
-ERROR Test was aborted

Copied: releases/0.94/test/04-diff/05-AbortDiff.test (from rev 99, trunk/test/04-diff/05-AbortDiff.test)

Deleted: releases/0.94/test/04-diff/09-MultiLevelDiff.test
===================================================================
--- trunk/test/04-diff/09-MultiLevelDiff.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/09-MultiLevelDiff.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,101 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d | patch -p0 in a hierarchy
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-# tt/t.test
-# tt/one/t.test
-# tt/two/t1.test
-# tt/two/t2.test
-# tt/two/one/t.test
-
-
-. &quot;$MYDIR/indent.sh&quot;
-
-
-MKDIR tt
-cd &quot;$tt&quot; || ABORT &quot;Could not cd to $tt&quot;
-
-cat &gt; t.test &lt;&lt;-EOL
-	echo &quot;right output1&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir one
-cat &gt; one/t.test &lt;&lt;-EOL
-	echo &quot;right output2&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two
-cat &gt; two/t1.test &lt;&lt;-EOL
-	echo &quot;right output3&quot;
-	STDOUT:
-	wrong output
-EOL
-
-cat &gt; two/t2.test &lt;&lt;-EOL
-	echo &quot;right output4&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two/one
-cat &gt; two/one/t.test &lt;&lt;-EOL
-	echo &quot;right output5&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-tmtest --all-files -d
-
-rm -rf t.test one two
-
-
-MODIFY:
-  s/^\-\-\- .*/--- TESTFILE DATE TIME TZ/,
-  s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-STDOUT:
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo &quot;right output1&quot;
- STDOUT:
--wrong output
-+right output1
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo &quot;right output2&quot;
- STDOUT:
--wrong output
-+right output2
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo &quot;right output3&quot;
- STDOUT:
--wrong output
-+right output3
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo &quot;right output4&quot;
- STDOUT:
--wrong output
-+right output4
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo &quot;right output5&quot;
- STDOUT:
--wrong output
-+right output5

Copied: releases/0.94/test/04-diff/09-MultiLevelDiff.test (from rev 89, trunk/test/04-diff/09-MultiLevelDiff.test)

Deleted: releases/0.94/test/04-diff/10-Patch.test
===================================================================
--- trunk/test/04-diff/10-Patch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/10-Patch.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,34 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d | patch
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-. &quot;$MYDIR/indent.sh&quot;
-
-
-MKFILE tt &lt;&lt;-EOL
-	echo &quot;right output&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-# This is a little exotic...  Patch needs the CWD to be the directory
-# containing the file to patch.  &quot;dirname $(tt.test)&quot; gives that dir.
-
-tmtest --all-files -d &quot;$tt&quot; | (cd `dirname &quot;$tt&quot;` &amp;&amp; patch)
-echo &quot;And the patched file:&quot;
-echo
-INDENT &lt; &quot;$tt&quot;
-
-MODIFY:
-  s/^patching .*/patching FILE/
-
-STDOUT:
-patching FILE
-And the patched file:
-
-	echo &quot;right output&quot;
-	STDOUT:
-	right output

Copied: releases/0.94/test/04-diff/10-Patch.test (from rev 89, trunk/test/04-diff/10-Patch.test)

Deleted: releases/0.94/test/04-diff/11-MultiPatch.test
===================================================================
--- trunk/test/04-diff/11-MultiPatch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/11-MultiPatch.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,57 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d | patch
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-. &quot;$MYDIR/indent.sh&quot;
-
-
-MKFILE tt1 &lt;&lt;-EOL
-	echo &quot;right output1&quot;
-	STDOUT:
-	wrong output
-EOL
-
-MKFILE tt2 &lt;&lt;-EOL
-	echo &quot;right output2&quot;
-	STDOUT:
-	wrong output
-EOL
-
-MKFILE tt3 &lt;&lt;-EOL
-	echo &quot;right output3&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-# All tt* files must be in the same directory.
-
-tmtest --all-files -d &quot;$tt1&quot; &quot;$tt2&quot; &quot;$tt3&quot; | (cd `dirname &quot;$tt1&quot;` &amp;&amp; patch)
-echo
-INDENT &lt; &quot;$tt1&quot;
-echo
-INDENT &lt; &quot;$tt2&quot;
-echo
-INDENT &lt; &quot;$tt3&quot;
-
-MODIFY:
-  s/^patching .*/patching FILE/
-
-STDOUT:
-patching FILE
-patching FILE
-patching FILE
-
-	echo &quot;right output1&quot;
-	STDOUT:
-	right output1
-
-	echo &quot;right output2&quot;
-	STDOUT:
-	right output2
-
-	echo &quot;right output3&quot;
-	STDOUT:
-	right output3

Copied: releases/0.94/test/04-diff/11-MultiPatch.test (from rev 89, trunk/test/04-diff/11-MultiPatch.test)

Deleted: releases/0.94/test/04-diff/12-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/12-MultiLevelPatch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/12-MultiLevelPatch.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,100 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d | patch -p0 in a hierarchy
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-# tt/t.test
-# tt/one/t.test
-# tt/two/t1.test
-# tt/two/t2.test
-# tt/two/one/t.test
-
-
-. &quot;$MYDIR/indent.sh&quot;
-
-
-MKDIR tt
-cd &quot;$tt&quot; || ABORT &quot;Could not cd to $tt&quot;
-
-cat &gt; t.test &lt;&lt;-EOL
-	echo &quot;right output1&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir one
-cat &gt; one/t.test &lt;&lt;-EOL
-	echo &quot;right output2&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two
-cat &gt; two/t1.test &lt;&lt;-EOL
-	echo &quot;right output3&quot;
-	STDOUT:
-	wrong output
-EOL
-
-cat &gt; two/t2.test &lt;&lt;-EOL
-	echo &quot;right output4&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two/one
-cat &gt; two/one/t.test &lt;&lt;-EOL
-	echo &quot;right output5&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-tmtest --all-files -d | patch -p0
-echo
-INDENT &lt; t.test
-echo
-INDENT &lt; one/t.test
-echo
-INDENT &lt; two/t1.test
-echo
-INDENT &lt; two/t2.test
-echo
-INDENT &lt; two/one/t.test
-
-rm -rf t.test one two
-
-
-MODIFY:
-  s/^patching .*/patching FILE/
-
-STDOUT:
-patching FILE
-patching FILE
-patching FILE
-patching FILE
-patching FILE
-
-	echo &quot;right output1&quot;
-	STDOUT:
-	right output1
-
-	echo &quot;right output2&quot;
-	STDOUT:
-	right output2
-
-	echo &quot;right output3&quot;
-	STDOUT:
-	right output3
-
-	echo &quot;right output4&quot;
-	STDOUT:
-	right output4
-
-	echo &quot;right output5&quot;
-	STDOUT:
-	right output5

Copied: releases/0.94/test/04-diff/12-MultiLevelPatch.test (from rev 89, trunk/test/04-diff/12-MultiLevelPatch.test)

Deleted: releases/0.94/test/04-diff/13-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/13-MultiLevelPatch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/13-MultiLevelPatch.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,101 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Same as 12-MultiLevelPatch.test except that it tests ..
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-# tt/t.test
-# tt/one/t.test
-# tt/two/t1.test
-# tt/two/t2.test
-# tt/two/one/t.test
-
-
-. &quot;$MYDIR/indent.sh&quot;
-
-
-MKDIR tt
-cd &quot;$tt&quot; || ABORT &quot;Could not cd to $tt&quot;
-
-cat &gt; t.test &lt;&lt;-EOL
-	echo &quot;right output1&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir one
-cat &gt; one/t.test &lt;&lt;-EOL
-	echo &quot;right output2&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two
-cat &gt; two/t1.test &lt;&lt;-EOL
-	echo &quot;right output3&quot;
-	STDOUT:
-	wrong output
-EOL
-
-cat &gt; two/t2.test &lt;&lt;-EOL
-	echo &quot;right output4&quot;
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two/one
-cat &gt; two/one/t.test &lt;&lt;-EOL
-	echo &quot;right output5&quot;
-	STDOUT:
-	wrong output
-EOL
-
-cd two
-
-tmtest --all-files -d .. | patch -p0
-echo
-INDENT &lt; ../t.test
-echo
-INDENT &lt; ../one/t.test
-echo
-INDENT &lt; t1.test
-echo
-INDENT &lt; t2.test
-echo
-INDENT &lt; one/t.test
-
-rm -rf ../t.test ../one ../two
-
-
-MODIFY:
-  s/^patching .*/patching FILE/
-
-STDOUT:
-patching FILE
-patching FILE
-patching FILE
-patching FILE
-patching FILE
-
-	echo &quot;right output1&quot;
-	STDOUT:
-	right output1
-
-	echo &quot;right output2&quot;
-	STDOUT:
-	right output2
-
-	echo &quot;right output3&quot;
-	STDOUT:
-	right output3
-
-	echo &quot;right output4&quot;
-	STDOUT:
-	right output4
-
-	echo &quot;right output5&quot;
-	STDOUT:
-	right output5

Copied: releases/0.94/test/04-diff/13-MultiLevelPatch.test (from rev 89, trunk/test/04-diff/13-MultiLevelPatch.test)

Copied: releases/0.94/test/04-diff/18-NeedNLWarn.test (from rev 99, trunk/test/04-diff/18-NeedNLWarn.test)

Copied: releases/0.94/test/04-diff/20-DiffNoNL.test (from rev 90, trunk/test/04-diff/20-DiffNoNL.test)

Copied: releases/0.94/test/04-diff/21-PatchNoNL.test (from rev 99, trunk/test/04-diff/21-PatchNoNL.test)

Copied: releases/0.94/test/04-diff/22-PatchNoNL2.test (from rev 99, trunk/test/04-diff/22-PatchNoNL2.test)

Copied: releases/0.94/test/04-diff/23-PatchNoNL3.test (from rev 99, trunk/test/04-diff/23-PatchNoNL3.test)

Deleted: releases/0.94/test/04-diff/indent.sh
===================================================================
--- trunk/test/04-diff/indent.sh	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/indent.sh	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,9 +0,0 @@
-# This function indents each line of its stdin with a tab.
-
-INDENT ()
-{
-	while read LINE; do
-		echo $'\t'&quot;$LINE&quot;
-	done
-}
-

Copied: releases/0.94/test/04-diff/tmtest.conf (from rev 90, trunk/test/04-diff/tmtest.conf)

Deleted: releases/0.94/test/README
===================================================================
--- trunk/test/README	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/README	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,30 +0,0 @@
-NOTE: If you are looking for examples of testfiles, this is NOT the
-directory for you!  Due to the recursive nature of tmtest testing
-itself, many of these testfiles are very difficult to understand.
-
-See the examples directory instead.
-
-
-These are the test subcategories:
-
-00-cmdline: tests parsing command-line arguments
-    Mostly tests illegal command-line arguments.
-
-01-testfile: tests the parsing of test files.
-    Mostly tests illegal testfiles and ensures proper errors are printed.
-
-02-running: tests running the actual tests
-    Ensures that the test environment is set up properly.
-    For instance, checks that disabled tests are not run, the tmlib
-    calls are performed properly, etc.
-
-03-results: tests the results
-    Ensures that we compare the test results properly.
-    For instance, verifies that we handle results that don't
-    end in newlines, binary characters, etc. properly.
-
-04-diff: ensures diffing and patching works
-
-09-docs: tests that appear in our documentation.
-    This ensures that tmtest behaves exactly like our docs say it will.
-

Copied: releases/0.94/test/README (from rev 91, trunk/test/README)

Deleted: releases/0.94/test/tmtest.sub.conf
===================================================================
--- trunk/test/tmtest.sub.conf	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/tmtest.sub.conf	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,18 +0,0 @@
-# tmtest.sub.conf
-# Scott Bronson
-# 15 Dec 2005
-
-
-# When you run &quot;make test&quot;, this is the only config file read by the
-# testfiles.  This ensures that the tests are not succeeding due some local
-# config setting, and that the correct tmlib routines are being used.
-
-
-# All tests are written to be pedantic.  We want them to exit at the
-# first sign of trouble and have the result code reported in RESULT.
-set -e
-
-
-# Include the standard tmtest functions
-. ../tmlib.sh
-

Copied: releases/0.94/test/tmtest.sub.conf (from rev 99, trunk/test/tmtest.sub.conf)

Deleted: releases/0.94/test.c
===================================================================
--- trunk/test.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,1159 +0,0 @@
-/* test.c
- * 30 Dec 2004
- * Copyright (C) 2004 Scott Bronson
- * 
- * Contains the routines to check/diff/etc test output.
- *
- * This file is covered by the MIT license.
- */
-
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-
-// to get PATH_MAX:
-#include &lt;dirent.h&gt;
-
-#include &quot;re2c/read-fd.h&quot;
-
-#include &quot;test.h&quot;
-#include &quot;stscan.h&quot;
-#include &quot;tfscan.h&quot;
-#include &quot;compare.h&quot;
-#include &quot;rusage.h&quot;
-
-
-// This is the maximum line length for the eachline substitution.
-// Lines longer than this will be parsed as 2 separate lines.
-#define MAX_LINE_LENGTH BUFSIZ
-
-// utility function so you can say i.e. write_strconst(fd, &quot;/&quot;);
-#define write_strconst(fd, str) write((fd), (str), sizeof(str)-1)
-
-static int test_runs = 0;
-static int test_successes = 0;
-static int test_failures = 0;
-
-
-const char *convert_testfile_name(const char *fn)
-{
-    if(fn[0] == '-' &amp;&amp; fn[1] == '\0') {
-        return &quot;(STDIN)&quot;;
-    }
-
-	return fn;
-}
-
-
-const char* get_testfile_name(struct test *test)
-{
-    return convert_testfile_name(test-&gt;testfilename);
-}
-
-
-/** Tells if the given file descriptor has a nonzero length.
- * NOTE: it changes the file offset to the end of the file.
- *
- * Returns nonzero if file has data, zero if it doesn't.
- * Actually, it just returns the file's length.
- */
-
-int fd_has_data(int fd)
-{
-    off_t pos = lseek(fd, 0, SEEK_END);
-    if(pos &lt; 0) {
-        perror(&quot;lseek in fd_has_data&quot;);
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    return pos;
-}
-
-
-/** Tries to find the argument in the status line given.
- *
- * @return  nonzero if the argument could be found, zero if not.
- * If the argument was found, then incp and ince are updated to
- * point to its beginning and end.
- */
-
-static int locate_status_arg(const char **incp, const char **ince)
-{
-	const char *cp = *incp;
-	const char *ce = *ince;
-
-	// trim the newline from the end
-	if(ce[-1] == '\n') ce--;
-
-	// skip to colon separating name from arg
-	while(*cp != ':' &amp;&amp; *cp != '\n' &amp;&amp; cp &lt; ce) cp++;
-	if(*cp == ':') {
-		cp++;					// skip the colon
-		if(*cp == ' ') cp++;	// skip the optional space after it
-		if(cp &lt; ce) {
-			*incp = cp;
-			*ince = ce;
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-
-static char* dup_status_arg(const char *cp, const char *ce)
-{
-	char *ret = NULL;
-
-	if(locate_status_arg(&amp;cp, &amp;ce)) {
-		ret = malloc(ce - cp + 1);
-		if(ret) {
-			memcpy(ret, cp, ce-cp);
-			// replace the NL on the end with the null terminator.
-			ret[ce-cp] = '\0';
-		}
-	}
-
-	return ret;
-}
-
-
-static int copy_status_arg(const char *cp, const char *ce, char *buf, int size)
-{
-	if(locate_status_arg(&amp;cp, &amp;ce)) {
-		int len = ce - cp;
-		if(size-1 &lt; len) len = size-1;
-		memcpy(buf, cp, len);
-		buf[len] = '\0';
-		return 1;
-	}
-
-	return 0;
-}
-
-
-/** Looks through the status file and stores the items of interest
- * in the test structure.
- */
-
-void scan_status_file(struct test *test)
-{
-	char lastfile[PATH_MAX];
-	int lastfile_good = 0;
-    char buf[BUFSIZ];
-    scanstate ss;
-    int tok;
-	int state = 0;
-
-    // first rewind the status file
-    if(lseek(test-&gt;statusfd, 0, SEEK_SET) &lt; 0) {
-        fprintf(stderr, &quot;read_file lseek for status file: %s\n&quot;, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // then create our scanner
-    scanstate_init(&amp;ss, buf, sizeof(buf));
-    readfd_attach(&amp;ss, test-&gt;statusfd);
-    stscan_attach(&amp;ss);
-
-    // now, if we see the token &quot;CBRUNNING&quot; in the token stream,
-    // it means that we attempted to start the test.  If not,
-    // then the test bailed early.
-    do {
-        tok = scan_token(&amp;ss);
-
-		// look for errors...
-        if(tok &lt; 0) {
-            fprintf(stderr, &quot;Error %d pulling status tokens: %s\n&quot;, 
-                    tok, strerror(errno));
-            exit(10);
-        } else if(tok == stGARBAGE) {
-			fprintf(stderr, &quot;Garbage on line %d in the status file: '%.*s'\n&quot;,
-					ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-		} else {
-			state = tok;
-		}
-
-		switch(tok) {
-			case stSTART:
-				// nothing to do
-				break;
-
-			case stCONFIG:
-				if(test-&gt;status == test_pending) {
-					test-&gt;num_config_files += 1;
-					if(copy_status_arg(token_start(&amp;ss), token_end(&amp;ss), lastfile, sizeof(lastfile))) {
-						lastfile_good = 1;
-					} else {
-						fprintf(stderr, &quot;CONFIG needs arg on line %d of the status file: '%.*s'\n&quot;,
-								ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-					}
-				} else {
-					fprintf(stderr, &quot;CONFIG but status (%d) wasn't pending on line %d of the status file: '%.*s'\n&quot;,
-							test-&gt;status, ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-				}
-				break;
-
-			case stPREPARE:
-				// nothing to do
-				break;
-
-			case stRUNNING:
-				if(test-&gt;status == test_pending) {
-					test-&gt;status = test_was_started;
-					if(copy_status_arg(token_start(&amp;ss), token_end(&amp;ss), lastfile, sizeof(lastfile))) {
-						lastfile_good = 1;
-					} else {
-						fprintf(stderr, &quot;RUNNING needs arg on line %d of the status file: '%.*s'\n&quot;,
-								ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-					}
-				} else {
-					fprintf(stderr, &quot;RUNNING but status (%d) wasn't pending on line %d of the status file: '%.*s'\n&quot;,
-							test-&gt;status, ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-				}
-				break;
-
-			case stDONE:
-				if(test-&gt;status == test_was_started) {
-					test-&gt;status = test_was_completed;
-				} else {
-					fprintf(stderr, &quot;DONE but status (%d) wasn't RUNNING on line %d of the status file: '%.*s'\n&quot;,
-							test-&gt;status, ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-				}
-				break;
-			
-			case stABORTED:
-				test-&gt;status = (test-&gt;status &gt;= test_was_started ? test_was_aborted : config_was_aborted);
-				test-&gt;status_reason = dup_status_arg(token_start(&amp;ss), token_end(&amp;ss));
-				break;
-
-			case stDISABLED:
-				test-&gt;status = (test-&gt;status &gt;= test_was_started ? test_was_disabled : config_was_disabled);
-				test-&gt;status_reason = dup_status_arg(token_start(&amp;ss), token_end(&amp;ss));
-				break;
-
-			default:
-				fprintf(stderr, &quot;Unknown token (%d) on line %d of the status file: '%.*s'\n&quot;,
-						tok, ss.line, token_length(&amp;ss)-1, token_start(&amp;ss));
-		}
-    } while(!scan_finished(&amp;ss));
-
-	if(lastfile_good) {
-		test-&gt;last_file_processed = strdup(lastfile);
-	}
-}
-
-
-/**
- * Prints the command section of the test suitable for how the test
- * is being run.
- *
- * If the user is just running the test, nothing is printed.  If the
- * user is diffing or dumping the test, however, the modified command
- * section needs to be printed to the appropriate command.
- *
- * @param test The test being run.
- * @param tok The type of data this is (from tfscan.h).  If 0 then 
- *            this is the EOF and this routine won't be called anymore.
- * @param ptr The data to write.  If tok==0 then ptr is undefined.
- * @param len The amount of data to write.  If tok==0 then len==0.
- *
- * Hm, a year later it ooks like rewriting is a feature that will
- * never need to be implemented...?
- */
-
-void rewrite_command_section(struct test *test, int tok, const char *ptr, int len)
-{
-    // only dump if we're asked to.
-    if(test-&gt;rewritefd &lt; 0) {
-        return;
-    }
-
-    // for now we don't modify it at all.
-    write(test-&gt;rewritefd, ptr, len);
-}
-
-
-/** Copies the command section of the test to the given fileptr and
- * also supplies it to the dump_command_section() routine.
- *
- * If you don't want to dump to a fileptr (i.e. if you're running
- * the test from a file) just pass NULL for fp.
- *
- * This routine is a whole lot like scan_sections except that it stops
- * at the end of the command section.  It leaves the result sections
- * on the stream to be parsed later.
- */
-
-void test_command_copy(struct test *test, FILE *fp)
-{
-    int oldline;
-
-    do {
-        oldline = test-&gt;testfile.line;
-        int tokno = scan_token(&amp;test-&gt;testfile);
-        if(tokno &lt; 0) {
-            fprintf(stderr, &quot;Error %d pulling status tokens: %s\n&quot;, 
-                    tokno, strerror(errno));
-            exit(10);
-        } else if(tokno == 0) {
-			// if the test file is totally empty.
-			break;
-		}
-
-
-        if(tokno != exCOMMAND) {
-            // now we attempt to push the token back on the stream...
-            scan_pushback(&amp;test-&gt;testfile);
-            test-&gt;testfile.line = oldline;
-            // The pushback reset the stream, and I restored the line number,
-            // but the scanner is still in a different state.
-            // We need it to be in a COMMAND state, so that when it feeds
-            // the new SECTION token it marks it NEW.  Reattaching resets
-            // the state to a command state, so we can just do that.
-            tfscan_attach(&amp;test-&gt;testfile);
-            // Now we're done dumping the command and the scanner
-            // is poised to return the correct section start to the
-            // next client.
-            break;
-        }
-
-        // print the modified data to the output stream.
-        rewrite_command_section(test, tokno, token_start(&amp;test-&gt;testfile), token_length(&amp;test-&gt;testfile));
-
-        if(fp) {
-            // print the unmodified data to the command script.
-            fwrite(token_start(&amp;test-&gt;testfile), token_length(&amp;test-&gt;testfile), 1, fp);
-        }
-    } while(!scan_finished(&amp;test-&gt;testfile));
-
-    rewrite_command_section(test, 0, NULL, 0);
-}
-
-
-/** Prepares a test section for comparison against actual results.
- *
- * The comparison is handled by compare.c/h.  We just need to set
- * it up.
- */
-
-void compare_section_start(scanstate *cmpscan, int fd, pcrs_job *joblist,
-		matchval *mv, const char *filename, const char *sectionname, int nonl)
-{
-    assert(!compare_in_progress(cmpscan));
-
-    // associates the scanstate with the fd and prepares to compare.
-    if(*mv != match_unknown) {
-        fprintf(stderr, &quot;'%s' has multiple %s sections!\n&quot;,
-                filename, sectionname);
-        exit(10);
-    }
-
-    // rewind the file
-    if(lseek(fd, 0, SEEK_SET) &lt; 0) {
-        fprintf(stderr, &quot;read_file lseek for status file: %s\n&quot;, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    scanstate_reset(cmpscan);
-    readfd_attach(cmpscan, fd);
-	compare_attach(cmpscan, mv, joblist, nonl);
-
-    // we may want to check the token to see if there are any
-    // special requests (like detabbing).
-}
-
-
-/** Returns true if the given buffer contains non-whitespace characters,
- * false if the buffer consists entirely of whitespace. */
-
-static int contains_nws(const char *cp, int len)
-{
-	const char *ce = cp + len;
-
-	while(cp &lt; ce) {
-		if(!isspace(*cp)) {
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-
-/** Scans the given buffer for the exit value.
- *
- * Ignores everything except for the first digit and any digits that
- * follow it.
- *
- * If digits are found, then it updates the test structure with
- * whether the exit values match or not.
- * If no digits are found, then this routine does nothing.
- */
-
-void parse_exit_clause(struct test *test, const char *cp, int len)
-{
-	const char *ce = cp + len;
-	unsigned int num = 0;
-
-	// skip to the first digit in the buffer
-	while(!isdigit(*cp) &amp;&amp; cp &lt; ce) cp++;
-	if(cp &gt;= ce) return;
-
-	// scan the number
-	while(isdigit(*cp)) {
-		num = 10*num + (*cp - '0');
-		cp++;
-	}
-
-	test-&gt;expected_exitno = num;
-	test-&gt;exitno_match = (test-&gt;exitno == num ? match_yes : match_no);
-}
-
-
-/** Increments cp past the section name.
- *
- * Will not increment cp by more than len bytes.
- * This routine must match the token parsing found in the tfscan_start routine.
- */
-
-const char *skip_section_name(const char *cp, int len)
-{
-	const char *ce = cp + len;
-
-	// skip to colon separating section name from data
-	while(*cp != ':' &amp;&amp; *cp != '\n' &amp;&amp; cp &lt; ce) cp++;
-	if(*cp == ':') cp++;
-	return cp;
-}
-
-
-void parse_modify_clause(struct test *test, const char *cp, const char *ce)
-{
-	pcrs_job *job, **p;
-	char *string;
-	int err;
-
-	char buf[128];	// holds the pcrs command.  We will dynamically
-		// allocate a buffer if the entire substitution doesn't fit
-		// into this buffer.  The vast majority of substitutions will
-		// be less than 40 chars.
-
-	// skip any leading whitespace
-	while(isspace(*cp) &amp;&amp; cp &lt; ce) cp++;
-
-	// ensure there's still data worth parsing
-	if(*cp == '\n' || cp &gt;= ce) {
-		return;
-	}
-
-	// don't parse it if it's a comment
-	if(*cp == '#') {
-		return;
-	}
-
-	// It's retarded that I can't pass a buf/len combo to pcrs_compile_command.
-	// It's also retarded that pcrs won't tell me where it stopped parsing
-	// so that we can have multiple substitution clauses on line line.
-
-	if(ce-cp-1 &lt; sizeof(buf)) {
-		string = buf;
-	} else {
-		string = malloc(ce-cp+1);
-		if(!string) {
-			perror(&quot;malloc in parse_modify_clause&quot;);
-			exit(10);
-		}
-	}
-
-	memcpy(string, cp, ce-cp);
-	string[ce-cp] = '\0';
-	job = pcrs_compile_command(string, &amp;err);
-	if(job == NULL) {
-        fprintf(stderr, &quot;%s line %d compile error: %s (%d).\n&quot;,
-                get_testfile_name(test), test-&gt;testfile.line,
-                pcrs_strerror(err), err);
-	}
-
-	if(ce-cp-1 &lt; sizeof(buf)) {
-		// nothing to do; we used the static buffer
-	} else {
-		free(string);
-	}
-
-	if(job == NULL) {
-		return;
-	}
-
-	// link this job onto the end of the list.
-	p = &amp;test-&gt;eachline;
-	while(*p) p = &amp;(**p).next;
-	*p = job;
-}
-
-
-/**
- * Calls the given callback routine for each argument found.
- *
- * For now, we just split on whitespace.  In the future, if needed,
- * this routine could be modified to handle \, &quot;, ', etc just like bash.
- */
-
-int parse_section_args(const char *tok, int toklen, const char *file, int line,
-        int (*argproc)(int index, const char *buf, const char *end, 
-            const char *file, int line, void *refcon),
-        void *refcon)
-{
-    const char *end = tok + toklen;
-    const char *cb, *ce;
-    int index = 0;
-    int val = 0;
-
-    ce = tok;
-    while(ce &lt; end) {
-        cb = ce;
-        while(!isspace(*ce) &amp;&amp; ce &lt; end) {
-            ce++;
-        }
-
-        val = (*argproc)(index, cb, ce, file, line, refcon);
-        if(val) {
-            break;
-        }
-        index += 1;
-
-        while(isspace(*ce) &amp;&amp; ce &lt; end) {
-            ce++;
-        }
-    }
-
-    return val;
-}
-
-
-int constreq(const char *cp, const char *ce, const char *str)
-{
-    int len = strlen(str);
-
-    if(ce - cp != len) {
-        return 0;
-    }
-
-    if(memcmp(cp, str, len) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
-
-
-int start_output_section_argproc(int i, const char *cp, const char *ce,
-        const char *file, int line, void *refcon)
-{
-    if(i == 0) {
-        // index == 0 is the name of this section
-        return 0;
-    }
-
-    // trim colons from arguments...  they can appear anywhere you want.
-    while(*cp == ':' &amp;&amp; cp &lt; ce) {
-        cp++;
-    }
-    while(ce[-1] == ':' &amp;&amp; ce &gt; cp) {
-        ce--;
-    }
-
-    if(constreq(cp,ce,&quot;-n&quot;) || constreq(cp,ce,&quot;--no-trailing-newline&quot;)) {
-        *(int*)refcon = 1;
-    } else if(cp &lt; ce) {
-        fprintf(stderr, &quot;%s line %d: unknown arguments \&quot;%.*s\&quot;\n&quot;,
-                file, line, ce-cp, cp);
-    }
-
-    return 0;
-}
-
-
-void start_output_section(struct test *test, const char *tok,
-        int toklen, scanstate *cmpscan, int fd, matchval *val,
-        const char *secname)
-{
-    int suppress_trailing_newline = 0;
-
-    parse_section_args(tok, toklen,
-            get_testfile_name(test), test-&gt;testfile.line,
-            start_output_section_argproc, 
-            (void*)&amp;suppress_trailing_newline);
-
-    if(*val != match_unknown) {
-        // we've already obtained a value for this section!
-        fprintf(stderr, &quot;%s line %d Error: duplicate %s &quot;
-                &quot;section.  Ignored.\n&quot;, get_testfile_name(test),
-                test-&gt;testfile.line, secname);
-        // as long as scanref == null, no comparison will happen.
-        assert(!cmpscan-&gt;scanref);
-        return;
-    }
-
-    compare_section_start(cmpscan, fd, test-&gt;eachline, val,
-        get_testfile_name(test), secname, suppress_trailing_newline);
-}
-
-
-/** This routine parses the tokens returned by scan_sections() and
- * compares them against the actual test results.  It stores the
- * results in test-&gt;match_stdout, match_stderr, and match_result.
- *
- * The refcon needs to be an allocated scanner.  It need not be
- * attached to anything -- this routine will take care of attaching
- * and detaching it as needed.
- *
- */
-
-void parse_section_compare(struct test *test, int sec,
-        const char *datap, int len, void *refcon)
-{
-    #define get_cur_state(ss)    ((int)(ss)-&gt;userref)
-    #define set_cur_state(ss,x)  ((ss)-&gt;userref=(void*)(x))
-
-    // compscan is the comparison scanner -- it is used to diff the
-    // current output section (either stdout or stderr).
-    scanstate *cmpscan = refcon;
-
-    // the section that we're entering (without the NEW flag attached)
-    int newsec = EX_TOKEN(sec);
-
-    if(get_cur_state(cmpscan) == 0) {
-        // This is the first time this scanner has been used.
-        set_cur_state(cmpscan, exCOMMAND);
-    }
-
-    if(!is_section_token(newsec) &amp;&amp; sec != 0) {
-        // We only work with result section tokens.  Ignore all
-        // non-section-tokens except the eof token.
-        return;
-    }
-
-    if(EX_ISNEW(sec) || sec == 0) {
-        // ensure previoius section is finished
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-            case exSTDERR:
-                compare_end(cmpscan);
-                break;
-            default:
-                ;
-        }
-
-        // then fire up the new section
-        set_cur_state(cmpscan, newsec);
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-                start_output_section(test, datap, len, cmpscan,
-                        test-&gt;outfd, &amp;test-&gt;stdout_match, &quot;STDOUT&quot;);
-                break;
-            case exSTDERR:
-                start_output_section(test, datap, len, cmpscan,
-                        test-&gt;errfd, &amp;test-&gt;stderr_match, &quot;STDERR&quot;);
-                break;
-            case exRESULT:
-				parse_exit_clause(test, datap, len);
-                break;
-            case exMODIFY:
-				parse_modify_clause(test, skip_section_name(datap,len),
-                        datap+len);
-                break;
-            case exCOMMAND:
-                fprintf(stderr, &quot;%s line %d Error: Well, this is impossible.  &quot;
-                        &quot;How did you start a new command section??\n&quot;,
-                        get_testfile_name(test), test-&gt;testfile.line);
-                // it should be harmless to continue but this definitely
-                // indicates a bug in the scanner.
-                break;
-        }
-    } else {
-        // we're continuing an already started section.
-        assert(get_cur_state(cmpscan) == newsec);
-
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-            case exSTDERR:
-                compare_continue(cmpscan, datap, len);
-                break;
-            case exRESULT:
-				if(contains_nws(datap, len)) {
-					fprintf(stderr, &quot;%s line %d Error: RESULT clause &quot;
-                            &quot;contains garbage.\n&quot;,
-							get_testfile_name(test), test-&gt;testfile.line);
-                    // Harmless to continue.  The testfile needs to be fixed.
-				}
-                break;
-            case exMODIFY:
-				parse_modify_clause(test, datap, datap+len);
-                break;
-            case exCOMMAND:
-                break;
-        }
-    }
-}
-
-
-/** Scans the output sections of the test and calls the supplied parser
- * for each token.
- *
- * Tokens are defined by the tfscan_start() routine.  Currently they're
- * full lines.  If the line starts with a recognized section heading,
- *
- *
- * @param scanner: used to provide the section tokens.
- */
-
-void scan_sections(struct test *test, scanstate *scanner,
-        void (*parseproc)(struct test *test, int sec, const char *datap,
-                int len, void *refcon), void *refcon)
-{
-    // if the testfile is already at its eof, it means that
-    // it didn't have any sections.  therefore, we'll assume
-    // defaults for all values.  we're done.
-    if(scan_finished(scanner)) {
-        return;
-    }
-    
-    do {
-        int tokno = scan_token(scanner);
-        if(tokno &lt; 0) {
-            fprintf(stderr, &quot;Error %d pulling status tokens: %s\n&quot;, 
-                    tokno, strerror(errno));
-            exit(10);
-        } else if(tokno == 0) {
-			break;
-		}
-
-        (*parseproc)(test, tokno, token_start(scanner),
-                token_length(scanner), refcon);
-
-    } while(!scan_finished(scanner));
-
-    // give the parser an eof token so it can finalize things.
-    (*parseproc)(test, 0, NULL, 0, refcon);
-}
-
-
-static void print_reason(struct test *test, const char *name, const char *prep)
-{
-	printf(&quot;%s %-25s &quot;, name, get_testfile_name(test));
-	if(!was_started(test-&gt;status)) {
-		printf(&quot;%s %s&quot;, prep, test-&gt;last_file_processed);
-		if(test-&gt;status_reason) {
-			printf(&quot;: &quot;);
-		}
-	}
-	if(test-&gt;status_reason) {
-		printf(&quot;%s&quot;, test-&gt;status_reason);
-	}
-	printf(&quot;\n&quot;);
-}
-
-
-/** Checks the actual results against the expected results.
- */
-
-void test_results(struct test *test)
-{
-    scanstate scanner;
-    char scanbuf[MAX_LINE_LENGTH];
-	int stdo, stde, exno;	// true if there are differences.
-	
-	if(was_aborted(test-&gt;status)) {
-		print_reason(test, &quot;ABRT&quot;, &quot;by&quot;);
-		test_failures++;
-		test-&gt;aborted = 1;
-		return;
-	}
-
-	if(was_disabled(test-&gt;status)) {
-		print_reason(test, &quot;dis &quot;, &quot;by&quot;);
-		return;
-	}
-
-    if(!was_started(test-&gt;status)) {
-		print_reason(test, &quot;ERR &quot;, &quot;error in&quot;);
-        test_failures++;
-        return;
-    }
-
-    test-&gt;exitno_match = match_unknown;
-    test-&gt;stdout_match = match_unknown;
-    test-&gt;stderr_match = match_unknown;
-
-    scanstate_init(&amp;scanner, scanbuf, sizeof(scanbuf));
-    scan_sections(test, &amp;test-&gt;testfile, parse_section_compare, &amp;scanner);
-
-    assert(test-&gt;stdout_match != match_inprogress);
-    assert(test-&gt;stderr_match != match_inprogress);
-
-    // convert any unknowns into a solid yes/no
-    if(test-&gt;exitno_match == match_unknown) {
-		test-&gt;expected_exitno = 0;
-        test-&gt;exitno_match = (test-&gt;exitno == 0 ? match_yes : match_no);
-    }
-    if(test-&gt;stdout_match == match_unknown) {
-        test-&gt;stdout_match = (fd_has_data(test-&gt;outfd) ? match_no : match_yes);
-    }
-    if(test-&gt;stderr_match == match_unknown) {
-        test-&gt;stderr_match = (fd_has_data(test-&gt;errfd) ? match_no : match_yes);
-    }
-
-    stdo = (test-&gt;stdout_match != match_yes);
-    stde = (test-&gt;stderr_match != match_yes);
-    exno = (test-&gt;exitno_match != match_yes);
-
-    if(!stdo &amp;&amp; !stde &amp;&amp; !exno) {
-        test_successes++;
-        printf(&quot;ok   %s \n&quot;, get_testfile_name(test));
-    } else {
-        test_failures++;
-        printf(&quot;FAIL %-25s &quot;, get_testfile_name(test));
-		printf(&quot;%c%c%c  &quot;,
-				(stdo ? 'O' : '.'),
-				(stde ? 'E' : '.'),
-				(exno ? 'X' : '.'));
-		if(stdo || stde) {
-			if(stdo) printf(&quot;stdout &quot;);
-			if(stdo &amp;&amp; stde) printf(&quot;and &quot;);
-			if(stde) printf(&quot;stderr &quot;);
-			printf(&quot;differed&quot;);
-		}
-		if((stdo || stde) &amp;&amp; exno) printf(&quot;, &quot;);
-		if(exno) printf(&quot;result was %d not %d&quot;, test-&gt;exitno, test-&gt;expected_exitno);
-		printf(&quot;\n&quot;);
-    }
-
-    return;
-}
-
-
-static void write_exit_no(int fd, int exitno)
-{
-    char buf[512];
-    int cnt;
-
-    cnt = snprintf(buf, sizeof(buf), &quot;RESULT: %d\n&quot;, exitno);
-    write(fd, buf, cnt);
-}
-
-
-void write_raw_file(int outfd, int infd)
-{
-    char buf[BUFSIZ];
-    int rcnt, wcnt;
-
-    // first rewind the input file
-    if(lseek(infd, 0, SEEK_SET) &lt; 0) {
-        fprintf(stderr, &quot;write_file lseek on %d: %s\n&quot;, infd, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // then write the file.
-    do {
-        do {
-            rcnt = read(infd, buf, sizeof(buf));
-        } while(rcnt &lt; 0 &amp;&amp; errno == EINTR);
-        if(rcnt &gt; 0) {
-            do {
-                wcnt = write(outfd, buf, rcnt);
-            } while(wcnt &lt; 0 &amp;&amp; errno == EINTR);
-            if(wcnt &lt; 0) {
-                // write error.  do something!
-                perror(&quot;writing in write_file&quot;);
-                break;
-            }
-        } else if (rcnt &lt; 0) {
-            // read error.  do something!
-            perror(&quot;reading in write_file&quot;);
-            break;
-        }
-    } while(rcnt);
-}
-
-
-static void write_modified_file(int outfd, int infd, pcrs_job *job)
-{
-    // this routine is fairly similar to compare_continue_lines.
-    // it would be nice to unify them.  that would take some fairly
-    // major surgery though.
-
-    scanstate scanner, *ss = &scanner;
-    char scanbuf[MAX_LINE_LENGTH];
-    const char *p;
-    char *new;
-    size_t newsize;
-    int rcnt, wcnt;
-
-    // first rewind the input file
-    if(lseek(infd, 0, SEEK_SET) &lt; 0) {
-        fprintf(stderr, &quot;write_file lseek on %d: %s\n&quot;, infd, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // create the scanner we'll use to buffer the lines
-    scanstate_init(ss, scanbuf, sizeof(scanbuf));
-    readfd_attach(ss, infd);
-
-    do {
-        p = memchr(ss-&gt;cursor, '\n', ss-&gt;limit - ss-&gt;cursor);
-        if(!p) {
-            rcnt = (*ss-&gt;read)(ss);
-            if(rcnt &lt; 0) {
-                // read error.  do something!
-                perror(&quot;reading in write_modified_file&quot;);
-                break;
-            }
-            p = memchr(ss-&gt;cursor, '\n', ss-&gt;limit - ss-&gt;cursor);
-            if(!p) {
-                p = ss-&gt;limit - 1;
-            }
-        }
-
-        p += 1;
-        new = substitute_string(job, ss-&gt;cursor, p, &amp;newsize);
-        if(!new) {
-            // substitution error!  message already printed.
-            break;
-        }
-
-        do {
-            wcnt = write(outfd, new, newsize);
-        } while(wcnt &lt; 0 &amp;&amp; errno == EINTR);
-        free(new);
-        if(wcnt &lt; 0) {
-            // write error.  do something!
-            perror(&quot;writing in write_modified_file&quot;);
-            break;
-        }
-        ss-&gt;cursor = p;
-    } while(rcnt);
-}
-
-
-static void write_file(int outfd, int infd, pcrs_job *job)
-{
-	if(!job) {
-		// use the simple, fast routine
-		write_raw_file(outfd, infd);
-	} else {
-		// use the line buffered routine
-		write_modified_file(outfd, infd, job);
-	}
-}
-
-
-/** Writes the actual results in place of the expected results.
- */
-
-void parse_section_output(struct test *test, int sec,
-        const char *datap, int len, void *refcon)
-{
-    int *needs_nl = (int*)refcon;
-
-    assert(sec &gt;= 0);
-
-    if(sec &amp; exNEW) {
-        // check to see if previous section needs a newline appended.
-        if(*needs_nl) {
-            write_strconst(test-&gt;rewritefd, &quot;\n&quot;);
-        }
-
-        *needs_nl = 0;
-    }
-
-    switch(sec) {
-        case 0:
-            if(*needs_nl) {
-                write_strconst(test-&gt;rewritefd, &quot;\n&quot;);
-            }
-            break;
-
-        case exSTDOUT|exNEW:
-            parse_section_args(datap, len,
-                    get_testfile_name(test), test-&gt;testfile.line,
-                    start_output_section_argproc, needs_nl);
-            write(test-&gt;rewritefd, datap, len);
-            write_file(test-&gt;rewritefd, test-&gt;outfd, test-&gt;eachline);
-            test-&gt;stdout_match = match_yes;
-            break;
-        case exSTDOUT:
-            // ignore all data in the expected stdout.
-            break;
-
-        case exSTDERR|exNEW:
-            parse_section_args(datap, len,
-                    get_testfile_name(test), test-&gt;testfile.line,
-                    start_output_section_argproc, needs_nl);
-            write(test-&gt;rewritefd, datap, len);
-            write_file(test-&gt;rewritefd, test-&gt;errfd, test-&gt;eachline);
-            test-&gt;stderr_match = match_yes;
-            break;
-        case exSTDERR:
-            // ignore all data in the expected stderr
-            break;
-
-        case exRESULT|exNEW:
-            test-&gt;exitno_match = match_yes;
-            write_exit_no(test-&gt;rewritefd, test-&gt;exitno);
-            break;
-        case exRESULT:
-            // allow random garbage in result section to pass
-            write(test-&gt;rewritefd, datap, len);
-            break;
-
-        case exMODIFY|exNEW:
-            parse_modify_clause(test, skip_section_name(datap,len), datap+len);
-            write(test-&gt;rewritefd, datap, len);
-            break;
-        case exMODIFY:
-            // parse modify sections and still print them.
-            parse_modify_clause(test, datap, datap+len);
-            write(test-&gt;rewritefd, datap, len);
-            break;
-            
-        default:
-            write(test-&gt;rewritefd, datap, len);
-    }
-}
-
-
-static void dump_reason(struct test *test, const char *name)
-{
-	fprintf(stderr, &quot;ERROR Test %s&quot;, name);
-	if(!was_started(test-&gt;status)) {
-		fprintf(stderr, &quot; by %s&quot;, convert_testfile_name(test-&gt;last_file_processed));
-		if(test-&gt;status_reason) {
-			printf(&quot;: &quot;);
-		}
-	}
-	if(test-&gt;status_reason) {
-		fprintf(stderr, &quot;: %s&quot;, test-&gt;status_reason);
-	}
-	fprintf(stderr, &quot;\n&quot;);
-}
-
-
-/** Prints the actual result sections in the same order as they
- * appear in the testfile.
- */
-
-void dump_results(struct test *test)
-{
-    int tempref = 0;
-
-	if(was_aborted(test-&gt;status)) {
-		dump_reason(test, &quot;was aborted&quot;);
-		test-&gt;aborted = 1;
-		return;
-	}
-
-	if(was_disabled(test-&gt;status)) {
-		dump_reason(test, &quot;is disabled&quot;);
-		return;
-
-	}
-
-    if(!was_started(test-&gt;status)) {
-        fprintf(stderr, &quot;Error: %s was not started due to errors in %s.\n&quot;,
-				get_testfile_name(test), test-&gt;last_file_processed);
-        test_failures++;
-        return;
-    }
-
-    // The command section has already been dumped.  We just
-    // need to dump the result sections.  The trick is, though,
-    // that we need to dump them in the same order as they occur
-    // in the testfile otherwise the diff will be all screwed up.
-
-    test-&gt;exitno_match = match_unknown;
-    test-&gt;stdout_match = match_unknown;
-    test-&gt;stderr_match = match_unknown;
-
-    // ensure that we haven't yet parsed any modify sections.
-    assert(!test-&gt;eachline);
-
-    scan_sections(test, &amp;test-&gt;testfile, parse_section_output, &amp;tempref);
-
-    // if any sections haven't been output, but they differ from
-    // the default, then they need to be output here at the end.
-
-    if(test-&gt;exitno_match == match_unknown &amp;&amp; test-&gt;exitno != 0) {
-        write_exit_no(test-&gt;rewritefd, test-&gt;exitno);
-    }
-    if(test-&gt;stderr_match == match_unknown &amp;&amp; fd_has_data(test-&gt;errfd)) {
-		write_strconst(test-&gt;rewritefd, &quot;STDERR:\n&quot;);
-        write_file(test-&gt;rewritefd, test-&gt;errfd, test-&gt;eachline);
-    }
-    if(test-&gt;stdout_match == match_unknown &amp;&amp; fd_has_data(test-&gt;outfd)) {
-		write_strconst(test-&gt;rewritefd, &quot;STDOUT:\n&quot;);
-        write_file(test-&gt;rewritefd, test-&gt;outfd, test-&gt;eachline);
-    }
-}
-
-
-void print_test_summary()
-{
-    printf(&quot;\n&quot;);
-    printf(&quot;%d test%s run, &quot;, test_runs, (test_runs != 1 ? &quot;s&quot; : &quot;&quot;));
-    printf(&quot;%d success%s, &quot;, test_successes, (test_successes != 1 ? &quot;es&quot; : &quot;&quot;));
-    printf(&quot;%d failure%s.&quot;, test_failures, (test_failures != 1 ? &quot;s&quot; : &quot;&quot;));
-
-	if(!quiet) {
-		printf(&quot;    &quot;);
-		print_rusage();
-	}
-	
-	printf(&quot;\n&quot;);
-}
-
-
-void test_init(struct test *test)
-{
-    test_runs++;
-    memset(test, 0, sizeof(struct test));
-    test-&gt;rewritefd = -1;
-}
-
-
-void test_free(struct test *test)
-{
-	int err;
-
-	// the buffer for the testfile scanner is allocated on the stack.
-	if(test-&gt;eachline) {
-		pcrs_free_joblist(test-&gt;eachline);
-	}
-
-	if(test-&gt;diffname) {
-		err = close(test-&gt;diff_fd);
-		if(err &lt; 0) {
-			fprintf(stderr, &quot;Could not close %s: %s\n&quot;, test-&gt;diffname, strerror(errno));
-		}
-		err = unlink(test-&gt;diffname);
-		if(err &lt; 0) {
-			fprintf(stderr, &quot;Could not remove %s: %s\n&quot;, test-&gt;diffname, strerror(errno));
-		}
-		free(test-&gt;diffname);
-	}
-
-	if(test-&gt;status_reason) {
-		free(test-&gt;status_reason);
-	}
-
-	if(test-&gt;last_file_processed) {
-		free(test-&gt;last_file_processed);
-	}
-}
-
-

Copied: releases/0.94/test.c (from rev 99, trunk/test.c)

Deleted: releases/0.94/test.h
===================================================================
--- trunk/test.h	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test.h	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,85 +0,0 @@
-/* test.h
- * Scott Bronson
- * 29 Dec 2004
- *
- * All the data needed to run a test and print the results.
- * This file is covered by the MIT License.
- */
-
-#include &quot;pcrs.h&quot;
-#include &quot;matchval.h&quot;
-#include &quot;re2c/scan.h&quot;
-
-
-typedef enum {
-	test_pending=0,			///&lt; still processing config files
-	config_was_aborted,		///&lt; some config file called ABORT
-	config_was_disabled, 	///&lt; some config file called DISABLED
-
-	test_was_started=16,	///&lt; test was started but we haven't received an exit status yet.
-	test_was_completed,		///&lt; test completed normally.  tests may abort prematurely but still consider it a successful run, so use test_was_started.  this status is largely useless.
-	test_was_aborted,		///&lt; somebody called abort in the middle of the test.
-	test_was_disabled,		///&lt; the test was disabled by somebody.
-} test_status;
-
-
-#define was_started(st)  ((st) &gt;= test_was_started)
-#define was_aborted(st)  ((st) == config_was_aborted || (st) == test_was_aborted)
-#define was_disabled(st) ((st) == config_was_disabled || (st) == test_was_disabled)
-
-
-// Nonzero if we want to be as silent as possible
-// (only print results, no statistics or other useful conversation).
-extern int quiet;
-
-// If this is set, then we should use it as the config file rather than
-// checking /etc/tmtest.conf, ~/.tmtestrc, etc.
-extern char *config_file;
-
-// all strings are malloc'd and need to be freed when the test is finished.
-
-struct test {
-    const char *testfilename;   ///&lt; will be &quot;-&quot; if reading from stdin.
-    scanstate testfile;         ///&lt; scans the testfile.  may be stdin so seeking is not allowed.
-
-    int rewritefd;          ///&lt; where to dump the rewritten test.  -1 if we're just running the tests, or the fd of the file that should receive the test contents.
-
-    int outfd;				///&lt; the file that receives the test's stdout.
-    int errfd;				///&lt; the file that receives the test's stderr.
-    int statusfd;			///&lt; receives the runtime test status messages.
-    int exitno;				///&lt; the test's actual exit value.
-
-	pcrs_job *eachline;		///&lt; a linked list of pcrs jobs to be applied to each line.
-
-	char *diffname;			///&lt; if we're diffing against stdin, this contains the name of the required tempfile.
-	int diff_fd;			///&lt; if diffname is set, then this is the fd of the tempfile we're using to store stdin.
-
-	test_status status;		///&lt; Tells what happened with the test.
-	char *status_reason;	///&lt; If the test was aborted or disabled, and the user gave a reason why, that reason is stored here.  Allocated dynamically -- free it when done.
-
-	int num_config_files;	///&lt; the number of config files we started processing.  If the status is higher than test_was_started, then this gives the total number of config files processed.
-	char *last_file_processed; ///&lt; if it could be discovered, this contains the name of the last file to be started.  must be freed.
-	int aborted;			///&lt; true if the test was aborted (and therefore no further tests should be run).
-
-	int expected_exitno;	///&lt; the test's expected exit value.  this is only valid when stderr_match != match_unknown.
-
-    matchval exitno_match;	///&lt; tells whether the expected and actual exit values match.
-    matchval stdout_match;	///&lt; tells whether the expected and actual stdout matches.
-    matchval stderr_match;	///&lt; tells whether the expected and actual stderr matches.
-};
-
-
-void scan_status_file(struct test *test);
-void test_command_copy(struct test *test, FILE *fp);
-
-void test_results(struct test *test);
-void dump_results(struct test *test);
-void print_test_summary();
-
-void test_init(struct test *test);
-void test_free(struct test *test);
-
-
-// random utility function for start_diff:
-void write_raw_file(int outfd, int infd);
-

Copied: releases/0.94/test.h (from rev 99, trunk/test.h)

Deleted: releases/0.94/tfscan.c
===================================================================
--- trunk/tfscan.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/tfscan.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,261 +0,0 @@
-/* tfscan.c
- * Scott Bronson
- * 30 Dec 2004
- *
- * Scanner for test files.  This used to be a re2c scanner but
- * I couldn't get it to work with no LF at the end of file.
- *
- * This file is covered by the MIT License.
- */
-
-// TOTEST: &gt;8K token not containing a cr
-// STDOUT:, STDERR:, etc at the EOF with no data.
-// STDOUT at the beginning of the file.
-// keyword without a colon
-// 		NO NO NO keyword without a colon is still the keyword.
-// 		And a keyword without a NL is still the keyword.
-// 		But it must always start at the beginning of a new line.
-// exit clauses with invalid numbers
-// What happens with a MODIFY larger than BUFSIZ.
-// DOS/Mac/Unix line endings.
-// 		What happes when platform doesn't match the testfile?
-// 	Get rid of rewrite_command_section
-
-// NOTE: because we linebuffer the MODIFY clause, a single MODIFY
-// may not be larger than the BUFSIZ on your system (usually 8192 bytes).
-// Technically this is true of RESULT as well but when are you ever going
-// to run into an 8K result code?
-
-#include &quot;tfscan.h&quot;
-
-
-#define START(x) (ss-&gt;scanref=(void*)(x))
-
-#ifndef NULL
-#define NULL ((void*)0)
-#endif
-
-
-int tfscan_tok_start(scanstate *ss);
-int tfscan_nontok_start(scanstate *ss);
-
-
-/*!re2c
- 
-  // This is almost the scanner that this file implements, except that
-  // this file handles data at EOF correctly.
-
-WS      = [ \t];
-ANYN    = [\000-\377]\[\n];
-
-&quot;STDOUT&quot; WS* &quot;:&quot; ANYN* &quot;\n&quot;  { START(exSTDOUT); return exNEW|exSTDOUT; }
-&quot;STDERR&quot; WS* &quot;:&quot; ANYN* &quot;\n&quot;  { START(exSTDERR); return exNEW|exSTDERR; }
-&quot;RESULT&quot; WS* &quot;:&quot; ANYN* &quot;\n&quot;  { START(exRESULT); return exNEW|exRESULT; }
-&quot;MODIFY&quot; WS* &quot;:&quot; ANYN* &quot;\n&quot;  { START(exMODIFY); return exNEW|exMODIFY; }
-
-ANYN* &quot;\n&quot;                  { return (int)ss-&gt;scanref; }
-
-
-// What it does:
-// Returns exCOMMAND for all data chunks.
-// When it sees the start of a section, it returns exNEW|TOK
-// (i.e. (exNEW|exSTDOUT).  This tells you that the old section
-// has ended and a new one is starting.  Then it continues
-// returning exSTDOUT without the exNEW flag until another
-// seciton starts.
-
-*/
-
-
-
-static int scan_to_end_of_keyword(scanstate *ss, int tok)
-{
-	// We assume that we're immediately at the end of a keyword
-	// section.  The first six bytes just guarantees the keyword.
-
-	// skip all characters up to the final nl.
-
-	while(*YYCURSOR != '\r' &amp;&amp; *YYCURSOR != '\n') {
-		YYCURSOR++;
-		if(YYCURSOR &gt;= YYLIMIT) {
-			break;
-		}
-	}
-
-	if(*YYCURSOR == '\r') YYCURSOR++;
-	if(*YYCURSOR == '\n') YYCURSOR++;
-
-    ss-&gt;line += 1;
-
-	START(tok);
-	return exNEW|tok;
-}
-
-
-/* When it finds a line that begins
- * with a new section, it returns the token name of that section
- * with the exNEW flag turned on.  After that, it returns each
- * line in the section with the token's identifier.  Then, when it
- * finds a new section, you get a exNEW+TOKEN of the new section.
- */
-
-int tfscan_tok_start(scanstate *ss)
-{
-    scanner_enter(ss);
-
-    // if we can read at least 8 more bytes from the current buffer,
-    // we won't bother reloading it.  This should cut down drastically
-    // on the number of small reads we make.
-	if(YYCURSOR+8 &gt;= YYLIMIT) {
-		int r = (*ss-&gt;read)(ss);
-		// if there was an error, return an error token.
-		if(r &lt; 0) return r;
-		// Only if we're _completely_ out of data, return eof.
-		// (this is why we can't use re2c for this scanner)
-		if(ss-&gt;token &gt;= ss-&gt;limit) return 0;
-	}
-
-	// At this point in the scanner, we know that we are at the beginning
-    // of a line (previous character was either start-of-file or \n).
-	// So check to see if there's a token.
-
-	if(YYCURSOR + 8 &lt; YYLIMIT) {
-		// There's enough data in this buffer to contain a keyword.
-		// If there are less than 8 bytes in the buffer then it means
-		// that we're 7 bytes from the EOF and there's no chance that
-		// there's another keyword to scan.  (6 bytes for the keyword,
-		// 1 byte for the colon, one byte for the newline).
-		switch(*YYCURSOR) {
-			case 'S':
-				if(YYCURSOR[1] == 'T' &amp;&amp; YYCURSOR[2] == 'D') {
-					if(YYCURSOR[3]=='O' &amp;&amp; YYCURSOR[4]=='U' &amp;&amp; YYCURSOR[5]=='T') {
-						return scan_to_end_of_keyword(ss, exSTDOUT);
-					}
-					if(YYCURSOR[3]=='E' &amp;&amp; YYCURSOR[4]=='R' &amp;&amp; YYCURSOR[5]=='R') {
-						return scan_to_end_of_keyword(ss, exSTDERR);
-					}
-				}
-				// else it wasn't a token so we can just keep scanning.
-				break;
-			case 'R':
-				if(YYCURSOR[1]=='E' &amp;&amp; YYCURSOR[2]=='S' &amp;&amp;
-					YYCURSOR[3]=='U' &amp;&amp; YYCURSOR[4]=='L' &amp;&amp; YYCURSOR[5]=='T')
-				{
-					return scan_to_end_of_keyword(ss, exRESULT);
-				}
-				break;
-			case 'M':
-				if(YYCURSOR[1]=='O' &amp;&amp; YYCURSOR[2]=='D' &amp;&amp;
-					YYCURSOR[3]=='I' &amp;&amp; YYCURSOR[4]=='F' &amp;&amp; YYCURSOR[5]=='Y')
-				{
-					return scan_to_end_of_keyword(ss, exMODIFY);
-				}
-				break;
-			default:
-				break;
-		}
-	}
-
-	// So there wasn't a keyword at this point in the buffer.
-	// We just treat it as random data.  Since we haven't moved the
-    // cursor we can just call straight into the nontok routine.
-	ss-&gt;state = tfscan_nontok_start;
-	return tfscan_nontok_start(ss);
-}
-
-
-int tfscan_nontok_start(scanstate *ss)
-{
-	scanner_enter(ss);
-
-	if(YYCURSOR &gt;= YYLIMIT) {
-		int r = (*ss-&gt;read)(ss);
-		// if there was an error, return an error token.
-		if(r &lt; 0) return r;
-		// if we're completely out of data, return eof.
-		// (this is why we can't use re2c for this scanner)
-		if(ss-&gt;token &gt;= ss-&gt;limit) return 0;
-	}
-
-	// Since it's impossible to have a token at this point so we
-	// scan forward to the next CR/LF.
-	while(YYCURSOR &lt; YYLIMIT) {
-		if(*YYCURSOR == '\r' || *YYCURSOR == '\n') break;
-		YYCURSOR++;
-	}
-	if(YYCURSOR &gt;= YYLIMIT) {
-		// We have to assume that we previously read as much data as
-		// possible.  So the entire buffer is just data with no tokens
-		// and no CR/LF.
-		return (int)ss-&gt;scanref;
-	}
-
-	if(*YYCURSOR == '\r') YYCURSOR++;
-	if(*YYCURSOR == '\n') YYCURSOR++;
-
-    ss-&gt;line += 1;
-
-	// We have potential for finding a token at this point.
-	ss-&gt;state = tfscan_tok_start;
-	return (int)ss-&gt;scanref;
-}
-	
-
-
-/** Prepares the given scanner to scan a testfile.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* tfscan_attach(scanstate *ss)
-{
-    if(ss) {
-        START(exCOMMAND);
-        ss-&gt;state = tfscan_tok_start;
-    }
-
-    return ss;
-}
-
-/*
-
-SOME MORE THOUGHTS ON SCANNING:
-
-
-We know we're at the beginning of the buffer or immediately
-after a newline.
-	Do we have enough data for a keyword?
-		No: fill buffer with more data.
-	We know we have enough data for a keyword.  Use strstr.
-	
-See if a keyword is here.
-If 
-
-
-So what's the problem?
-	Read might return:
-		error, just return error code as negative number.
-		0, eof.
-			If we have more data in the buffer, we need to make sure
-			to return that data.
-			(actaully, with re2c, that's not the case.  It screws up the
-			last token in the file unless the file ends on a token delimiter).
-			- If there's no more data in the buffer then we just return 0.
-		positive number: we read data.
-
-So the problem is that re2c scanners can't handle it if the file doesn't
-end on a token delim.  We can't return if we hit eol and haven't scanned
-more data even if there's more data in the buffer.  The stupid re2c
-scanner will just start scanning in the garbage past the end of the buffer.
-Sigh.
-
-That means I can't use it for the testfile scanner.
-
-That furthermore means that I can't use YYFILL on the non-broken scanner.
-I should probably add a different macro that can be used everywhere,
-zero-length reads (as in a network packet), file ending with a non-delim
-character, etc.
-
-*/
-

Copied: releases/0.94/tfscan.c (from rev 99, trunk/tfscan.c)

Deleted: releases/0.94/tmlib.sh
===================================================================
--- trunk/tmlib.sh	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/tmlib.sh	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,180 +0,0 @@
-# tmlib.sh
-
-# Utilities useful for writing tmtest testfiles.
-# This file is covered by the MIT License.
-
-
-# TODO: should these routines be prefixed by &quot;TM&quot;?
-
-
-# Current functions:
-# ASSERT: Stop a test if a condition fails
-# ATEXIT: Ensure something gets cleaned up even if the test fails.
-# MKFILE MKFILE_EMPTY: create temporary files
-# MKDIR: create a temporary directory
-
-
-
-#
-# ASSERT
-#
-# If you include this file from either a config file or your
-# test file (&quot;. assert.sh&quot; or &quot;source assert.sh&quot;),
-# you can then use asserts in your test scripts.
-
-# usage:
-#   . assert.sh
-# 	assert 42 -eq $((0x2A))		# true, so test continues as normal
-# 	assert 1 -eq 2				# false, so the test is aborted.
-
-ASSERT ()
-{
-	if [ ! $* ]; then
-		msg=''
-		if [ ${BASH_VERSINFO[0]} -ge 3 ]; then
-			# bash2 doesn't provide BASH_SOURCE or BASH_LINENO
-			msg=&quot; on ${BASH_SOURCE[1]} line ${BASH_LINENO[0]}&quot;
-		fi
-		ABORT assertion failed$msg: \&quot;$*\&quot;
-	fi  
-}    
-
-
-#
-# TRAP
-#
-# This function makes trap behave more like atexit(3), where you can
-# install multiple commands to execute for the same condition.
-# I'm surprised that Bash doesn't do this by default.
-#
-# NOTE: you must not mix use of TRAP and trap on the same conndition.
-# The builtin trap will remove TRAP's condition, and all the commands
-# installed using TRAP will not be run.
-#
-# Call this routine exactly like the trap builtin: &quot;TRAP cmd cond&quot;
-#
-# Example:
-#
-#     TRAP &quot;echo debug!&quot; DEBUG
-#
-
-TRAP ()
-{
-	# install the trap if this is the first time TRAP is called for
-	# the given condition.  (Is there any way to get rid of &quot;local var&quot;??)
-
-	local var=TRAP_$2
-	if [ ! -n &quot;${!var}&quot; ]; then
-		trap &quot;eval \&quot;\$TRAP_$2\&quot;&quot; $2
-	fi
-
-
-	# This just adds $1 to the front of the string given by TRAP_$2.
-	# In Perl:		$TRAP{$2} = $1.($TRAP{$2} ? &quot;; &quot; : &quot;&quot;).$TRAP{$2}
-
-	eval TRAP_$2=\&quot;$1'${'TRAP_$2':+; }$'TRAP_$2\&quot;
-}
-
-
-#
-# ATEXIT
-#
-# This behaves just like atexit(3) call.  Supply a command to be executed
-# when the shell exits.  Commands are executed in the reverse order that
-# they are supplied.
-#
-# Example:  (will produce &quot;BA&quot; on stdout when the test ends)
-#
-#     ATEXIT echo A
-#     ATEXIT echo -n B
-
-ATEXIT ()
-{
-	TRAP &quot;$*&quot; EXIT
-}
-
-
-#
-# MKFILE
-#
-# Creates a file and assigns the new filename to the given variable.
-# Fills in the new file with the supplied data.  Ensures that it is
-# deleted when the test ends.
-#
-# argument 1: varname, the name of the variable that will contain the new filename.
-# argument 2: filename, (optional) the name/fullpath to give the file.
-#
-# You need to be aware that if you supply an easily predictable filename
-# (such as a PID), you are exposing your users to symlink attacks.  You
-# should never supply a filename unless you know EXACTLY what you are doing.
-#
-# Examples:
-#
-# create a new file with a random name in $TMPDIR or /tmp:
-#
-#     MKFILE fn &lt;&lt;-EOL
-#     	Initial file contents.
-#     EOL
-#     cat &quot;$fn&quot;		&lt;-- prints &quot;Initial file contents.&quot;
-#
-# create a new empty file with the given name (open to symlink attack,
-# DO NOT USE UNLESS YOU ARE SURE WHAT YOU ARE DOING).
-#
-#     MKFILE ttf /tmp/$mydir/tt1 &lt; /dev/null
-#
-
-MKFILE ()
-{
-	local name=${2-`mktemp -t tmtest.XXXXXX || ABORT MKFILE: could not mktemp`}
-	eval &quot;$1='$name'&quot;
-	cat &gt; &quot;$name&quot;
-	ATEXIT &quot;rm '$name'&quot;
-}
-
-
-#
-# MKFILE_EMPTY
-#
-# I can't figure out how to get bash to bail instead of blocking.
-# Therefore, if you just want to create an empty file, you either
-# call MKFILE piped from /dev/null or just call MKFILE_EMPTY.
-#
-
-MKFILE_EMPTY ()
-{
-	MKFILE &quot;$*&quot; &lt; /dev/null
-}
-
-
-#
-# MKDIR
-#
-# Like MKFILE, but creates a directory instead of a file.  If you
-# supply a directory name, and that directory already exists, then
-# MKDIR ensures it is deleted when the script ends.  The directory
-# will not be deleted if it still contains any files.
-#
-# argument 1: varname, the name of the variable that will contain the new directory name.
-# argument 2: dirname, (optional) the name/fullpath to give the directory.
-#
-# Examples:
-#
-# create a new directory with a random name in $TMPDIR or /tmp:
-#
-#     MKDIR dn
-#     cd &quot;$dn&quot;
-#
-
-MKDIR ()
-{
-	local name=${2}
-	if [ -z &quot;$name&quot; ]; then
-		name=`mktemp -d -t tmtest.XXXXXX || ABORT MKDIR: could not mktemp`
-	else
-		[ -d $name ] || mkdir --mode 0600 $name || ABORT &quot;MKDIR: could not 'mkdir \&quot;$name\&quot;'&quot;
-	fi
-
-	eval &quot;$1='$name'&quot;
-	ATEXIT &quot;rmdir '$name'&quot;
-}
-

Copied: releases/0.94/tmlib.sh (from rev 99, trunk/tmlib.sh)

Deleted: releases/0.94/tmtest.conf
===================================================================
--- trunk/tmtest.conf	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/tmtest.conf	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,63 +0,0 @@
-# tmtest.conf
-# Scott Bronson
-# 31 Dec 2004
-
-
-# This file tells how to run tests on tmtest itself.
-# See tmtestetc or tmtestrc for examples of globally-installed
-# configuration files.
-
-
-# This can be a little confusing because one copy of tmtest runs another
-# copy and checks its output.  We'll call the executable doing the testing
-# the superexec, and the program being tested the subexec.
-#
-# Because the user launched the superexec, we have no control over which
-# executable is used to run the tests.  Hopefully it's reasonably stable.
-#
-# This configuration file, tmtest.conf, tells the superexec how to run the
-# test battery.  Local settings are read from /etc/tmtest.conf, ~/.tmtestrc,
-# etc., then this file is loaded.
-#
-# The subtests do not read any configuration files outside of the test
-# directory except for one, tmtest.sub.conf.
-
-
-# turn on debugging
-# set -x
-
-
-# All tests are written to be pedantic.  We want them to exit at the
-# first sign of trouble and have the result code reported in RESULT.
-
-set -e
-
-
-
-# Add the current directory at the front of the PATH environment variable.
-# This means that while the test is running, any executables in this
-# directory will take priority over similarly-named executables anywhere
-# else (like /usr/bin or ~/bin).  This ensures that we lauch the unstable
-# copy of tmtest to handle each subtest.
-
-PATH=&quot;$MYDIR:$PATH&quot;;
-
-
-# All testfiles include $args in the arguments to the subexec.
-# (if they don't, it's a bug in the test).
-#
-# This allows us to specify default commands for all tests being run.
-# For instance, forcing the config file ensures that no config files
-# outside the test directory will be read.  This way we can be sure
-# that the tests are not succeeding due to some local configuration;
-# their environment is as clean as we can possibly make it.
-
-args=&quot;--config=$MYPATH/test/tmtest.sub.conf&quot;
-
-
-# This allows us to run tests without installing tmtest first.
-# (todo: will this cause problems if you DO have a currently-installed
-# tmtest?)
-
-. tmlib.sh
-

Copied: releases/0.94/tmtest.conf (from rev 99, trunk/tmtest.conf)

Deleted: releases/0.94/tmtest.pod
===================================================================
--- trunk/tmtest.pod	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/tmtest.pod	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,188 +0,0 @@
-=head1 NAME
-
-tmtest - Makes functional tests as easy to write as shell scripts.
-
-=head1 SYNOPSIS
-
-B&lt;tmtest&gt; [B&lt;-d&gt;|B&lt;-o&gt;] [I&lt;dir&gt;|I&lt;testfile&gt;...]
-
-=head1 DESCRIPTION
-
-
-
-=head1 OPTIONS
-
-=over 8
-
-=item B&lt;-c&gt; B&lt;--config&gt;
-
-Specifies the config file to be read before running the test file.
-Prevents the standard config files (/etc/tmtest.conf, /etc/tmtest/tmtest.conf,
-~/.tmtestrc) from being read.  Also doesn't read config files unless they
-are below the directory that contains the specified file.
-
-=item B&lt;-d&gt; B&lt;--diff&gt;
-
-Prints a diff of the expected results against the actual results.
-The expected results are the lines prefixed with a '-',
-and the actual results are prefixed with a '+'.
-In other words, the '+' lines are ones that the test erroneously added,
-and the '-' lines are ones that the test erroneously didn't print.
-
-You can pipe the output straight into the patch
-program to modify the test files.  This works when running tests
-in subdirectories too, but you need to invoke C&lt;patch -p0&gt; becaue
-the patch utility doesn't enter subdirectories by default.
-
-    tmtest -d | less        # view patch to ensure no bad changes
-    tmtest -d | patch -p0   # update every testfile.  Beware!
-
-DANGER!!!  This is the perfect way to let subtle bugs slip
-into your test deck.  Make sure you know exactly what you
-changed, right down to the whitespace.
-
-=item B&lt;-q&gt; B&lt;--quiet&gt;
-
-Tells tmtest to be quiet while running tests.  tmtest only prints the
-test results, and a final passed/failed/disabled summary.  So, it's
-quieter than it normally is but it certainly isn't silent.
-
-=back
-
-=head1 TESTFILE
-
-=over 8
-
-=item MODIFY
-
-Specifies a perl-compatible substitution command to be executed
-on each line of the program's output.  For instance,
-the following modify clause will replace DATE='2005-10-02' with
-DATE='DATE DATE'.
-
-	MODIFY: s/DATE='.*'/DATE='DATE DATE'/
-
-Due to a pcrs limitation, you may only specify one substitution
-command per MODIFY clause.  (&quot;MODIFY: s/1/one/ s/2/two/&quot; will not
-work.
-
-=back
-
-=head1 CONFIGURATION
-
-tmtest reads its configuration first from F&lt;/etc/tmtest.conf&gt; and
-F&lt;~/.tmtest.conf&gt;.  Then it starts at the root directory and works
-its way up to the current directory looking for files named &quot;tmtest.conf&quot;
-Therefore, /home/test/a/b/tmtest.conf overrides /home/test/tmtest.conf
-(because the latter is read and executed before the former).
-It executes each config files every time it runs a test.  If you're
-running 40 tests, your config files will each get executed 40 times.
-
-Note that while config files are running, the current directory
-is set to the testfile's directory.  For convenience, in each
-config file, the MYFILE variable gives the full pathname to the config
-file, and MYDIR gives just the directory portion (MYFILE and MYDIR
-are available when running the test script too -- MYDIR is just the
-current working directory).
-
-Any output produced by the config files goes straight to the screen.
-It will not contaminate the test results.  tmtest only cares about
-the output produced by the testfile itself.
-
-=over 8
-
-=item ABORT
-
-Causes the test to abort immediately.  You can optionally specify
-a message.  See the example in L&lt;/MKDIR&gt;.
-
-    ABORT: too bad this test won't live
-
-=item DISABLE
-=item DISABLED
-
-Marks the test disabled.  If put in a config file, marks all tests in
-that directory and all subdirectories disabled.
-
-You can supply a reason string too
-
-   DISABLED: this test is just too lame.
-
-=back
-
-=head1 EXIT VALUE
-
-tmtest returns a nonzero error code only if one or more tests
-could not be run for some reason.  If all tests are successfully run,
-even if they all fail, tmtest returns 0.
-
-=head1 SUGGESTIONS
-
-Look in the &quot;examples&quot; directory that came with this distribution.
-You may find some helpful utilities.
-
-If you want to be more pedantic, you might want to &quot;set -e&quot; in your
-test file or configuration file.  This will make it so the test will
-stop at the very first command that returns a nonzero exit status.
-
-If you can't figure out what your test is doing, you might want
-to add &quot;set -v&quot; or &quot;set -x&quot; to the top of the testfile.  This will
-show you line-by-line what is happening.  You can also put them in
-a config file if you're having configuration issues.
-
-Never create files in /tmp with static or easily predictable file names.
-This opens you up to symlink attacks.  Instead, use mktemp(1)
-or tempfile(1).  Also check the examples directory for functions
-to make working with files easier.
-
-	file=`mktemp -t 02-XXXXXX` || ABORT can't mktemp.
-
-=head1 FAQ
-
-How do I indent my stdout section?  My test prints the word &quot;STDOUT&quot; at
-the beginning of the line, causing tmtest to choke on the multiple STDOUT
-sections.
-
-A: Yes, tmtest is pedantic about finding sections in a file.  This is
-because it can be easy to get confused about what line applies where.
-Easiest just to ensure that there is a single section.
-
-But what to do if your test's output would contain a section break?
-Simply indent every line of your test's output by some number of spaces:
-
-	MODIFY : s/^(.)/   $1/
-
-The complex expression is because some versions of pcrs mistakenly
-add two spaces after tine final newline.  This ensures that the line
-actually contains a character before indenting it.
-
-=head1 HISTORY
-
-The original tmtest script was written in June of 2000 when I got frustrated
-with the TrestleMail mail relay program.  TrestleMail, now large and complex,
-required some serious reorganization.  I wrote tmtest as a quick one-off Perl
-hack to allow me to tear TrestleMail to shreds and have some hope of getting
-the peices back together.
-
-The Perl version was too slow and its testfile format took some learking.
-So, in early 2005, I rewrote the good parts in C and tried to make it as
-much like Bash as possible.
-
-=head1 LICENSE
-
-tmtest is distributed under the Lesser General Public License.
-See the COPYING file included with this tmtest distribution for
-more details or L&lt;<A HREF="http://www.gnu.org/copyleft/lesser.html">http://www.gnu.org/copyleft/lesser.html</A>&gt;.
-
-=head1 FILES
-
-L&lt;tmtest.conf(5)&gt;
-
-=head1 SEE ALSO
-
-L&lt;testfile(1)&gt;, L&lt;tmtest.conf(5)&gt;
-
-=head1 AUTHOR
-
-Scott Bronson &lt;S&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tmtest-commits">bronson at rinspin.com</A>&gt;&gt;
-

Copied: releases/0.94/tmtest.pod (from rev 90, trunk/tmtest.pod)

Deleted: releases/0.94/vars.c
===================================================================
--- trunk/vars.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/vars.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,267 +0,0 @@
-/* vars.c
- * Scott Bronson
- * 29 Dec 2004
- *
- * Interpolates $(VARS) in the test template (template.sh).
- * This file is covered by the MIT License.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;time.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;pwd.h&gt;
-#include &lt;assert.h&gt;
-
-#include &quot;test.h&quot;
-#include &quot;vars.h&quot;
-#include &quot;curdir.h&quot;
-
-#define CONFIG_FILE &quot;tmtest.conf&quot;
-#define HOME_CONFIG_FILE &quot;.tmtestrc&quot;
-
-
-/** @file vars.c
- *
- * Generates values for all the variables that appear in the
- * shell template.
- *
- * The functions in this file return errors only when there's a config
- * error (i.e. bad template variable, can't get user's login, etc).
- * They should ignore write errors.  They will happpen whenever the
- * test (or a config file) exits early and should properly be ignored.
- *
- * NOTE: this file is the only place in this project that we use
- * fileptrs.  Well, other than printing status information from main.c,
- * and, by proxy, the test_command_copy() routine.
- * Everywhere else we use Unix I/O.  Ensure they never mix.
- */
-
-static int var_testfile(struct test *test, FILE* fp, const char *var)
-{
-	fprintf(fp, &quot;%s/%s&quot;, curabsolute(), test-&gt;testfilename);
-    return 0;
-}
-
-static int var_testdir(struct test *test, FILE* fp, const char *var)
-{
-	fputs(curabsolute(), fp);
-    return 0;
-}
-
-
-static int var_testexec(struct test *test, FILE* fp, const char *var)
-{
-    // If the filename is a dash, it means we should feed the test
-    // from stdin.  Otherwise, just have the shell execute the testfile.
-
-    if(test-&gt;testfilename[0] == '-' &amp;&amp; test-&gt;testfilename[1] == '\0') {
-		// bash doesn't support setting LINENO any more but,
-		// what the hell, it's worth a shot.
-		fprintf(fp, &quot;LINENO=0\n&quot;);
-        test_command_copy(test, fp);
-    } else {
-        test_command_copy(test, NULL);
-        fprintf(fp, &quot;. '%s/%s'&quot;, curabsolute(), test-&gt;testfilename);
-    }
-
-    return 0;
-}
-
-
-static int var_outfd(struct test *test, FILE *fp, const char *var)
-{
-    fprintf(fp, &quot;%d&quot;, test-&gt;outfd);
-    return 0;
-}
-
-static int var_errfd(struct test *test, FILE *fp, const char *var)
-{
-    fprintf(fp, &quot;%d&quot;, test-&gt;errfd);
-    return 0;
-}
-
-static int var_statusfd(struct test *test, FILE *fp, const char *var)
-{
-    fprintf(fp, &quot;%d&quot;, test-&gt;statusfd);
-    return 0;
-}
-
-
-/** Returns the full path to the user's home directory.
- */
-
-static char* get_home_dir()
-{
-	char *cp;
-	struct passwd *entry;
-	
-	cp = getenv(&quot;HOME&quot;);
-	if(cp) return cp;
-	cp = getenv(&quot;LOGDIR&quot;);
-	if(cp) return cp;
-
-	entry = getpwuid(getuid());
-	if(entry) {
-		cp = entry-&gt;pw_dir;
-		if(cp) return cp;
-	}
-
-	fprintf(stderr, &quot;Could not locate your home directory!\n&quot;);
-	exit(10);
-}
-
-
-/** Returns true if the given file exists, false if not.
- */
-
-int file_exists(char *path)
-{
-	struct stat st;
-	return stat(path, &amp;st) == 0 &amp;&amp; S_ISREG(st.st_mode);
-}
-
-
-
-#define check_config_str(t,f,s,n) check_config((t),(f),(s),strlen(s),(n))
-
-
-/** Checks to see if the file exists and, if it does, then it
- *  outputs the appropriate commands.
- *
- *  @param base The path.
- *  @param len The number of characters from base to use.
- *  @param name The filename.  It will be concatenated with a '/'
- *  onto the end of base.  Optional: if name is null then base will
- *  be used directly.  This is a 0-terminated string.
- *
- *  @see var_config_files()
- */
-
-static void check_config(struct test *test, FILE *fp,
-		const char *base, int len, const char *name)
-{
-	char buf[PATH_MAX];
-	
-	// if the buffer isn't big enough then don't even try.
-	if(len+(name?strlen(name):0)+2 &gt; sizeof(buf)) return;
-
-	// assemble the file name
-	memcpy(buf, base, len);
-	buf[len]='\0';
-
-	// append the filename if supplied
-	if(name) {
-		buf[len] = '/';
-		buf[len+1] = 0;
-		strcat(buf+len+1, name);
-	}
-
-	if(config_file &amp;&amp; strcmp(buf,config_file) == 0) {
-		// If buf == config_file then it means the user must have
-		// specified a config file within the current search path.
-		// This ensures that we don't include it twice.
-		return;
-	}
-
-	if(file_exists(buf)) {
-		fprintf(fp, &quot;echo 'CONFIG: %s' &gt;&amp;%d\n&quot;, buf, test-&gt;statusfd);
-		fprintf(fp, &quot;MYDIR='%.*s'\nMYFILE='%s'\n. '%s'\n&quot;, len, buf, buf, buf);
-	}
-}
-
-
-/** Prints the shell commands needed to read in all available config files.
- *
- * for instance:
- *
- *     echo 'CONFIG: /etc/tmtest' &gt;&amp;5
- *     . '/etc/tmtest'
- *     echo 'CONFIG: /home/bronson/tmtest/tmtest.conf' &gt;&amp;5
- *     . '/home/bronson/tmtest/tmtest.conf'
- *
- *     and so on...
- */
-
-static int var_config_files(struct test *test, FILE *fp, const char *var)
-{
-	char buf[PATH_MAX];
-    char *cp;
-	int confbaselen;
-
-	// check global configuration files
-	if(config_file) {
-		// Need to obliterate config_file, otherwise it will think that
-		// it has included config_file twice and refuse to include it.
-		char *oldcfg = config_file;
-		config_file = NULL;
-		check_config_str(test, fp, oldcfg, NULL);
-		config_file = oldcfg;
-	} else {
-		check_config_str(test, fp, &quot;/etc&quot;, CONFIG_FILE);
-		check_config_str(test, fp, &quot;/etc/tmtest&quot;, CONFIG_FILE);
-		check_config_str(test, fp, get_home_dir(), HOME_CONFIG_FILE);
-	}
-
-	// check config files in the current hierarchy
-	strncpy(buf, curabsolute(), sizeof(buf));
-	if(config_file) {
-		confbaselen = strrchr(config_file, '/') - config_file;
-	}
-    for(cp=buf; (cp=strchr(cp,'/')); cp++) {
-		// If the user specifies a config file, we only check directories
-		// not above the given config file.  i.e. if user specifies
-		// &quot;tmtest -c /a/b/cc /a/t/u/t.test&quot;, we will look for config files
-		// in /a/t/tmtest.conf and /a/t/u/tmtest.conf.
-		if(config_file &amp;&amp; cp-buf &lt;= confbaselen &amp;&amp;
-				memcmp(buf, config_file, cp-buf)==0) {
-			continue;
-		}
-		check_config(test, fp, buf, cp-buf, CONFIG_FILE);
-    }
-	check_config_str(test, fp, buf, CONFIG_FILE);
-
-    return 0;
-}
-
-
-/** Prints the value for variable varname to file fp.
- * Returns zero if successful, nonzero if not.
- */
-
-int printvar(struct test *test, FILE *fp, const char *varname)
-{
-    int i;
-
-    struct {
-        char *name;
-        int (*func)(struct test *test, FILE *fp, const char *var);
-    } funcs[] = {
-        { &quot;CONFIG_FILES&quot;,   var_config_files },
-        { &quot;OUTFD&quot;,          var_outfd },
-        { &quot;ERRFD&quot;,          var_errfd },
-        { &quot;STATUSFD&quot;,       var_statusfd },
-        { &quot;TESTFILE&quot;,       var_testfile },
-        { &quot;TESTEXEC&quot;,       var_testexec },
-        { &quot;TESTDIR&quot;,        var_testdir },
-    };
-
-    for(i=0; i&lt;sizeof(funcs)/sizeof(funcs[0]); i++) {
-        if(strcmp(varname, funcs[i].name) == 0) {
-            if(funcs[i].func) {
-                return (*funcs[i].func)(test, fp, varname);
-            } else {
-                fprintf(fp, &quot;&lt;&lt;&lt;%s&gt;&gt;&gt;&quot;, varname);
-                return 0;
-            }
-        }
-    }
-
-    fprintf(stderr, &quot;Unknown variable '%s' in template.\n&quot;, varname);
-    return 1;
-}
-

Copied: releases/0.94/vars.c (from rev 99, trunk/vars.c)

Deleted: releases/0.94/vars.h
===================================================================
--- trunk/vars.h	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/vars.h	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,2 +0,0 @@
-struct test;
-int printvar(struct test *test, FILE *fp, const char *varname);

Copied: releases/0.94/vars.h (from rev 99, trunk/vars.h)

Added: releases/tmtest-0.92.tar.gz
===================================================================
(Binary files differ)


Property changes on: releases/tmtest-0.92.tar.gz
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: releases/tmtest-0.94.tar.gz
===================================================================
(Binary files differ)


Property changes on: releases/tmtest-0.94.tar.gz
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream




</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000018.html">[Tmtest-commits] [101] releases/0.92: Minor update to 0.92 to make it distributable and
</A></li>
	<LI>Next message: <A HREF="000020.html">[Tmtest-commits] [103] trunk: Tmtest would get confused by .
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19">[ date ]</a>
              <a href="thread.html#19">[ thread ]</a>
              <a href="subject.html#19">[ subject ]</a>
              <a href="author.html#19">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tmtest-commits">More information about the Tmtest-commits
mailing list</a><br>
</body></html>
