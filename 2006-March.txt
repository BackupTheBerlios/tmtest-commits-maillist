From tmtest-commits at berlios.de  Wed Mar  1 15:57:56 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Wed, 1 Mar 2006 15:57:56 +0100
Subject: [Tmtest-commits] [98] trunk: Add tests for an empty test with empty stdout or stderr
Message-ID: <200603011457.k21Evu9d024637@sheep.berlios.de>

Revision: 98
Author:   bronson
Date:     2006-03-01 15:57:44 +0100 (Wed, 01 Mar 2006)

Log Message:
-----------
Add tests for an empty test with empty stdout or stderr clause.

Modified Paths:
--------------
    trunk/CHANGES
    trunk/TODO
    trunk/examples/docs/Modify3.test

Added Paths:
-----------
    trunk/test/03-results/15-EmptyWithErr.test
    trunk/test/03-results/15-EmptyWithOut.test
    trunk/test/03-results/16-EmptyWithErrNoNL.test
    trunk/test/03-results/16-EmptyWithOutNoNL.test
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-28 22:05:17 UTC (rev 97)
+++ trunk/CHANGES	2006-03-01 14:57:44 UTC (rev 98)
@@ -1,6 +1,6 @@
 - Release next version.
 ----
-- --dump-script now cleans up after itself.
+- --dump-script now cleans up after itself (before we'd leave turds in /tmp).
 - Now reports in the test results if child was terminated by a signal.
 - Added the INDENT and REPLACE functions to tmlib.
 - Bash3 has made it so that the RE can no longer appear on the same line as

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-02-28 22:05:17 UTC (rev 97)
+++ trunk/TODO	2006-03-01 14:57:44 UTC (rev 98)
@@ -1,20 +1,28 @@
 0.94:
-- An empty test with a STDOUT clause should fail without the -n right?
-  I mean, there's no newline in the actual output, but there is in the
-  expected...
-- write tests for nesting testfiles with --config.
-        // If the user specifies a config file, we only check directories
-        // not above the given config file.  i.e. if user specifies
-        // "tmtest -c /a/b/cc /a/t/u/t.test", we will look for config files
-        // in /a/t/tmtest.conf and /a/t/u/tmtest.conf.
+- Print a warning if we notice that an output section doesn't end in
+  a newline, but the testfile hasn't marked that section with a "-n".
+  See 22-PatchNoNL2.test for more.  Make sure a test for this is in 03 too.
+
+0.96:
+- Get rid of MODIFY clauses.  It's unnecessary complexity.
+  And it's a LOT.  First remove it from the tests, then from the code.
 - Add the ability to specify test arguments on the command line.
   I'm picturing something where VAR=val on the command line would be
   inserted without change into the template.  That way you can use the
   command line to override default settings in the testfile.
   - This would allow us to test almost every test to ensure it
     supports the --config argument (make them DISABLED or something).
+- write tests for nesting testfiles with --config.
+        // If the user specifies a config file, we only check directories
+        // not above the given config file.  i.e. if user specifies
+        // "tmtest -c /a/b/cc /a/t/u/t.test", we will look for config files
+        // in /a/t/tmtest.conf and /a/t/u/tmtest.conf.
+- get rid of all the exit(10) calls in test.c.  We need a better way to
+  abort the test.
+  should get rid of a whole bunch in main.c as well.
+  this should prevent us from dropping turds in /tmp all the time too.
 
-0.96:
+0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.
   Convert to using the async io library.  Don't use temporary files.
   This would allow us to recognize that the test is disabled before
@@ -27,12 +35,6 @@
   the rest of the test script?  And why is it that if you fork, diff freezes?
   They're related problems I suspect.
     Is it because I'm forgetting to close all open filehandles before forking?
-- Tighten up printing a folder name when there are no testfiles in it.
-  No need for double spacing.
-- Add the ability to run multiple tests from one testfile.
-  See tmtest 0.8 for a potential implementation of this.
-  All we'd need to add is a framework to notify the user that multiple
-  tests are in progress; bash can take care of the rest.
 - Shouldn't run every test in a dir if the DISABLED directive is in a config
   file.
   Should discover what dir the DISABLED directive came from and refuse
@@ -40,19 +42,16 @@
   - Yes, if a config file returns DISABLED, then that folder and all its
     subfolders are skipped.  Just make the test itself call the DISABLED
 	command if you want testing to continue in that subfolder.
-- Print a warning if we notice that an output section doesn't end in
-  a newline, but the testfile hasn't marked that section with a "-n".
-  See 22-PatchNoNL2.test for more.  Make sure a test for this is in 03 too.
+- Tighten up printing a folder name when there are no testfiles in it.
+  No need for double spacing.
 
-0.98:
-- get rid of all the exit(10) calls in test.c.  We need a better way to
-  abort the test.
-  should get rid of a whole bunch in main.c as well.
-  this should prevent us from dropping turds in /tmp all the time too.
-- Get rid of MODIFY clauses.  It's unnecessary complexity.
-  And it's a LOT.  First remove it from the tests, then from the code.
+1.0!
 
-1.0:
+1.2:
+- Add the ability to run multiple tests from one testfile.
+  See tmtest 0.8 for a potential implementation of this.
+  All we'd need to add is a framework to notify the user that multiple
+  tests are in progress; bash can take care of the rest.
 
 ?:
 - add gcov support so you can see what sort of coverage your tests provide.
@@ -63,7 +62,7 @@
   directory hierarchy.
 - add the ability to run valgrind over each test and print success/failure
   of that.  (gives deep valgrind coverage)
-  - One problem with this will be all the false warnings.
+  - One problem with this will be all the false warnings that valgrind spews.
 
 No longer a problem when we dump pcrs:
 - allow multiple s/// expressions on a single line.  will probably require

Modified: trunk/examples/docs/Modify3.test
===================================================================
--- trunk/examples/docs/Modify3.test	2006-02-28 22:05:17 UTC (rev 97)
+++ trunk/examples/docs/Modify3.test	2006-03-01 14:57:44 UTC (rev 98)
@@ -2,6 +2,6 @@
 
 date
 MODIFY:
-  s/... +... +[0-9][0-9] +[0-9]?[0-9]:[0-9][0-9]:[0-9][0-9] +... +20[0-9][0-9]/date date date/
+  s/... +... +[0-9]?[0-9] +[0-9]?[0-9]:[0-9][0-9]:[0-9][0-9] +... +20[0-9][0-9]/date date date/
 STDOUT:
 date date date

Added: trunk/test/03-results/15-EmptyWithErr.test
===================================================================
--- trunk/test/03-results/15-EmptyWithErr.test	2006-02-28 22:05:17 UTC (rev 97)
+++ trunk/test/03-results/15-EmptyWithErr.test	2006-03-01 14:57:44 UTC (rev 98)
@@ -0,0 +1,10 @@
+# A blank test with an empty stderr clause should succeed because
+# the stdout clause doesn't contain anything -- not even a newline.
+
+tmtest -q - <<-EOL
+	STDERR:
+EOL
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/03-results/15-EmptyWithOut.test
===================================================================
--- trunk/test/03-results/15-EmptyWithOut.test	2006-02-28 22:05:17 UTC (rev 97)
+++ trunk/test/03-results/15-EmptyWithOut.test	2006-03-01 14:57:44 UTC (rev 98)
@@ -0,0 +1,10 @@
+# A blank test with an empty stdout clause should succeed because
+# the stdout clause doesn't contain anything -- not even a newline.
+
+tmtest -q - <<-EOL
+	STDOUT:
+EOL
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/03-results/16-EmptyWithErrNoNL.test
===================================================================
--- trunk/test/03-results/16-EmptyWithErrNoNL.test	2006-02-28 22:05:17 UTC (rev 97)
+++ trunk/test/03-results/16-EmptyWithErrNoNL.test	2006-03-01 14:57:44 UTC (rev 98)
@@ -0,0 +1,11 @@
+# A blank test with an empty stderr clause should succeed (see
+# 15-BlankWithErr.test), so adding -n should not change the
+# results at all.
+
+tmtest -q - <<-EOL
+	STDERR: -n
+EOL
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/03-results/16-EmptyWithOutNoNL.test
===================================================================
--- trunk/test/03-results/16-EmptyWithOutNoNL.test	2006-02-28 22:05:17 UTC (rev 97)
+++ trunk/test/03-results/16-EmptyWithOutNoNL.test	2006-03-01 14:57:44 UTC (rev 98)
@@ -0,0 +1,11 @@
+# A blank test with an empty stdout clause should succeed (see
+# 15-BlankWithOut.test), so adding -n should not change the
+# results at all.
+
+tmtest -q - <<-EOL
+	STDOUT: -n
+EOL
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.





From tmtest-commits at berlios.de  Fri Mar  3 00:57:07 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Fri, 3 Mar 2006 00:57:07 +0100
Subject: [Tmtest-commits] [99] trunk: Major changes.
Message-ID: <200603022357.k22Nv7po015763@sheep.berlios.de>

Revision: 99
Author:   bronson
Date:     2006-03-03 00:56:35 +0100 (Fri, 03 Mar 2006)

Log Message:
-----------
Major changes.  Fix config file handling and a bunch of other stuff.

Modified Paths:
--------------
    trunk/BUGS
    trunk/CHANGES
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/compare.h
    trunk/curdir.c
    trunk/main.c
    trunk/test/01-testfile/08-GarbageInStdout.test
    trunk/test/01-testfile/10-DumpScript.test
    trunk/test/02-running/21-QuoteFile.test
    trunk/test/02-running/40-Replace.test
    trunk/test/03-results/33-BinaryHuge.test
    trunk/test/04-diff/01-Diff.test
    trunk/test/04-diff/02-MultiDiff.test
    trunk/test/04-diff/05-AbortDiff.test
    trunk/test/04-diff/21-PatchNoNL.test
    trunk/test/04-diff/22-PatchNoNL2.test
    trunk/test/04-diff/23-PatchNoNL3.test
    trunk/test/tmtest.sub.conf
    trunk/test.c
    trunk/test.h
    trunk/tfscan.c
    trunk/tmlib.sh
    trunk/tmtest.conf
    trunk/vars.c
    trunk/vars.h

Added Paths:
-----------
    trunk/examples/docs/testfile/
    trunk/examples/docs/testfile/Idiom-Indent1.test
    trunk/examples/docs/testfile/Idiom-Indent2.test
    trunk/examples/docs/testfile/Idiom-Indent3.test
    trunk/examples/docs/testfile/Idiom-Replace1.test
    trunk/test/00-cmdline/10-CfgDir.test
    trunk/test/00-cmdline/11-CfgMissing.test
    trunk/test/00-cmdline/12-CfgEmpty.test
    trunk/test/01-testfile/02-StdOutNK.test
    trunk/test/01-testfile/03-StdErrNK.test
    trunk/test/01-testfile/11-InnerConfig.test
    trunk/test/01-testfile/20-TestVars.test
    trunk/test/01-testfile/21-TestVarsABS.test
    trunk/test/01-testfile/22-TestVarsRel.test
    trunk/test/02-running/41-Indent.test
    trunk/test/03-results/01-YstderrOut.test
    trunk/test/03-results/01-YstdoutOut.test
    trunk/test/03-results/14-NoNLWarn.test
    trunk/test/03-results/17-NoStderr.test
    trunk/test/03-results/18-NoNLWarnOut.test
    trunk/test/04-diff/18-NeedNLWarn.test
Modified: trunk/BUGS
===================================================================
--- trunk/BUGS	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/BUGS	2006-03-02 23:56:35 UTC (rev 99)
@@ -8,6 +8,7 @@
 
 Bash Gotchas:
 
+These are bugs that tmtest inherits from Bash:
 
 Bash3 has removed the ability to set LINENO, so you may see the
 wrong line number be printed if there's an error.  If you want to
@@ -26,18 +27,29 @@
 	EOL
 
 The first heredoc flattens everything and then the EOLs get mixed up.
+Sometimes you can work around this by renaming your EOL words,
+sometimes you can't.
+
+Another problem is that Bash ONLY strips tabs.  This makes it a royal
+pain to edit heredocs in an editor that expands tabs.  Thanks to
+how common Python is becoming, many editors are expanding tabs now!
+If you edit a bash script with an editor that automatically expands
+tabs, you may destroy the heredoc even though you never even saw it!
+Invisible syntax problems always suck.
+
 What bash *SHOULD* do (and what tmtest did before it was integrated
 with Bash) is discover the whitespace sequence indenting the
 first line of a heredoc, then remove exactly that sequence from all
 subsequent lines.  If a line doesn't begin with that sequence, then
-it is unchanged.  This is safer and more useful than just blowing away
+it remains unchanged.  This is safer and more useful than just blowing away
 all tabs wholesale!
 
 
-Bashisms:
+Strange Bashisms:
 
 Why does &> redirect both stdout and stderr to a file, but &| doesn't
 redirect both stdout and stderr to a pipe?
 
 Why is the unset command totally unrelated to the set command?
 
+Why can I "exec > file" but I can't "exec | prog"?

Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/CHANGES	2006-03-02 23:56:35 UTC (rev 99)
@@ -1,22 +1,24 @@
-- Release next version.
-----
+get rid of ATEXIT from template.sh.  Can also merge 3>&- and 5>& in template.sh
+- Release 0.94 on 2 Mar 2006
+- NOTE: Bash3 has made it so that the regex can not appear on the same line as
+  the MODIFY keyword.  I updated all tests and accelerated MODIFY deprecation.
+- Added the INDENT and REPLACE functions to tmlib.
+- Standardized licensing: everything under my control is MIT, package is LGPL.
 - --dump-script now cleans up after itself (before we'd leave turds in /tmp).
-- Now reports in the test results if child was terminated by a signal.
-- Added the INDENT and REPLACE functions to tmlib.
-- Bash3 has made it so that the RE can no longer appear on the same line as
-  the MODIFY command.  I updated all tests and accelerated MODIFY deprecation.
+- Now reports in the test results when child is terminated by a signal.
+- When installing locally, it's ~/.tmlib.sh instead of ~/share/tmtest/tmlib.sh
 - Added -n (--no-trailing-newline) capability to STDOUT and STDERR sections.
+- Got rid of all AUTHOR and DATE automation.  Too heavyhanded.
+- Added --patch/-p to do the same thing as --diff/-d.  Just feels natural.
+- Now only "\nSTDOUT[ \t\r\n:]" starts a section.  Anything else is just data.
 - Rewrote the re2c parser in C so we should now be totally binary transparent.
-- Got rid of all AUTHOR and DATE automation.  Too heavyhanded.
-- Standardized licensing: everything under my control is MIT, package is LGPL.
-- When installing locally, it's ~/.tmlib.sh instead of ~/share/tmtest/tmlib.sh
 
 - Bump to 0.92
+- Tests now start with /tmp as the cwd, not the testdir.
+  The testdir is supplied in $TESTDIR (or $MYDIR inside the testfile)
+- Added timing information to test summary.  Disable with new -q option.
+- Added the --config option to override default config files.
 - install now installs config files too.
-- Added the --config option to override default config files.
-- Added timing information to test summary.  Disable with new -q option.
 - Created tmlib, a "standard library" for tests.
 - We now stop running all tests if any test aborts.  DISABLE stops the current
   test but lets all other tests finish; ABORT stops testing altogether.
-- Tests now start with /tmp as the cwd, not the testdir.
-  The testdir is supplied in $TESTDIR (or $MYDIR inside the testfile)

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/Makefile	2006-03-02 23:56:35 UTC (rev 99)
@@ -65,7 +65,9 @@
 install: tmtest
 	install -d -m755 $(bindir)
 	install tmtest $(bindir)
+ifneq ($(libdir),$(HOME))
 	install -d -m755 $(libdir)
+endif
 	install tmlib.sh $(stdlib)
 ifeq ($(wildcard $(conf_dst)),$(conf_dst))
 	# configuration already exists, don't overwrite it.

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/TODO	2006-03-02 23:56:35 UTC (rev 99)
@@ -1,9 +1,11 @@
-0.94:
-- Print a warning if we notice that an output section doesn't end in
-  a newline, but the testfile hasn't marked that section with a "-n".
-  See 22-PatchNoNL2.test for more.  Make sure a test for this is in 03 too.
-
 0.96:
+- Put $args into EVERY test we run.
+- There's some sort of a bug with 10-DumpScript.test.  When running with
+  -o or -d, sometimes it complains about a missing newline.  Odd.
+- Write a test to ensure we can run tests named "-.test"
+- Write tests to verify what FDs are still open when we run
+  config files, test files, and diff.
+- Add --diff and --shell to change the executables that get launched.
 - Get rid of MODIFY clauses.  It's unnecessary complexity.
   And it's a LOT.  First remove it from the tests, then from the code.
 - Add the ability to specify test arguments on the command line.
@@ -21,16 +23,27 @@
   abort the test.
   should get rid of a whole bunch in main.c as well.
   this should prevent us from dropping turds in /tmp all the time too.
+- Rename --all-files to --ignore-extension.
+- Move newline suppressing out of compare.c.  If it can't be moved out,
+  at least clean it up!   (maybe?)
+- Figure out how to ensure that we run the binary in the project tree
+  when testing rather than the globally installed one.  What happened?
+- Ensure it compiles and runs on freebsd.
 
 0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.
   Convert to using the async io library.  Don't use temporary files.
   This would allow us to recognize that the test is disabled before
   producing a partial diff, blowing away output sections.
+  - Make sure to keep reading both stdin and stderr to eof.
+  - This also allows us to get rid of STATUSFD so that NO other fds are open
+    when running the test.  OUTFD and ERRFD still need to be open when
+	running the config files though.
 - Use i/o lib for everything.  No need for temp files.
   This means that we stream everything EXCEPT stderr, which we memory
   buffer.  If your stderr is more than 100K or so in size, just redirect
-  it to stdout.
+  it to a file, then cat the file at the end.  We truncate stderr if it
+  gets too big.
 - stdin is all buggered up.  why is it that "cat" with no args will print
   the rest of the test script?  And why is it that if you fork, diff freezes?
   They're related problems I suspect.
@@ -44,6 +57,10 @@
 	command if you want testing to continue in that subfolder.
 - Tighten up printing a folder name when there are no testfiles in it.
   No need for double spacing.
+- Add a --continuous argument that will cycle through all tests tmtest
+  can find.  It prints nothing if a test succeeds, or the fail notice
+  if it fails.  Runs until cancelled with ^C.  Let it run overnight and
+  see if any of your tests have intermittent failures.
 
 1.0!
 
@@ -63,6 +80,15 @@
 - add the ability to run valgrind over each test and print success/failure
   of that.  (gives deep valgrind coverage)
   - One problem with this will be all the false warnings that valgrind spews.
+- Get rid of exNEW and all the definitions from tfscan.h.  It's uuuugly!
+  Not quite sure how... I mean, I see how to clean it up some but not
+  a lot.  Probably not worth it.  It's an ugly problem.
+- Is it possible to add a SECOND diff to the output from tmtest -d to
+  add a "-n" to the output section?  That way, instead of printing a
+  warning telling the user what to edit, we could just fix it ourselves.
+  See 18-NoNLWarn.test for more.
+- Maybe make an option to run the command from a pty so it looks just
+  like the user is running the command.
 
 No longer a problem when we dump pcrs:
 - allow multiple s/// expressions on a single line.  will probably require

Modified: trunk/compare.c
===================================================================
--- trunk/compare.c	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/compare.c	2006-03-02 23:56:35 UTC (rev 99)
@@ -41,8 +41,9 @@
 	const char *pbuf;
 	int pcursor;
 	int plimit;
-    int no_trailing_newline;
-    int nl_suppressed;
+    int no_trailing_newline;    ///< true if this section isn't supposed to end with a newline
+    int nl_suppressed;          ///< if no_trailing_newline is true, we need to suppress the newline in the execpted output when matching against the actual (because of the way heredocs work, the expected always ends in a newline).
+    int warn_no_newline;             ///< true if the section expected a trailing newline (no_trailing_newline == false), but the last buffer seen (presumably the end of the file) didn't end with a newline.
 } compare_state;
 
 
@@ -61,9 +62,6 @@
 {
 	compare_state *cmp = (compare_state*)ss->scanref;
     *cmp->output = newval;
-	if(cmp->pbuf) free((char*)cmp->pbuf);
-	free(cmp);
-    ss->scanref = NULL;
 }
 
 
@@ -81,7 +79,8 @@
 	cmp->output = mv;
 	cmp->jobs = jobs;
     cmp->no_trailing_newline = nonl;
-    cmp->nl_suppressed = 0;;
+    cmp->nl_suppressed = 0;
+    cmp->warn_no_newline = 0;
     ss->scanref = cmp;
 }
 
@@ -89,6 +88,7 @@
 
 static void compare_continue_bytes(scanstate *ss, const char *ptr, int len)
 {
+	compare_state *cmp = (compare_state*)ss->scanref;
     int n;
 
     while(len > 0) {
@@ -106,6 +106,12 @@
                 compare_halt(ss, match_no);
                 return;
             }
+           
+            if(n > 0) {
+                // shouldn't force user to put a -n on empty sections!
+                // therefore, we'll only issue the warning if we've seen data.
+                cmp->warn_no_newline = (ss->limit[-1] != '\n' && ss->limit[-1] != '\r');
+            }
         }
 
         if(len < n) {
@@ -240,8 +246,8 @@
 {
 	compare_state *cmp = (compare_state*)ss->scanref;
 
-    if(!ss->scanref) {
-        // we already decided the files don't match
+    if(*cmp->output != match_inprogress) {
+        // we already decided an answer
         // so don't waste time comparing more.
         return;
     }
@@ -273,39 +279,36 @@
 }
 
 
-void compare_end(scanstate *ss)
+void compare_end(scanstate *ss, int *warn_nl)
 {
 	compare_state *cmp = (compare_state*)ss->scanref;
 
-    if(!ss->scanref) {
-        // we already decided the files don't match
-        // so don't waste time comparing more.
-        return;
+    // Tell the caller to emit a warning if the expected section was marked
+    // as having a trailing newline but the actual section didn't have it.
+    if(warn_nl && !cmp->no_trailing_newline) {
+        *warn_nl = cmp->warn_no_newline;
     }
 
-	assert(cmp->pcursor <= cmp->plimit);
-	assert(ss->cursor <= ss->limit);
+    if(*cmp->output == match_inprogress) {
+        assert(cmp->pcursor <= cmp->plimit);
+        assert(ss->cursor <= ss->limit);
 
-	if(cmp->jobs) {
-		// if there's more data in the pbuf then fail.
-		if(cmp->plimit - cmp->pcursor != 0) {
-			compare_halt(ss, match_no);
-			return;
-		}
-	}
+        *cmp->output = match_no;
+        if(cmp->jobs && cmp->plimit - cmp->pcursor != 0) {
+            // get rid of this asap.
+            *cmp->output = match_no;
+        } else if(scan_finished(ss)) {
+            // if we're totally out of data and we still don't know
+            // if they match, then they do match.
+            *cmp->output = match_yes;
+        }
+    }
 
-	// if we have no data left in the scan buffer
-	if(ss->cursor == ss->limit) {
-		// and our input file is at eof
-		if(compare_fill(ss) == 0) {
-			// then the two data streams match
-			compare_halt(ss, match_yes);
-			return;
-		}
-	}
+	if(cmp->pbuf) {
+        free((char*)cmp->pbuf);
+    }
 
-    // otherwise, they don't.
-    compare_halt(ss, match_no);
+	free(cmp);
+    ss->scanref = NULL;
 }
 
-

Modified: trunk/compare.h
===================================================================
--- trunk/compare.h	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/compare.h	2006-03-02 23:56:35 UTC (rev 99)
@@ -20,7 +20,7 @@
 
 void compare_attach(scanstate *ss, matchval *mv, pcrs_job *joblist, int nonl);
 void compare_continue(scanstate *ss, const char *ptr, int len);
-void compare_end(scanstate *cmp);
+void compare_end(scanstate *cmp, int *warn_nl);
 
 // no better place to put this for now...
 char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize);

Modified: trunk/curdir.c
===================================================================
--- trunk/curdir.c	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/curdir.c	2006-03-02 23:56:35 UTC (rev 99)
@@ -9,7 +9,7 @@
  *
  * Unfortunately this file got hacked to shreds when tmtest was
  * made to run with /tmp as the constant cwd.  It's pretty
- * incomprehensible and in dire need of a rewrite.
+ * incomprehensible and in dire dire DIRE need of a rewrite.
  */
 
 #include <stdio.h>

Added: trunk/examples/docs/testfile/Idiom-Indent1.test
===================================================================
--- trunk/examples/docs/testfile/Idiom-Indent1.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/examples/docs/testfile/Idiom-Indent1.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,11 @@
+DISABLED: neads streaming tmtest?
+
+echo test output > >(INDENT)
+
+# What the hell?  These two sleeps make this test mostly reliable
+# but not 100%.
+sleep 0.001
+sleep 0.001
+
+STDOUT:
+    test output

Added: trunk/examples/docs/testfile/Idiom-Indent2.test
===================================================================
--- trunk/examples/docs/testfile/Idiom-Indent2.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/examples/docs/testfile/Idiom-Indent2.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,8 @@
+{
+  echo output1
+  echo output2
+} | INDENT
+
+STDOUT:
+    output1
+    output2

Added: trunk/examples/docs/testfile/Idiom-Indent3.test
===================================================================
--- trunk/examples/docs/testfile/Idiom-Indent3.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/examples/docs/testfile/Idiom-Indent3.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,8 @@
+(
+  echo output1
+  echo output2
+) | INDENT
+
+STDOUT:
+    output1
+    output2

Added: trunk/examples/docs/testfile/Idiom-Replace1.test
===================================================================
--- trunk/examples/docs/testfile/Idiom-Replace1.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/examples/docs/testfile/Idiom-Replace1.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,6 @@
+# Testfile to demonstrate fixing a temporary filename
+MKFILE tt <<< "file contents"
+echo "patching $tt" | REPLACE "$tt" /tmp/FILE
+
+STDOUT:
+patching /tmp/FILE

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/main.c	2006-03-02 23:56:35 UTC (rev 99)
@@ -91,7 +91,7 @@
 /** Returns zero if s1 ends with s2, nonzero if not.
  */
 
-int strcmpend(const char *s1, const char *s2)
+static int strcmpend(const char *s1, const char *s2)
 {
     size_t n1 = strlen(s1);
     size_t n2 = strlen(s2);
@@ -104,10 +104,60 @@
 }
 
 
+static int i_have_permission(const struct stat *st, int op)
+{
+	if(st->st_mode & S_IRWXU & op) {
+		if(geteuid() == st->st_uid) {
+			return 1;
+		}
+	}
+
+	if(st->st_mode & S_IRWXG & op) {
+		if(getegid() == st->st_gid) {
+			return 1;
+		}
+	}
+
+	if(st->st_mode & S_IRWXO & op) {
+		return 1;
+	}
+
+	return 0;
+}
+
+
+static int verify_readable(const char *file, struct stat *st, int regfile)
+{
+	struct stat sts;
+	
+	// arg is optional so we can pass the stat struct back
+	// if the caller wants to do more with it.
+	if(st == NULL) {
+		st = &sts;
+	}
+
+
+	if(stat(file, st) < 0) {
+		fprintf(stderr, "Could not locate %s: %s\n", file, strerror(errno));
+		return 0;
+	}
+	if(regfile && !S_ISREG(st->st_mode)) {
+		fprintf(stderr, "Could not open %s: not a file!\n", file);
+		return 0;
+	}
+	if(!i_have_permission(st, 0444)) {
+		fprintf(stderr, "Could not open %s: permission denied!\n", file);
+		return 0;
+	}
+
+	return 1;
+}
+
+
 /** Prints the given template to the given file, performing substitutions.
  */
 
-void print_template(struct test *test, const char *tmpl,  FILE *fp)
+static void print_template(struct test *test, const char *tmpl,  FILE *fp)
 {
     char varbuf[32];
     const char *cp, *ocp, *ce;
@@ -153,7 +203,7 @@
  */
 
 
-void reset_fd(int fd, const char *fname)
+static void reset_fd(int fd, const char *fname)
 {
     if(lseek(fd, 0, SEEK_SET) < 0) {
         fprintf(stderr, "Couldn't seek to start of %s: %s\n",
@@ -169,7 +219,7 @@
 }
 
 
-int wait_for_child(int child, const char *name)
+static int wait_for_child(int child, const char *name)
 {
     int pid;
     int status;
@@ -200,7 +250,7 @@
 }
 
 
-int open_file(char *fn, const char *name, int flags)
+static int open_file(char *fn, const char *name, int flags)
 {
 	strcpy(fn, g_testdir);
 	strcat(fn, "/");
@@ -216,7 +266,7 @@
 }
 
 
-int write_stdin_to_tmpfile(struct test *test)
+static int write_stdin_to_tmpfile(struct test *test)
 {
 	char *buf;
 	int fd;
@@ -240,7 +290,7 @@
 /** Forks off a diff process and sets it up to receive the dumped test.
  */
 
-int start_diff(struct test *test)
+static int start_diff(struct test *test)
 {
     int pipes[2];
     int child;
@@ -312,7 +362,7 @@
 /** Waits for the forked diff process to finish.
  */
 
-void finish_diff(struct test *test, int diffpid)
+static void finish_diff(struct test *test, int diffpid)
 {
     int status;
     int exitcode;
@@ -341,7 +391,7 @@
  * If warn_suffix is true and the ffilename doesn't end in ".test"
  * then we'll print a warning to stderr.  This is used when
  * processing the cmdline args so the user will know why a file
- * explicitly named didn't run.
+ * that was explicitly named didn't run.
  *
  * When config files are executing, they use the standard stdout
  * and stderr.  That way, the user sees any output while the test
@@ -355,7 +405,7 @@
  * @returns 1 if we should keep testing, 0 if we should stop now.
  */
 
-int run_test(const char *name, int warn_suffix)
+static int run_test(const char *name, int warn_suffix)
 {
     struct test test;
     char buf[BUFSIZ];   // scan buffer for the testfile
@@ -533,7 +583,7 @@
  *  We don't want to process any hidden files or special directories.
  */
 
-int select_nodots(const struct dirent *d)
+static int select_nodots(const struct dirent *d)
 {
     return d->d_name[0] != '.';
 }
@@ -543,6 +593,33 @@
 int process_dir();
 
 
+/**
+ * Sucks the dirname from an absolute file path and calls curinit with it.
+ */
+
+static void init_path(const char *path)
+{
+	const char *cp;
+	int loc;
+	char buf[PATH_MAX];
+	
+	cp = strrchr(path, '/');
+	if(cp == NULL) {
+		fprintf(stderr, "Illegal absolute path '%s'\n", path);
+		exit(runtime_error);
+	}
+
+	strncpy(buf, path, sizeof(buf));
+
+	loc = cp - path;
+	if(sizeof(buf)-1 < loc) {
+		loc = sizeof(buf)-1;
+	}
+
+	buf[loc] = '\0';
+	curinit(buf);
+}
+
 /** Processes a directory specified using an absolute path.
  *
  * We need to save and restore curpath to do this.
@@ -550,13 +627,13 @@
  * @returns 1 if we should continue testing, 0 if we should abort.
  */
 
-int process_absolute_file(const char *path, int warn_suffix)
+static int process_absolute_file(const char *path, int warn_suffix)
 {
 	struct cursave save;
 	int keepontruckin;
 
 	cursave(&save);
-	curinit("/");
+	init_path(path);
 
 	if(outmode == outmode_test) {
 		printf("\nProcessing %s\n", path);
@@ -573,7 +650,7 @@
  * We need to save and restore curpath to do this.
  */
 
-int process_absolute_dir(const char *path)
+static int process_absolute_dir(const char *path)
 {
 	struct cursave save;
 	int keepontruckin;
@@ -597,9 +674,9 @@
  * See run_test() for an explanation of warn_suffix.
  */
 
-int process_ents(char **ents, int warn_suffix)
+static int process_ents(char **ents, int warn_suffix)
 {
-    struct stat st;
+	struct stat st;
     mode_t *modes;
     int i, n;
 	int keepontruckin;
@@ -626,8 +703,10 @@
 				}
 				cp = curabsolute();
 			}
-            if(stat(cp, &st) < 0) {
-                fprintf(stderr, "%s: %s\n", cp, strerror(errno));
+			// Need to be careful to test that file does exist.
+			// Bash opens it, not us, so the error message might
+			// be confusing.
+			if(!verify_readable(cp,&st,0)) {
                 exit(runtime_error);
             }
 			if(ents[i][0] != '/') curpop(keep);
@@ -716,7 +795,7 @@
 }
 
 
-void stop_tests()
+static void stop_tests()
 {
 	checkerr(close(g_outfd), "closing", g_outname);
 	checkerr(close(g_errfd), "closing", g_errname);
@@ -744,7 +823,7 @@
  * This should save some inode thrashing.
  */
 
-void start_tests()
+static void start_tests()
 {
 	char *cp;
 
@@ -780,12 +859,17 @@
 }
 
 
-void set_config_file(const char *cfg)
+static void set_config_file(const char *cfg)
 {
 	char cwd[PATH_MAX];
 	char out[PATH_MAX];
 	char *path;
 
+	if(cfg[0] == '\0') {
+		fprintf(stderr, "You must specify a directory for --config.\n");
+		exit(argument_error);
+	}
+
 	if(!getcwd(cwd, PATH_MAX)) {
 		perror("Couldn't get current working directory");
 		exit(runtime_error);
@@ -798,6 +882,13 @@
 		exit(runtime_error);
 	}
 
+	// need to ensure as well as we can that the file is readable because
+	// we don't open it ourselves.  Bash does.  And that can lead to some
+	// really cryptic error messages.
+	if(!verify_readable(out,NULL,1)) {
+		exit(runtime_error);
+	}
+
 	config_file = strdup(out);
 	if(!config_file) {
 		perror("strdup");
@@ -806,7 +897,7 @@
 }
 
 
-void usage()
+static void usage()
 {
 	printf(
 			"Usage: tmtest [OPTION]... [DLDIR]\n"
@@ -819,7 +910,7 @@
 }
 
 
-void process_args(int argc, char **argv)
+static void process_args(int argc, char **argv)
 {
     char buf[256], *cp;
     int optidx, i, c;
@@ -833,6 +924,7 @@
 		{"dump-script", 0, &dumpscript, 1},
 		{"help", 0, 0, 'h'},
 		{"output", 0, 0, 'o'},
+		{"patch", 0, 0, 'p'},
 		{"quiet", 0, 0, 'q'},
 		{"version", 0, 0, 'V'},
 		{0, 0, 0, 0},
@@ -871,6 +963,10 @@
                 outmode = outmode_dump;
 				break;
 
+			case 'p':
+                outmode = outmode_diff;
+                break;
+
 			case 'q':
 				quiet++;
 				break;

Added: trunk/test/00-cmdline/10-CfgDir.test
===================================================================
--- trunk/test/00-cmdline/10-CfgDir.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/00-cmdline/10-CfgDir.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,7 @@
+tmtest $args --config=/tmp - <<-EOL
+	echo Test!
+EOL
+
+RESULT: 2
+STDERR:
+Could not open /tmp: not a file!

Added: trunk/test/00-cmdline/11-CfgMissing.test
===================================================================
--- trunk/test/00-cmdline/11-CfgMissing.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/00-cmdline/11-CfgMissing.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,20 @@
+# Ensures that tmtest correctly handles when we specify a nonexistent file.
+# NOTE: the result is the result of the sed command, not the result of
+# the tmtest command.  tmtest should return 2.  This is unfortunate.
+# TODO: how can I fix this?
+
+
+SANIFY ()
+{
+	sed -e 's/Could not locate .*zzyzx: No such file or directory/Could not locate ...zzyzx: No such file or directory/'
+}
+
+tmtest $args --config="$MYDIR/zzyzx" - <<-EOL 2>&1 | SANIFY
+	echo Howdy
+	STDOUT:
+	Howdy
+EOL
+
+RESULT: 0
+STDOUT:
+Could not locate ...zzyzx: No such file or directory

Added: trunk/test/00-cmdline/12-CfgEmpty.test
===================================================================
--- trunk/test/00-cmdline/12-CfgEmpty.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/00-cmdline/12-CfgEmpty.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,9 @@
+tmtest $args --config= - <<-EOL
+	echo Howdy
+	STDOUT:
+	Howdy
+EOL
+
+RESULT: 1
+STDERR:
+You must specify a directory for --config.

Added: trunk/test/01-testfile/02-StdOutNK.test
===================================================================
--- trunk/test/01-testfile/02-StdOutNK.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/01-testfile/02-StdOutNK.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,14 @@
+# Ensure that a keyword can appear in the output clause as long as the
+# following char isn't a delimiter ("STDOUT ", "STDOUT:" and "STDOUT\n"
+# are all keywords, "STDOUTx" is not).
+
+tmtest $args -q - <<-EOL
+	echo STDOUTx
+	STDOUT:
+	STDOUTx
+EOL
+
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/01-testfile/03-StdErrNK.test
===================================================================
--- trunk/test/01-testfile/03-StdErrNK.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/01-testfile/03-StdErrNK.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,17 @@
+# Ensure that a keyword can appear in the output clause as long as the
+# following char isn't a delimiter ("STDOUT ", "STDOUT:" and "STDOUT\n"
+# are all keywords, "STDOUTx" is not).
+#
+# Same as 02, but works on STDERR not STDOUT.
+
+
+tmtest $args -q - <<-EOL
+	echo STDERR. 1>&2
+	STDERR:
+	STDERR.
+EOL
+
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Modified: trunk/test/01-testfile/08-GarbageInStdout.test
===================================================================
--- trunk/test/01-testfile/08-GarbageInStdout.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/01-testfile/08-GarbageInStdout.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -8,9 +8,9 @@
 	STDOUT: crapola
     crapola
 EOL
-STDERR:
+STDERR
 (STDIN) line 2: unknown arguments "crapola"
-STDOUT:
+STDOUT
 FAIL (STDIN)                   O..  stdout differed
 
 1 test run, 0 successes, 1 failure.

Modified: trunk/test/01-testfile/10-DumpScript.test
===================================================================
--- trunk/test/01-testfile/10-DumpScript.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/01-testfile/10-DumpScript.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -2,11 +2,23 @@
 # This is just so we don't surprise ourselves...  Any time you modify
 # template.sh, you should expect test to fail.
 
-tmtest $args --dump-script - <<-EOL
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 2
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 3
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 4
+SANIFY ()
+{
+	# This function cleans the absolute pathnames specifying the
+	# 'tmtest.sub.conf' config file from the script.
+
+	sed \
+	-e "s/echo 'CONFIG: .*tmtest.sub.conf' .*/echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD/" \
+	-e "s/MYDIR='.*test'/MYDIR='...test'/" \
+	-e "s/MYFILE='.*tmtest.sub.conf'/MYFILE='...tmtest.sub.conf'/" \
+	-e "s/\\. '.*tmtest.sub.conf'/. '...tmtest.sub.conf'/"
+}
+
+tmtest $args --dump-script - <<-EOL | SANIFY
+	THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
+	THE-SCRIPT THE-SCRIPT THE-SCRIPT 2
+	THE-SCRIPT THE-SCRIPT THE-SCRIPT 3
+	THE-SCRIPT THE-SCRIPT THE-SCRIPT 4
 EOL
 
 MODIFY:
@@ -28,8 +40,12 @@
 	DISABLE:  () { DISABLED $*; }
 
 	TESTDIR='/tmp'
-	TESTFILE='/tmp/-'
+	TESTFILE='(STDIN)'
 
+	echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD
+	MYDIR='...test'
+	MYFILE='...tmtest.sub.conf'
+	. '...tmtest.sub.conf'
 
 
 	echo PREPARE >&7
@@ -43,9 +59,9 @@
 	MODIFY () { exit 0; }
 	MODIFY: () { exit 0; }
 
-	echo 'RUNNING: /tmp/-' >&7
+	echo 'RUNNING: (STDIN)' >&7
 	MYDIR='/tmp'
-	MYFILE='/tmp/-'
+	MYFILE='(STDIN)'
 	exec >&3 2>&5
 	exec 3>&-
 	exec 5>&-

Added: trunk/test/01-testfile/11-InnerConfig.test
===================================================================
--- trunk/test/01-testfile/11-InnerConfig.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/01-testfile/11-InnerConfig.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,15 @@
+# Ensure that inner tests don't read any config files outside of the
+# test directory.  (seems like there's got to be a better way of doing
+# this but this works for now).
+
+tmtest $args -q - <<-'EOL'
+	if [ $OUTER_CONFIG_FILE ]; then
+		# this is what happens when inner tests don't have $args
+		ABORT "inner test read outer config file!"
+	fi
+EOL
+
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/01-testfile/20-TestVars.test
===================================================================
--- trunk/test/01-testfile/20-TestVars.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/01-testfile/20-TestVars.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,23 @@
+# Ensure the variables are set up correctly when we're running a test
+# from stdin.
+
+# MYDIR=/tmp, MYFILE="(STDIN)", TESTDIR=/tmp, TESTFILE="(STDIN)"
+
+
+tmtest $args -o -q - <<-'EOL' | INDENT
+	echo MYDIR:    "$MYDIR"
+	echo MYFILE:   "$MYFILE"
+	echo TESTDIR:  "$TESTDIR"
+	echo TESTFILE: "$TESTFILE"
+EOL
+
+STDOUT:
+    echo MYDIR:    "$MYDIR"
+    echo MYFILE:   "$MYFILE"
+    echo TESTDIR:  "$TESTDIR"
+    echo TESTFILE: "$TESTFILE"
+    STDOUT:
+    MYDIR: /tmp
+    MYFILE: (STDIN)
+    TESTDIR: /tmp
+    TESTFILE: (STDIN)

Added: trunk/test/01-testfile/21-TestVarsABS.test
===================================================================
--- trunk/test/01-testfile/21-TestVarsABS.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/01-testfile/21-TestVarsABS.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,22 @@
+# Make sure the variables are set up correctly when we are running a
+# test with an absolute pathname.
+
+MKFILE tt <<-'EOL'
+	echo MYDIR:    "$MYDIR"
+	echo MYFILE:   "$MYFILE"
+	echo TESTDIR:  "$TESTDIR"
+	echo TESTFILE: "$TESTFILE"
+EOL
+
+tmtest $args --all-files -o -q "$tt" <<-EOL | REPLACE "$tt" /tmp/FILE | INDENT
+
+STDOUT:
+    echo MYDIR:    "$MYDIR"
+    echo MYFILE:   "$MYFILE"
+    echo TESTDIR:  "$TESTDIR"
+    echo TESTFILE: "$TESTFILE"
+    STDOUT:
+    MYDIR: /tmp
+    MYFILE: /tmp/FILE
+    TESTDIR: /tmp
+    TESTFILE: /tmp/FILE

Added: trunk/test/01-testfile/22-TestVarsRel.test
===================================================================
--- trunk/test/01-testfile/22-TestVarsRel.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/01-testfile/22-TestVarsRel.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,23 @@
+# Make sure the variables are set up correctly when we are running a
+# test with a relative pathname.
+
+MKFILE tt <<-'EOL'
+	echo MYDIR:    "$MYDIR"
+	echo MYFILE:   "$MYFILE"
+	echo TESTDIR:  "$TESTDIR"
+	echo TESTFILE: "$TESTFILE"
+EOL
+
+cd `dirname "$tt"`
+tmtest $args --all-files -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
+
+STDOUT:
+    echo MYDIR:    "$MYDIR"
+    echo MYFILE:   "$MYFILE"
+    echo TESTDIR:  "$TESTDIR"
+    echo TESTFILE: "$TESTFILE"
+    STDOUT:
+    MYDIR: /tmp
+    MYFILE: /tmp/FILE
+    TESTDIR: /tmp
+    TESTFILE: /tmp/FILE

Modified: trunk/test/02-running/21-QuoteFile.test
===================================================================
--- trunk/test/02-running/21-QuoteFile.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/02-running/21-QuoteFile.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -1,4 +1,5 @@
-# Ensures that a test disabled by a config file doesn't run.
+# Ensures that testfiles with quotes in their names are skipped
+# (might as well close this potential security hole right now)
 
 MKDIR dir
 cd "$dir"

Modified: trunk/test/02-running/40-Replace.test
===================================================================
--- trunk/test/02-running/40-Replace.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/02-running/40-Replace.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -2,47 +2,71 @@
 # regular expression metachars are correctly interpreted as
 # regular characters.
 
-echo $'Abc  : '   $'abc'       | REPLACE abc def
-echo $'A\'b  : '  $'a\'b'      | REPLACE $'a\'b' def
-echo $'A\"b  : '  $'a\"b'      | REPLACE $'a\"b' def
-echo $'A\'\'b : ' $'a\'\'b'    | REPLACE $'a\'\'b' def
-echo $'A\"\"b : ' $'a\"\"b'    | REPLACE $'a\"\"b' def
-echo $'A\\\'b : ' $'a\\\'b'    | REPLACE $'a\\\'b' def
-echo $'A\\\"b : ' $'a\\\"b'    | REPLACE $'a\\\"b' def
-echo $'A\'\\b : ' $'a\'\\b'    | REPLACE $'a\'\\b' def
-echo $'A\"\\b : ' $'a\"\\b'    | REPLACE $'a\"\\b' def
-echo $'A\\\\b : ' $'a\\\\b'    | REPLACE $'a\\\\b' def
-echo  'A/b  : '   'a/b'        | REPLACE a/b def
-echo  'A.b  : '   'a.b'        | REPLACE 'a.b' def
-echo  'A*b  : '   'a*b'        | REPLACE 'a*b' def
-echo  'A+b  : '   'a+b'        | REPLACE 'a+b' def
-echo  'A$b  : '   'a$b'        | REPLACE 'a$b' def
-echo  'A$$b : '   'a$$b'       | REPLACE 'a$$b' def
-echo  'A at b  : '   'a at b'        | REPLACE 'a at b' def
-echo  'D.f  : '   'def'        | REPLACE 'd.f' BAD
-echo $'A\\\'b : ' $'a\\\'b'    | REPLACE $'a\\\'b' def
-echo $'A\\\"b : ' $'a\\\"b'    | REPLACE $'a\\\"b' def
-echo $'A\\Q\\Eb:' $'a\\Q\\Eb' | REPLACE $'a\\Q\\Eb' def
+tmtest $CFG -o - <<'EOL' | INDENT
+	echo $'Abc  : '   $'abc'       | REPLACE abc def
+	echo $'A\'b  : '  $'a\'b'      | REPLACE $'a\'b' def
+	echo $'A\"b  : '  $'a\"b'      | REPLACE $'a\"b' def
+	echo $'A\'\'b : ' $'a\'\'b'    | REPLACE $'a\'\'b' def
+	echo $'A\"\"b : ' $'a\"\"b'    | REPLACE $'a\"\"b' def
+	echo $'A\\\'b : ' $'a\\\'b'    | REPLACE $'a\\\'b' def
+	echo $'A\\\"b : ' $'a\\\"b'    | REPLACE $'a\\\"b' def
+	echo $'A\'\\b : ' $'a\'\\b'    | REPLACE $'a\'\\b' def
+	echo $'A\"\\b : ' $'a\"\\b'    | REPLACE $'a\"\\b' def
+	echo $'A\\\\b : ' $'a\\\\b'    | REPLACE $'a\\\\b' def
+	echo  'A/b  : '   'a/b'        | REPLACE a/b def
+	echo  'A.b  : '   'a.b'        | REPLACE 'a.b' def
+	echo  'A*b  : '   'a*b'        | REPLACE 'a*b' def
+	echo  'A+b  : '   'a+b'        | REPLACE 'a+b' def
+	echo  'A$b  : '   'a$b'        | REPLACE 'a$b' def
+	echo  'A$$b : '   'a$$b'       | REPLACE 'a$$b' def
+	echo  'A at b  : '   'a at b'        | REPLACE 'a at b' def
+	echo  'D.f  : '   'def'        | REPLACE 'd.f' BAD
+	echo $'A\\\'b : ' $'a\\\'b'    | REPLACE $'a\\\'b' def
+	echo $'A\\\"b : ' $'a\\\"b'    | REPLACE $'a\\\"b' def
+	echo $'A\\Q\\Eb:' $'a\\Q\\Eb'  | REPLACE $'a\\Q\\Eb' def
+EOL
 
 STDOUT:
-Abc  :  def
-A'b  :  def
-A"b  :  def
-A''b :  def
-A""b :  def
-A\'b :  def
-A\"b :  def
-A'\b :  def
-A"\b :  def
-A\\b :  def
-A/b  :  def
-A.b  :  def
-A*b  :  def
-A+b  :  def
-A$b  :  def
-A$$b :  def
-A at b  :  def
-D.f  :  def
-A\'b :  def
-A\"b :  def
-A\Q\Eb: def
+    	echo $'Abc  : '   $'abc'       | REPLACE abc def
+    	echo $'A\'b  : '  $'a\'b'      | REPLACE $'a\'b' def
+    	echo $'A\"b  : '  $'a\"b'      | REPLACE $'a\"b' def
+    	echo $'A\'\'b : ' $'a\'\'b'    | REPLACE $'a\'\'b' def
+    	echo $'A\"\"b : ' $'a\"\"b'    | REPLACE $'a\"\"b' def
+    	echo $'A\\\'b : ' $'a\\\'b'    | REPLACE $'a\\\'b' def
+    	echo $'A\\\"b : ' $'a\\\"b'    | REPLACE $'a\\\"b' def
+    	echo $'A\'\\b : ' $'a\'\\b'    | REPLACE $'a\'\\b' def
+    	echo $'A\"\\b : ' $'a\"\\b'    | REPLACE $'a\"\\b' def
+    	echo $'A\\\\b : ' $'a\\\\b'    | REPLACE $'a\\\\b' def
+    	echo  'A/b  : '   'a/b'        | REPLACE a/b def
+    	echo  'A.b  : '   'a.b'        | REPLACE 'a.b' def
+    	echo  'A*b  : '   'a*b'        | REPLACE 'a*b' def
+    	echo  'A+b  : '   'a+b'        | REPLACE 'a+b' def
+    	echo  'A$b  : '   'a$b'        | REPLACE 'a$b' def
+    	echo  'A$$b : '   'a$$b'       | REPLACE 'a$$b' def
+    	echo  'A at b  : '   'a at b'        | REPLACE 'a at b' def
+    	echo  'D.f  : '   'def'        | REPLACE 'd.f' BAD
+    	echo $'A\\\'b : ' $'a\\\'b'    | REPLACE $'a\\\'b' def
+    	echo $'A\\\"b : ' $'a\\\"b'    | REPLACE $'a\\\"b' def
+    	echo $'A\\Q\\Eb:' $'a\\Q\\Eb'  | REPLACE $'a\\Q\\Eb' def
+    STDOUT:
+    Abc  :  def
+    A'b  :  def
+    A"b  :  def
+    A''b :  def
+    A""b :  def
+    A\'b :  def
+    A\"b :  def
+    A'\b :  def
+    A"\b :  def
+    A\\b :  def
+    A/b  :  def
+    A.b  :  def
+    A*b  :  def
+    A+b  :  def
+    A$b  :  def
+    A$$b :  def
+    A at b  :  def
+    D.f  :  def
+    A\'b :  def
+    A\"b :  def
+    A\Q\Eb: def

Added: trunk/test/02-running/41-Indent.test
===================================================================
--- trunk/test/02-running/41-Indent.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/02-running/41-Indent.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,29 @@
+# Ensures that INDENT works.  Also tests that we can exec to a process
+# group to cause all further output from the script to be indented.
+
+tmtest $CFG -o - <<-EOL | INDENT "| "
+	# this technique doesn't work.  Fixes scheduled for 0.98 should
+	# fix it.  Put it into its own test when that happens.
+	# exec > >(INDENT)
+
+	(
+	echo one
+	echo two
+	echo three!
+	) | INDENT "in --> "
+EOL
+
+STDOUT:
+| # this technique doesn't work.  Fixes scheduled for 0.98 should
+| # fix it.  Put it into its own test when that happens.
+| # exec > >(INDENT)
+| 
+| (
+| echo one
+| echo two
+| echo three!
+| ) | INDENT "in --> "
+| STDOUT:
+| in --> one
+| in --> two
+| in --> three!

Added: trunk/test/03-results/01-YstderrOut.test
===================================================================
--- trunk/test/03-results/01-YstderrOut.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/03-results/01-YstderrOut.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,12 @@
+# Ensures an empty STDOUT clause won't affect the test results.
+
+tmtest -q - <<-EOL
+	echo Howdy 1>&2
+	STDERR:
+	Howdy
+	STDOUT:
+EOL
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/03-results/01-YstdoutOut.test
===================================================================
--- trunk/test/03-results/01-YstdoutOut.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/03-results/01-YstdoutOut.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,12 @@
+# Ensures an empty stderr section won't affect the test results.
+
+tmtest -q - <<-EOL
+	echo Howdy
+	STDOUT :
+	Howdy
+	STDERR:
+EOL
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/03-results/14-NoNLWarn.test
===================================================================
--- trunk/test/03-results/14-NoNLWarn.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/03-results/14-NoNLWarn.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,22 @@
+# Scott Bronson
+# 26 Feb 2006
+#
+# Verifies that a warning is printed when a the actual output for a
+# section didn't include a newline, but the expected output for that
+# section had one.  (this error can only be fixed by editing the
+# testfile; patch can't fix it).
+
+# See also 18-NoNLWarnOut.test and 04-diff/22-PatchNoNL2.test
+
+tmtest -q - <<-EOL
+	echo -n Howdy
+	STDOUT:
+	Howdy
+EOL
+STDOUT : 
+FAIL (STDIN)                   O..  stdout differed
+
+1 test run, 0 successes, 1 failure.
+STDERR:
+WARNING: STDOUT didn't end with a newline!
+   Add a -n to (STDIN) line 3 if this is the expected behavior.

Added: trunk/test/03-results/17-NoStderr.test
===================================================================
--- trunk/test/03-results/17-NoStderr.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/03-results/17-NoStderr.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,10 @@
+tmtest -q - <<-EOL
+	echo Howdy 1>&2
+	STDERR :
+	Howdy
+	STDOUT:
+EOL
+STDOUT:
+ok   (STDIN) 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/03-results/18-NoNLWarnOut.test
===================================================================
--- trunk/test/03-results/18-NoNLWarnOut.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/03-results/18-NoNLWarnOut.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,31 @@
+# If a section is marked as having a trailing newline, but one wasn't
+# found in the actual output, we need to print a warning.
+
+# By the time we figure out that the section didn't end in a trailing
+# newline, we've long since output the section header and so we missed
+# our chance to fix it ourselves.  Therefore, we'll warn the user that
+# he has to fix it himself).
+
+# See also 14-NoNLWarn.test and 04-diff/18-NeedNLWarn.test
+
+tmtest -o -q - <<-EOL | INDENT
+	echo -n "right output"
+	echo -n "stderr text" 1>&2
+	STDOUT:
+	right output
+	STDERR:
+	stderr text
+EOL
+
+STDERR:
+WARNING: STDOUT didn't end with a newline!
+   Add a -n to (STDIN) line 3 if this is the expected behavior.
+WARNING: STDERR didn't end with a newline!
+   Add a -n to (STDIN) line 5 if this is the expected behavior.
+STDOUT:
+    echo -n "right output"
+    echo -n "stderr text" 1>&2
+    STDOUT:
+    right outputSTDERR:
+    stderr text
+    

Modified: trunk/test/03-results/33-BinaryHuge.test
===================================================================
--- trunk/test/03-results/33-BinaryHuge.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/03-results/33-BinaryHuge.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -3,18 +3,20 @@
 # of 2 1-byte values (64K of data).
 
 # We need to manually create the testfile because Bash will screw 
-# things up if we use a heredoc.
+# things up if we use a heredoc.  We also ensure that the test data
+# ends in a newline, otherwise tmtest will complain (we could also
+# just have specified -n).
 
 
 MKFILE tt <<-'EOL'
-    perl -e 'for(my $i=0; $i<256; $i++) { for(my $j=0; $j<256; $j++) { print pack("cc", $i, $j); }}'
+    perl -e 'for(my $i=0; $i<256; $i++) { for(my $j=0; $j<256; $j++) { print pack("cc", $i, $j); }}; print "\n";'
     # stdout will be filled in below
 	STDOUT:
 EOL
 
 
 # Add the expected results to the testfile.
-perl -e 'for(my $i=0; $i<256; $i++) { for(my $j=0; $j<256; $j++) { print pack("cc", $i, $j); }}' >> "$tt"
+perl -e 'for(my $i=0; $i<256; $i++) { for(my $j=0; $j<256; $j++) { print pack("cc", $i, $j); }}; print "\n";' >> "$tt"
 
 # and run the test
 tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE

Modified: trunk/test/04-diff/01-Diff.test
===================================================================
--- trunk/test/04-diff/01-Diff.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/04-diff/01-Diff.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -7,7 +7,7 @@
 # updated for 2.0 on 27 Jan 2005
 
 
-tmtest -d - <<-EOL
+tmtest --diff - <<-EOL
     echo "right output"
     STDOUT:
     wrong output

Modified: trunk/test/04-diff/02-MultiDiff.test
===================================================================
--- trunk/test/04-diff/02-MultiDiff.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/04-diff/02-MultiDiff.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -18,7 +18,7 @@
 	test 2 wrong output
 EOF
 
-tmtest --all-files -d "$t1" "$t2"
+tmtest --all-files -p "$t1" "$t2"
 
 
 MODIFY:

Modified: trunk/test/04-diff/05-AbortDiff.test
===================================================================
--- trunk/test/04-diff/05-AbortDiff.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/04-diff/05-AbortDiff.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -5,7 +5,7 @@
 
 
 
-tmtest -d - <<-EOL
+tmtest --patch - <<-EOL
 	ABORT
 	echo "right output"
 	STDOUT:

Added: trunk/test/04-diff/18-NeedNLWarn.test
===================================================================
--- trunk/test/04-diff/18-NeedNLWarn.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/04-diff/18-NeedNLWarn.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -0,0 +1,40 @@
+# If a section is marked as having a trailing newline, but one wasn't
+# found in the actual output, we need to print a warning.
+
+# By the time we figure out that the section didn't end in a trailing
+# newline, we've long since output the section header and so we missed
+# our chance to fix it ourselves.  Therefore, we'll warn the user that
+# he has to fix it himself).  It's also too late to stop ourselves from
+# outputting an incorrect patch.  No problem -- user can make the change
+# and patch again, fixing the problem.
+
+# See also the corresponding test in 03-Running/18-NeedNLWarn.test
+
+
+tmtest --diff -q - <<-EOL | FIX_DIFF
+	echo -n "right output"
+	echo -n "stderr text" 1>&2
+	STDOUT:
+	right output
+	STDERR:
+	stderr text
+EOL
+
+STDERR:
+WARNING: STDOUT didn't end with a newline!
+   Add a -n to (STDIN) line 3 if this is the expected behavior.
+WARNING: STDERR didn't end with a newline!
+   Add a -n to (STDIN) line 5 if this is the expected behavior.
+STDOUT:
+--- /tmp/FILE DATE TIME TZ
++++ - DATE TIME TZ
+@@ -1,6 +1,5 @@
+ echo -n "right output"
+ echo -n "stderr text" 1>&2
+ STDOUT:
+-right output
+-STDERR:
+-stderr text
++right outputSTDERR:
++stderr text
+\ No newline at end of file

Modified: trunk/test/04-diff/21-PatchNoNL.test
===================================================================
--- trunk/test/04-diff/21-PatchNoNL.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/04-diff/21-PatchNoNL.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -17,8 +17,10 @@
 
 # This is a little exotic...  Patch needs the CWD to be the directory
 # containing the file to patch.  "dirname $(tt.test)" gives that dir.
+# Ignore stderr because we want to ignore the warning that tmtest prints
+# about the sections not having matching trailing newlines.
 
-tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
+tmtest --all-files -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 INDENT < "$tt"
 echo "<<DONE>>"
@@ -27,7 +29,7 @@
 STDOUT:
 patching FILE
 And the patched file:
-  echo -n "right output"
-  STDOUT:
-  right output<<DONE>>
+    echo -n "right output"
+    STDOUT:
+    right output<<DONE>>
 (since there's no trailing newline, DONE should appear on the prevous line)

Modified: trunk/test/04-diff/22-PatchNoNL2.test
===================================================================
--- trunk/test/04-diff/22-PatchNoNL2.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/04-diff/22-PatchNoNL2.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -9,7 +9,9 @@
 # of the last STDOUT line.  This is not real good, but at least it
 # guarantees that the test will fail until the user fixes it.
 
+# See also test/03-results/18-NoNLWarn.test
 
+
 MKFILE tt <<-EOL
 	echo -n "right output"
     echo "stderr text" 1>&2
@@ -22,8 +24,10 @@
 
 # This is a little exotic...  Patch needs the CWD to be the directory
 # containing the file to patch.  "dirname $(tt.test)" gives that dir.
+# Pipe STDERR to /dev/null because we want to ignore the warning that
+# tmtest prints (other tests ensure the warning works)
 
-tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
+tmtest --all-files -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 INDENT < "$tt"
 echo "<<DONE>>"
@@ -31,9 +35,9 @@
 STDOUT:
 patching FILE
 And the patched file:
-  echo -n "right output"
-      echo "stderr text" 1>&2
-  STDOUT:
-  right outputSTDERR:
-  stderr text
+    echo -n "right output"
+        echo "stderr text" 1>&2
+    STDOUT:
+    right outputSTDERR:
+    stderr text
 <<DONE>>

Modified: trunk/test/04-diff/23-PatchNoNL3.test
===================================================================
--- trunk/test/04-diff/23-PatchNoNL3.test	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/04-diff/23-PatchNoNL3.test	2006-03-02 23:56:35 UTC (rev 99)
@@ -29,8 +29,8 @@
 STDOUT:
 patching FILE
 And the patched file:
-  echo "right output"
-  STDOUT: -n
-  right output
-  
+    echo "right output"
+    STDOUT: -n
+    right output
+    
 <<DONE>>

Modified: trunk/test/tmtest.sub.conf
===================================================================
--- trunk/test/tmtest.sub.conf	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test/tmtest.sub.conf	2006-03-02 23:56:35 UTC (rev 99)
@@ -14,5 +14,5 @@
 
 
 # Include the standard tmtest functions
-. ../tmlib.sh
+. "$MYDIR/../tmlib.sh"
 

Modified: trunk/test.c
===================================================================
--- trunk/test.c	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test.c	2006-03-02 23:56:35 UTC (rev 99)
@@ -347,13 +347,6 @@
 {
     assert(!compare_in_progress(cmpscan));
 
-    // associates the scanstate with the fd and prepares to compare.
-    if(*mv != match_unknown) {
-        fprintf(stderr, "'%s' has multiple %s sections!\n",
-                filename, sectionname);
-        exit(10);
-    }
-
     // rewind the file
     if(lseek(fd, 0, SEEK_SET) < 0) {
         fprintf(stderr, "read_file lseek for status file: %s\n", strerror(errno));
@@ -579,7 +572,13 @@
 }
 
 
-void start_output_section(struct test *test, const char *tok,
+/**
+ * Called when we're at the start of a STDOUT or STDERR section.
+ * Sets the cmpscanner up to compare the section.
+ * See end_output_section().
+ */
+
+int start_output_section(struct test *test, const char *tok,
         int toklen, scanstate *cmpscan, int fd, matchval *val,
         const char *secname)
 {
@@ -595,16 +594,47 @@
         fprintf(stderr, "%s line %d Error: duplicate %s "
                 "section.  Ignored.\n", get_testfile_name(test),
                 test->testfile.line, secname);
-        // as long as scanref == null, no comparison will happen.
-        assert(!cmpscan->scanref);
-        return;
+        return 0;
     }
 
     compare_section_start(cmpscan, fd, test->eachline, val,
         get_testfile_name(test), secname, suppress_trailing_newline);
+
+    return 1;
 }
 
 
+/** 
+ * If the actual test results were found to not end in a newline,
+ * but the expected results were marked in the testfile as expecting
+ * a newline, this function prints the warning.
+ */
+
+void warn_section_newline(struct test *test, const char *name)
+{
+	fprintf(stderr, "WARNING: %s didn't end with a newline!\n"
+			"   Add a -n to %s line %d if this is the expected behavior.\n",
+			name, get_testfile_name(test), test->testfile.line);
+}
+
+
+/**
+ * Finishes comparing a section.
+ * see start_output_section().
+ */
+
+void end_output_section(struct test *test, scanstate *cmpscan,
+        const char *name)
+{
+    int warn_nl = 0;
+
+    compare_end(cmpscan, &warn_nl);
+    if(warn_nl) {
+		warn_section_newline(test, name);
+    }
+}
+
+
 /** This routine parses the tokens returned by scan_sections() and
  * compares them against the actual test results.  It stores the
  * results in test->match_stdout, match_stderr, and match_result.
@@ -621,30 +651,26 @@
     #define get_cur_state(ss)    ((int)(ss)->userref)
     #define set_cur_state(ss,x)  ((ss)->userref=(void*)(x))
 
-    // compscan is the comparison scanner -- it is used to diff the
-    // current output section (either stdout or stderr).
+    // cmpscan is the scanner used to perform the diff.
     scanstate *cmpscan = refcon;
 
-    // the section that we're entering (without the NEW flag attached)
+    // the section that we're processing (without the NEW flag attached)
     int newsec = EX_TOKEN(sec);
 
-    if(get_cur_state(cmpscan) == 0) {
-        // This is the first time this scanner has been used.
-        set_cur_state(cmpscan, exCOMMAND);
-    }
+    // make sure we're not fed an illegal token.
+    assert(is_section_token(newsec) || sec == 0);
+    // make sure we're not starting from an illegal state.
+    assert(is_section_token(get_cur_state(cmpscan)) ||
+            get_cur_state(cmpscan) == 0);
 
-    if(!is_section_token(newsec) && sec != 0) {
-        // We only work with result section tokens.  Ignore all
-        // non-section-tokens except the eof token.
-        return;
-    }
-
     if(EX_ISNEW(sec) || sec == 0) {
         // ensure previoius section is finished
         switch(get_cur_state(cmpscan)) {
             case exSTDOUT:
+                end_output_section(test, cmpscan, "STDOUT");
+                break;
             case exSTDERR:
-                compare_end(cmpscan);
+                end_output_section(test, cmpscan, "STDERR");
                 break;
             default:
                 ;
@@ -652,14 +678,23 @@
 
         // then fire up the new section
         set_cur_state(cmpscan, newsec);
-        switch(get_cur_state(cmpscan)) {
+        switch(newsec) {
+            case 0:
+                // don't start a new section if eof.
+                break;
             case exSTDOUT:
-                start_output_section(test, datap, len, cmpscan,
-                        test->outfd, &test->stdout_match, "STDOUT");
+                if(!start_output_section(test, datap, len, cmpscan,
+                        test->outfd, &test->stdout_match, "STDOUT"))
+                {
+                    set_cur_state(cmpscan, 0);
+                }
                 break;
             case exSTDERR:
-                start_output_section(test, datap, len, cmpscan,
-                        test->errfd, &test->stderr_match, "STDERR");
+                if(!start_output_section(test, datap, len, cmpscan,
+                        test->errfd, &test->stderr_match, "STDERR"))
+                {
+                    set_cur_state(cmpscan, 0);
+                }
                 break;
             case exRESULT:
 				parse_exit_clause(test, datap, len);
@@ -668,19 +703,15 @@
 				parse_modify_clause(test, skip_section_name(datap,len),
                         datap+len);
                 break;
-            case exCOMMAND:
-                fprintf(stderr, "%s line %d Error: Well, this is impossible.  "
-                        "How did you start a new command section??\n",
-                        get_testfile_name(test), test->testfile.line);
-                // it should be harmless to continue but this definitely
-                // indicates a bug in the scanner.
-                break;
         }
     } else {
         // we're continuing an already started section.
-        assert(get_cur_state(cmpscan) == newsec);
+        assert(get_cur_state(cmpscan) == newsec || get_cur_state(cmpscan) == 0);
 
         switch(get_cur_state(cmpscan)) {
+            case 0:
+                // do nothing
+                break;
             case exSTDOUT:
             case exSTDERR:
                 compare_continue(cmpscan, datap, len);
@@ -854,10 +885,11 @@
 }
 
 
-void write_raw_file(int outfd, int infd)
+int write_raw_file(int outfd, int infd)
 {
     char buf[BUFSIZ];
     int rcnt, wcnt;
+	int ending_newline;
 
     // first rewind the input file
     if(lseek(infd, 0, SEEK_SET) < 0) {
@@ -871,6 +903,7 @@
             rcnt = read(infd, buf, sizeof(buf));
         } while(rcnt < 0 && errno == EINTR);
         if(rcnt > 0) {
+			ending_newline = (buf[rcnt-1] == '\n');
             do {
                 wcnt = write(outfd, buf, rcnt);
             } while(wcnt < 0 && errno == EINTR);
@@ -885,6 +918,8 @@
             break;
         }
     } while(rcnt);
+
+	return ending_newline;
 }
 
 
@@ -947,62 +982,78 @@
 }
 
 
-static void write_file(int outfd, int infd, pcrs_job *job)
+static int write_file(int outfd, int infd, pcrs_job *job)
 {
 	if(!job) {
 		// use the simple, fast routine
-		write_raw_file(outfd, infd);
-	} else {
-		// use the line buffered routine
-		write_modified_file(outfd, infd, job);
+		return write_raw_file(outfd, infd);
 	}
+
+	// use the line buffered routine
+	// (don't bother with the return value because we
+	// know that MODIFY sections are going away in the
+	// next release anyway)
+	write_modified_file(outfd, infd, job);
+	return 0;
 }
 
 
+static void write_section(struct test *test, const char *datap, int len,
+		int fd, const char *name)
+{
+    int marked_no_nl = 0;
+	int has_nl;
+
+	parse_section_args(datap, len,
+			get_testfile_name(test), test->testfile.line,
+			start_output_section_argproc, &marked_no_nl);
+
+	write(test->rewritefd, datap, len);
+	has_nl = write_file(test->rewritefd, fd, test->eachline);
+
+	if(marked_no_nl) {
+		// if a section is marked with --no-trailing-newline, we need
+		// to print a newline here so that the testfile isn't messed up.
+		// Otherwise, you'd end up with "STDOUT -n:STDERR:" on one line.
+		write_strconst(test->rewritefd, "\n");
+	} else if(!has_nl) {
+		// If the section isn't marked with --no-trailing-newline, but
+		// the output DOESN'T have one, we need to print a warning.
+		// First, if the user will be viewing the test output, we need
+		// to add the final CR so our error message will appear at the
+		// start of the line.
+		if(test->rewritefd == STDOUT_FILENO) {
+			printf("\n");
+		}
+
+		warn_section_newline(test, name);
+	}
+}
+
+
 /** Writes the actual results in place of the expected results.
  */
 
 void parse_section_output(struct test *test, int sec,
         const char *datap, int len, void *refcon)
 {
-    int *needs_nl = (int*)refcon;
-
     assert(sec >= 0);
 
-    if(sec & exNEW) {
-        // check to see if previous section needs a newline appended.
-        if(*needs_nl) {
-            write_strconst(test->rewritefd, "\n");
-        }
-
-        *needs_nl = 0;
-    }
-
     switch(sec) {
-        case 0:
-            if(*needs_nl) {
-                write_strconst(test->rewritefd, "\n");
-            }
-            break;
+		case 0:
+			// eof!  nothing to do.
+			break;
 
         case exSTDOUT|exNEW:
-            parse_section_args(datap, len,
-                    get_testfile_name(test), test->testfile.line,
-                    start_output_section_argproc, needs_nl);
-            write(test->rewritefd, datap, len);
-            write_file(test->rewritefd, test->outfd, test->eachline);
-            test->stdout_match = match_yes;
+			write_section(test, datap, len, test->outfd, "STDOUT");
+			test->stdout_match = match_yes;
             break;
         case exSTDOUT:
             // ignore all data in the expected stdout.
             break;
 
         case exSTDERR|exNEW:
-            parse_section_args(datap, len,
-                    get_testfile_name(test), test->testfile.line,
-                    start_output_section_argproc, needs_nl);
-            write(test->rewritefd, datap, len);
-            write_file(test->rewritefd, test->errfd, test->eachline);
+			write_section(test, datap, len, test->errfd, "STDERR");
             test->stderr_match = match_yes;
             break;
         case exSTDERR:

Modified: trunk/test.h
===================================================================
--- trunk/test.h	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/test.h	2006-03-02 23:56:35 UTC (rev 99)
@@ -39,7 +39,7 @@
 // all strings are malloc'd and need to be freed when the test is finished.
 
 struct test {
-    const char *testfilename;   ///< will be "-" if reading from stdin.
+    const char *testfilename;   ///< name of the test file.  does not include any directories.  will be "-" if reading from stdin.
     scanstate testfile;         ///< scans the testfile.  may be stdin so seeking is not allowed.
 
     int rewritefd;          ///< where to dump the rewritten test.  -1 if we're just running the tests, or the fd of the file that should receive the test contents.
@@ -82,6 +82,7 @@
 void test_free(struct test *test);
 
 
-// random utility function for start_diff:
-void write_raw_file(int outfd, int infd);
+// random utility function for start_diff.  Return value is true if the
+// file ends in a newline, false if not.
+int write_raw_file(int outfd, int infd);
 

Modified: trunk/tfscan.c
===================================================================
--- trunk/tfscan.c	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/tfscan.c	2006-03-02 23:56:35 UTC (rev 99)
@@ -8,6 +8,11 @@
  * This file is covered by the MIT License.
  */
 
+// STDOUT\n starts a new section.  STDOUT my be followed by
+// either whitespace or a colon -- nothing else.  If it's followed
+// by anything else, it's interpreted as data.
+
+
 // TOTEST: >8K token not containing a cr
 // STDOUT:, STDERR:, etc at the EOF with no data.
 // STDOUT at the beginning of the file.
@@ -42,7 +47,7 @@
 
 /*!re2c
  
-  // This is almost the scanner that this file implements, except that
+  // The following is almost the scanner that this file implements, except that
   // this file handles data at EOF correctly.
 
 WS      = [ \t];
@@ -67,24 +72,82 @@
 */
 
 
+static int nontok_start(scanstate *ss)
+{
+	if(YYCURSOR >= YYLIMIT) {
+		int r = (*ss->read)(ss);
+		// if there was an error, return an error token.
+		if(r < 0) return r;
+		// if we're completely out of data, return eof.
+		// (this is why we can't use re2c for this scanner)
+		if(ss->token >= ss->limit) return 0;
+	}
 
+	// Since it's impossible to have a token at this point so we
+	// scan forward to the next CR/LF.
+	while(YYCURSOR < YYLIMIT) {
+		if(*YYCURSOR == '\r' || *YYCURSOR == '\n') break;
+		YYCURSOR++;
+	}
+	if(YYCURSOR >= YYLIMIT) {
+		// We have to assume that we previously read as much data as
+		// possible.  So the entire buffer is just data with no tokens
+		// and no CR/LF.
+		return (int)ss->scanref;
+	}
+
+	if(*YYCURSOR == '\r') YYCURSOR++;
+	if(*YYCURSOR == '\n') YYCURSOR++;
+
+    ss->line += 1;
+
+	// We have potential for finding a token at this point.
+	ss->state = tfscan_tok_start;
+	return (int)ss->scanref;
+}
+
+
+
 static int scan_to_end_of_keyword(scanstate *ss, int tok)
 {
+    int r;
+
 	// We assume that we're immediately at the end of a keyword
 	// section.  The first six bytes just guarantees the keyword.
 
 	// skip all characters up to the final nl.
 
+    // there's a chance we can be called with an empty buffer.
+    // If so, we need to fill it before proceeding.
+    if(YYCURSOR >= YYLIMIT) {
+        r = (*ss->read)(ss);
+        if(r < 0) return r;
+        // if we're at eof, then the current token is just data.
+        if(r == 0) return (int)ss->scanref;
+    }
+
+    if(*YYCURSOR != '\r' && *YYCURSOR != '\n' && *YYCURSOR != ':' &&
+            *YYCURSOR != ' ' && *YYCURSOR != '\t')
+    {
+        // We had a keyword but it didn't end in a proper delimiter.
+        // Therefore, it's data, not a keyword.
+        ss->state = tfscan_nontok_start;
+        return nontok_start(ss);
+    }
+
 	while(*YYCURSOR != '\r' && *YYCURSOR != '\n') {
 		YYCURSOR++;
 		if(YYCURSOR >= YYLIMIT) {
-			break;
+            // try to fill the buffer (maybe it's a really long keyword)
+            r = (*ss->read)(ss);
+            if(r < 0) return r;
+            // if we're at eof, then the current token is just data.
+            if(r == 0) return (int)ss->scanref;
 		}
 	}
 
 	if(*YYCURSOR == '\r') YYCURSOR++;
 	if(*YYCURSOR == '\n') YYCURSOR++;
-
     ss->line += 1;
 
 	START(tok);
@@ -101,17 +164,24 @@
 
 int tfscan_tok_start(scanstate *ss)
 {
+    int r;
+
     scanner_enter(ss);
 
     // if we can read at least 8 more bytes from the current buffer,
     // we won't bother reloading it.  This should cut down drastically
-    // on the number of small reads we make.
-	if(YYCURSOR+8 >= YYLIMIT) {
-		int r = (*ss->read)(ss);
+    // on the number of small reads we make.  The constant in the if
+    // statement is an arbitrary number; if we have less than that
+    // number of bytes available in the buffer, we read some more data.
+	if(YYCURSOR+16 >= YYLIMIT) {
+		r = (*ss->read)(ss);
 		// if there was an error, return an error token.
 		if(r < 0) return r;
 		// Only if we're _completely_ out of data, return eof.
 		// (this is why we can't use re2c for this scanner)
+        // we can handle cursor==limit; we just return the
+        // final token.  But, if token==limit, we're out of data.
+        // (except, at this point in the function, cursor == token).
 		if(ss->token >= ss->limit) return 0;
 	}
 
@@ -119,7 +189,7 @@
     // of a line (previous character was either start-of-file or \n).
 	// So check to see if there's a token.
 
-	if(YYCURSOR + 8 < YYLIMIT) {
+	if(YYCURSOR + 7 <= YYLIMIT) {
 		// There's enough data in this buffer to contain a keyword.
 		// If there are less than 8 bytes in the buffer then it means
 		// that we're 7 bytes from the EOF and there's no chance that
@@ -129,9 +199,11 @@
 			case 'S':
 				if(YYCURSOR[1] == 'T' && YYCURSOR[2] == 'D') {
 					if(YYCURSOR[3]=='O' && YYCURSOR[4]=='U' && YYCURSOR[5]=='T') {
+                        YYCURSOR += 6;
 						return scan_to_end_of_keyword(ss, exSTDOUT);
 					}
 					if(YYCURSOR[3]=='E' && YYCURSOR[4]=='R' && YYCURSOR[5]=='R') {
+                        YYCURSOR += 6;
 						return scan_to_end_of_keyword(ss, exSTDERR);
 					}
 				}
@@ -141,6 +213,7 @@
 				if(YYCURSOR[1]=='E' && YYCURSOR[2]=='S' &&
 					YYCURSOR[3]=='U' && YYCURSOR[4]=='L' && YYCURSOR[5]=='T')
 				{
+                    YYCURSOR += 6;
 					return scan_to_end_of_keyword(ss, exRESULT);
 				}
 				break;
@@ -148,6 +221,7 @@
 				if(YYCURSOR[1]=='O' && YYCURSOR[2]=='D' &&
 					YYCURSOR[3]=='I' && YYCURSOR[4]=='F' && YYCURSOR[5]=='Y')
 				{
+                    YYCURSOR += 6;
 					return scan_to_end_of_keyword(ss, exMODIFY);
 				}
 				break;
@@ -167,37 +241,7 @@
 int tfscan_nontok_start(scanstate *ss)
 {
 	scanner_enter(ss);
-
-	if(YYCURSOR >= YYLIMIT) {
-		int r = (*ss->read)(ss);
-		// if there was an error, return an error token.
-		if(r < 0) return r;
-		// if we're completely out of data, return eof.
-		// (this is why we can't use re2c for this scanner)
-		if(ss->token >= ss->limit) return 0;
-	}
-
-	// Since it's impossible to have a token at this point so we
-	// scan forward to the next CR/LF.
-	while(YYCURSOR < YYLIMIT) {
-		if(*YYCURSOR == '\r' || *YYCURSOR == '\n') break;
-		YYCURSOR++;
-	}
-	if(YYCURSOR >= YYLIMIT) {
-		// We have to assume that we previously read as much data as
-		// possible.  So the entire buffer is just data with no tokens
-		// and no CR/LF.
-		return (int)ss->scanref;
-	}
-
-	if(*YYCURSOR == '\r') YYCURSOR++;
-	if(*YYCURSOR == '\n') YYCURSOR++;
-
-    ss->line += 1;
-
-	// We have potential for finding a token at this point.
-	ss->state = tfscan_tok_start;
-	return (int)ss->scanref;
+    return nontok_start(ss);
 }
 	
 

Modified: trunk/tmlib.sh
===================================================================
--- trunk/tmlib.sh	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/tmlib.sh	2006-03-02 23:56:35 UTC (rev 99)
@@ -3,7 +3,11 @@
 # Utilities useful for writing tmtest testfiles.
 # This file is covered by the MIT License.
 
+# DO NOT EDIT THIS FILE!  Edit /etc/tmtest.conf or ~/.tmtestrc instead.
+# This file is replaced when you reinstall tmtest and your changes
+# will be lost!
 
+
 # TODO: should these routines be prefixed by "TM"?
 # TODO: is there any way to get rid of MKFILE_EMPTY?  Can't MKFILE notice
 #       if read would block and, if so, just create an empty file.?
@@ -193,7 +197,7 @@
 # Note that this only works with stdout!  You'll have to combine
 # the stdout and stderr streams if you want to indent stderr.
 #
-# By default this script indents each line with two spaces.
+# By default this script indents each line with four spaces.
 # Pass an argument to tell this function what to put before
 # each line.
 #
@@ -207,9 +211,9 @@
 INDENT ()
 {
     # sed appears more binary transparent than bash's builtins so I'm
-    # using sed instead of read.
+    # using sed instead of builtin read.  It might even be faster.
 
-    sed -e "s/^/${1-  }/"
+    sed -e "s/^/${1-    }/"
 
     # even though this might be faster, it mucks things up.
     #

Modified: trunk/tmtest.conf
===================================================================
--- trunk/tmtest.conf	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/tmtest.conf	2006-03-02 23:56:35 UTC (rev 99)
@@ -52,12 +52,21 @@
 # that the tests are not succeeding due to some local configuration;
 # their environment is as clean as we can possibly make it.
 
-args="--config=$MYPATH/test/tmtest.sub.conf"
+args="--config=$MYDIR/test/tmtest.sub.conf"
 
 
 # This allows us to run tests without installing tmtest first.
-# (todo: will this cause problems if you DO have a currently-installed
-# tmtest?)
+# This is generally a good thing but it will cause problems if
+# this tmlib has problems...  Maybe we should check to see if
+# a particular function has been defined and include tmlib only
+# if it hasn't.
 
 . tmlib.sh
 
+
+# We set OUTER_CONFIG_FILE so that we can check later that this file
+# has or has not been read.  We need to ensure that subtests have NOT
+# read this file (we need to restrict the config files that they read
+# to the testdir ONLY).
+
+OUTER_CONFIG_FILE=1

Modified: trunk/vars.c
===================================================================
--- trunk/vars.c	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/vars.c	2006-03-02 23:56:35 UTC (rev 99)
@@ -43,7 +43,14 @@
 
 static int var_testfile(struct test *test, FILE* fp, const char *var)
 {
-	fprintf(fp, "%s/%s", curabsolute(), test->testfilename);
+	if(test->testfilename[0] == '-' && test->testfilename[1] == '\0') {
+		fprintf(fp, "(STDIN)");
+	} else if(test->testfilename[0] == '/') {
+		fprintf(fp, "%s", test->testfilename);
+	} else {
+		fprintf(fp, "%s/%s", curabsolute(), test->testfilename);
+	}
+
     return 0;
 }
 
@@ -60,13 +67,17 @@
     // from stdin.  Otherwise, just have the shell execute the testfile.
 
     if(test->testfilename[0] == '-' && test->testfilename[1] == '\0') {
-		// bash doesn't support setting LINENO any more but,
+		// bash3 doesn't support setting LINENO anymore.  Bash2 did.
 		// what the hell, it's worth a shot.
 		fprintf(fp, "LINENO=0\n");
         test_command_copy(test, fp);
     } else {
         test_command_copy(test, NULL);
-        fprintf(fp, ". '%s/%s'", curabsolute(), test->testfilename);
+		if(test->testfilename[0] == '/') {
+			fprintf(fp, ". %s", test->testfilename);
+		} else {
+			fprintf(fp, ". '%s/%s'", curabsolute(), test->testfilename);
+		}
     }
 
     return 0;
@@ -190,16 +201,25 @@
 static int var_config_files(struct test *test, FILE *fp, const char *var)
 {
 	char buf[PATH_MAX];
-    char *cp;
+    char *cp, *oldcfg;
 	int confbaselen;
 
 	// check global configuration files
 	if(config_file) {
-		// Need to obliterate config_file, otherwise it will think that
-		// it has included config_file twice and refuse to include it.
-		char *oldcfg = config_file;
+		// Need to temporarily forget config_file, otherwise it will think
+		// that it has included config_file twice and refuse to include it.
+		oldcfg = config_file;
 		config_file = NULL;
-		check_config_str(test, fp, oldcfg, NULL);
+
+		strncpy(buf, oldcfg, sizeof(buf));
+		buf[sizeof(buf)-1] = '\0';
+		cp = strrchr(buf, '/');
+		if(cp == NULL) {
+			fprintf(stderr, "Illegal config_file: '%s'\n", buf); 
+			exit(1);
+		}
+		*cp = '\0';
+		check_config_str(test, fp, buf, cp+1);
 		config_file = oldcfg;
 	} else {
 		check_config_str(test, fp, "/etc", CONFIG_FILE);
@@ -209,6 +229,7 @@
 
 	// check config files in the current hierarchy
 	strncpy(buf, curabsolute(), sizeof(buf));
+	buf[sizeof(buf)-1] = '\0';
 	if(config_file) {
 		confbaselen = strrchr(config_file, '/') - config_file;
 	}

Modified: trunk/vars.h
===================================================================
--- trunk/vars.h	2006-03-01 14:57:44 UTC (rev 98)
+++ trunk/vars.h	2006-03-02 23:56:35 UTC (rev 99)
@@ -1,2 +1,3 @@
 struct test;
+int file_exists(char *path);
 int printvar(struct test *test, FILE *fp, const char *varname);





From tmtest-commits at berlios.de  Fri Mar  3 01:01:34 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Fri, 3 Mar 2006 01:01:34 +0100
Subject: [Tmtest-commits] [100] trunk: Purge ATEXIT from the template, minor cleanup
Message-ID: <200603030001.k2301YOv018444@sheep.berlios.de>

Revision: 100
Author:   bronson
Date:     2006-03-03 01:01:32 +0100 (Fri, 03 Mar 2006)

Log Message:
-----------
Purge ATEXIT from the template, minor cleanup

Modified Paths:
--------------
    trunk/CHANGES
    trunk/examples/tutorial/20-ArgSuppressNL.test
    trunk/template.sh
    trunk/test/01-testfile/10-DumpScript.test
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-03-02 23:56:35 UTC (rev 99)
+++ trunk/CHANGES	2006-03-03 00:01:32 UTC (rev 100)
@@ -1,5 +1,4 @@
-get rid of ATEXIT from template.sh.  Can also merge 3>&- and 5>& in template.sh
-- Release 0.94 on 2 Mar 2006
+Released 0.94 on 2 Mar 2006
 - NOTE: Bash3 has made it so that the regex can not appear on the same line as
   the MODIFY keyword.  I updated all tests and accelerated MODIFY deprecation.
 - Added the INDENT and REPLACE functions to tmlib.

Modified: trunk/examples/tutorial/20-ArgSuppressNL.test
===================================================================
--- trunk/examples/tutorial/20-ArgSuppressNL.test	2006-03-02 23:56:35 UTC (rev 99)
+++ trunk/examples/tutorial/20-ArgSuppressNL.test	2006-03-03 00:01:32 UTC (rev 100)
@@ -1,3 +1,3 @@
 echo -n "No newline"
-STDOUT:
-No newline
\ No newline at end of file
+STDOUT: -n
+No newline

Modified: trunk/template.sh
===================================================================
--- trunk/template.sh	2006-03-02 23:56:35 UTC (rev 99)
+++ trunk/template.sh	2006-03-03 00:01:32 UTC (rev 100)
@@ -3,9 +3,6 @@
 ABORT ()  { echo "ABORTED: $*" >&%(STATUSFD); exit 0; }
 ABORT: () { ABORT $*; }
 
-ATEXIT ()  { echo "ATEXIT: $*" >&%(STATUSFD); }
-ATEXIT: () { ATEXIT $*; }
-
 DISABLED  () { echo "DISABLED: $*" >&%(STATUSFD); exit 0; }
 DISABLED: () { DISABLED $*; }
 DISABLE   () { DISABLED $*; }
@@ -30,9 +27,7 @@
 echo 'RUNNING: %(TESTFILE)' >&%(STATUSFD)
 MYDIR='%(TESTDIR)'
 MYFILE='%(TESTFILE)'
-exec >&%(OUTFD) 2>&%(ERRFD)
-exec %(OUTFD)>&-
-exec %(ERRFD)>&-
+exec >&%(OUTFD) 2>&%(ERRFD) %(OUTFD)>&- %(ERRFD)>&-
 %(TESTEXEC)
 
 echo DONE >&%(STATUSFD)

Modified: trunk/test/01-testfile/10-DumpScript.test
===================================================================
--- trunk/test/01-testfile/10-DumpScript.test	2006-03-02 23:56:35 UTC (rev 99)
+++ trunk/test/01-testfile/10-DumpScript.test	2006-03-03 00:01:32 UTC (rev 100)
@@ -31,9 +31,6 @@
 	ABORT ()  { echo "ABORTED: $*" >&7; exit 0; }
 	ABORT: () { ABORT $*; }
 
-	ATEXIT ()  { echo "ATEXIT: $*" >&7; }
-	ATEXIT: () { ATEXIT $*; }
-
 	DISABLED  () { echo "DISABLED: $*" >&7; exit 0; }
 	DISABLED: () { DISABLED $*; }
 	DISABLE   () { DISABLED $*; }
@@ -62,9 +59,7 @@
 	echo 'RUNNING: (STDIN)' >&7
 	MYDIR='/tmp'
 	MYFILE='(STDIN)'
-	exec >&3 2>&5
-	exec 3>&-
-	exec 5>&-
+	exec >&3 2>&5 3>&- 5>&-
 	LINENO=0
 	THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
 	THE-SCRIPT THE-SCRIPT THE-SCRIPT 2





From tmtest-commits at berlios.de  Fri Mar  3 01:06:32 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Fri, 3 Mar 2006 01:06:32 +0100
Subject: [Tmtest-commits] [101] releases/0.92: Minor update to 0.92 to make it distributable and
Message-ID: <200603030006.k2306Wo0019790@sheep.berlios.de>

Revision: 101
Author:   bronson
Date:     2006-03-03 01:06:24 +0100 (Fri, 03 Mar 2006)

Log Message:
-----------
Minor update to 0.92 to make it distributable and testable.

Modified Paths:
--------------
    releases/0.92/tmtest.conf

Added Paths:
-----------
    releases/0.92/make-dist
Added: releases/0.92/make-dist
===================================================================
--- releases/0.92/make-dist	2006-03-03 00:01:32 UTC (rev 100)
+++ releases/0.92/make-dist	2006-03-03 00:06:24 UTC (rev 101)
@@ -0,0 +1,61 @@
+#!/bin/sh
+
+# make-dist (for tmtest)
+# Scott Bronson
+# 30 May 2000
+
+
+name=tmtest
+version=$(perl -ne '/VERSION=([0-9]+\.[0-9A-Za-z_.-]+)/ && print $1' Makefile)
+
+if [ ! "$version" ] ; then echo "Could not figure out version." ; exit 1 ; fi
+
+if grep -vw $version CHANGES 2>&1 >/dev/null; then echo -n
+else echo echo "Did you update the Changelog?" ; exit 1 ; fi
+
+pushd . 2>&1 > /dev/null
+
+# Ensure tree is ready to go
+make distclean > /dev/null || exit 1
+make dist > /dev/null || exit 1
+
+# get rid of possible old files
+rm -rf /tmp/$name-$version
+rm -rf /tmp/$name-$version.tar.gz
+
+# make a working copy in /tmp
+cp -r . /tmp/$name-$version
+
+# remove unneeded files
+cd /tmp/$name-$version
+find . -name .svn | xargs rm -rf
+rm -f Makefile.old
+rm make-dist
+
+# check for any invisible files
+find . | grep /\\. && echo "BAD FILES!  Won't finish." && exit 1
+
+# check the version number on all modules
+if ((0)) ; then
+find . -path './t' -prune -o -name '*.pm' -print | while read file; do
+	fver=$(perl -MExtUtils::MakeMaker -le 'print MM->parse_version(shift)' "$file")
+	if [ "x$version" != "x$fver" ]; then
+		echo "Versions don't match!  $file is $fver, should be $version."
+		exit 1
+	fi
+done
+fi
+# bash is really weird
+if [ "$?" != "0" ]; then exit 1; fi
+
+# show a list of files so we can see questionable stuff
+find .
+
+# tar it up
+cd ..
+tar zcf $name-$version.tar.gz $name-$version
+
+# we're done
+echo "New dist is in /tmp/$name-$version.tar.gz, enjoy!"
+popd 2>&1 > /dev/null
+


Property changes on: releases/0.92/make-dist
___________________________________________________________________
Name: svn:executable
   + *

Modified: releases/0.92/tmtest.conf
===================================================================
--- releases/0.92/tmtest.conf	2006-03-03 00:01:32 UTC (rev 100)
+++ releases/0.92/tmtest.conf	2006-03-03 00:06:24 UTC (rev 101)
@@ -49,3 +49,6 @@
 
 args="--config=$MYPATH/test/tmtest.sub.conf"
 
+# This allows us to run tests without installing tmtest first.
+. tmlib.sh
+





From tmtest-commits at berlios.de  Fri Mar  3 01:13:27 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Fri, 3 Mar 2006 01:13:27 +0100
Subject: [Tmtest-commits] [102] releases: Release 0.94
Message-ID: <200603030013.k230DRhq021580@sheep.berlios.de>

Revision: 102
Author:   bronson
Date:     2006-03-03 01:12:52 +0100 (Fri, 03 Mar 2006)

Log Message:
-----------
Release 0.94

Added Paths:
-----------
    releases/0.94/
    releases/0.94/BUGS
    releases/0.94/CHANGES
    releases/0.94/Makefile
    releases/0.94/TODO
    releases/0.94/compare.c
    releases/0.94/compare.h
    releases/0.94/curdir.c
    releases/0.94/examples/docs/Modify3.test
    releases/0.94/examples/docs/testfile/
    releases/0.94/examples/tutorial/20-ArgSuppressNL.test
    releases/0.94/main.c
    releases/0.94/make-dist
    releases/0.94/re2c/read.c
    releases/0.94/re2c/scan.h
    releases/0.94/stscan.c
    releases/0.94/template.sh
    releases/0.94/test/00-cmdline/10-CfgDir.test
    releases/0.94/test/00-cmdline/11-CfgMissing.test
    releases/0.94/test/00-cmdline/12-CfgEmpty.test
    releases/0.94/test/01-testfile/02-StdOutNK.test
    releases/0.94/test/01-testfile/03-StdErrNK.test
    releases/0.94/test/01-testfile/08-GarbageInStdout.test
    releases/0.94/test/01-testfile/10-DumpScript.test
    releases/0.94/test/01-testfile/11-InnerConfig.test
    releases/0.94/test/01-testfile/20-TestVars.test
    releases/0.94/test/01-testfile/21-TestVarsABS.test
    releases/0.94/test/01-testfile/22-TestVarsRel.test
    releases/0.94/test/02-running/21-QuoteFile.test
    releases/0.94/test/02-running/22-Signal.test
    releases/0.94/test/02-running/40-Replace.test
    releases/0.94/test/02-running/41-Indent.test
    releases/0.94/test/03-results/01-YstderrOut.test
    releases/0.94/test/03-results/01-YstdoutOut.test
    releases/0.94/test/03-results/14-NoNLWarn.test
    releases/0.94/test/03-results/15-EmptyWithErr.test
    releases/0.94/test/03-results/15-EmptyWithOut.test
    releases/0.94/test/03-results/16-EmptyWithErrNoNL.test
    releases/0.94/test/03-results/16-EmptyWithOutNoNL.test
    releases/0.94/test/03-results/17-NoStderr.test
    releases/0.94/test/03-results/18-NoNLWarnOut.test
    releases/0.94/test/03-results/30-Binary.test
    releases/0.94/test/03-results/31-BinaryFail.test
    releases/0.94/test/03-results/32-BinaryLarge.test
    releases/0.94/test/03-results/33-BinaryHuge.test
    releases/0.94/test/04-diff/01-Diff.test
    releases/0.94/test/04-diff/02-MultiDiff.test
    releases/0.94/test/04-diff/05-AbortDiff.test
    releases/0.94/test/04-diff/09-MultiLevelDiff.test
    releases/0.94/test/04-diff/10-Patch.test
    releases/0.94/test/04-diff/11-MultiPatch.test
    releases/0.94/test/04-diff/12-MultiLevelPatch.test
    releases/0.94/test/04-diff/13-MultiLevelPatch.test
    releases/0.94/test/04-diff/18-NeedNLWarn.test
    releases/0.94/test/04-diff/20-DiffNoNL.test
    releases/0.94/test/04-diff/21-PatchNoNL.test
    releases/0.94/test/04-diff/22-PatchNoNL2.test
    releases/0.94/test/04-diff/23-PatchNoNL3.test
    releases/0.94/test/04-diff/tmtest.conf
    releases/0.94/test/README
    releases/0.94/test/tmtest.sub.conf
    releases/0.94/test.c
    releases/0.94/test.h
    releases/0.94/tfscan.c
    releases/0.94/tmlib.sh
    releases/0.94/tmtest.conf
    releases/0.94/tmtest.pod
    releases/0.94/vars.c
    releases/0.94/vars.h
    releases/tmtest-0.92.tar.gz
    releases/tmtest-0.94.tar.gz

Removed Paths:
-------------
    releases/0.94/BUGS
    releases/0.94/CHANGES
    releases/0.94/Makefile
    releases/0.94/TODO
    releases/0.94/compare.c
    releases/0.94/compare.h
    releases/0.94/curdir.c
    releases/0.94/examples/docs/Modify3.test
    releases/0.94/examples/tutorial/20-ArgSuppressNL.test
    releases/0.94/main.c
    releases/0.94/re2c/read.c
    releases/0.94/re2c/scan.h
    releases/0.94/stscan.c
    releases/0.94/template.sh
    releases/0.94/test/01-testfile/08-GarbageInStdout.test
    releases/0.94/test/01-testfile/10-DumpScript.test
    releases/0.94/test/02-running/21-QuoteFile.test
    releases/0.94/test/04-diff/01-Diff.test
    releases/0.94/test/04-diff/02-MultiDiff.test
    releases/0.94/test/04-diff/05-AbortDiff.test
    releases/0.94/test/04-diff/09-MultiLevelDiff.test
    releases/0.94/test/04-diff/10-Patch.test
    releases/0.94/test/04-diff/11-MultiPatch.test
    releases/0.94/test/04-diff/12-MultiLevelPatch.test
    releases/0.94/test/04-diff/13-MultiLevelPatch.test
    releases/0.94/test/04-diff/indent.sh
    releases/0.94/test/README
    releases/0.94/test/tmtest.sub.conf
    releases/0.94/test.c
    releases/0.94/test.h
    releases/0.94/tfscan.c
    releases/0.94/tmlib.sh
    releases/0.94/tmtest.conf
    releases/0.94/tmtest.pod
    releases/0.94/vars.c
    releases/0.94/vars.h
Copied: releases/0.94 (from rev 88, trunk)

Deleted: releases/0.94/BUGS
===================================================================
--- trunk/BUGS	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/BUGS	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,43 +0,0 @@
-If you run tmtest -d on a disabled test, it produces a tiny diff with the
-word "Disabled" in its stderr.  If you blindly pipe this diff to patch,
-it will destroy the output section of your test file.  This is easy enough
-to fix -- just re-enable the test and patch it again.  This will be
-fixed in tmtest 1.2 when we parse the status file asynchronously.  We
-will notice that the test is disabled and refuse to produce the diff.
-
-
-Bash Gotchas:
-
-
-Bash3 has removed the ability to set LINENO, so you may see the
-wrong line number be printed if there's an error.  If you want to
-see the correct line numbers, use Bash2.  It's an unfortunate
-regression but since it only affects tests scripts being piped
-on stdin it won't affect many people.
-
-
-The <<-EOL operator strips ALL tabs from the front of each line.
-This is bad because it means you can't nest heredocs:
-
-	cmd1 <<-EOL
-		cmd2 <<-EOL
-			cmd3
-		EOL
-	EOL
-
-The first heredoc flattens everything and then the EOLs get mixed up.
-What bash *SHOULD* do (and what tmtest did before it was integrated
-with Bash) is discover the whitespace sequence indenting the
-first line of a heredoc, then remove exactly that sequence from all
-subsequent lines.  If a line doesn't begin with that sequence, then
-it is unchanged.  This is safer and more useful than just blowing away
-all tabs wholesale!
-
-
-Bashisms:
-
-Why does &> redirect both stdout and stderr to a file, but &| doesn't
-redirect both stdout and stderr to a pipe?
-
-Why is the unset command totally unrelated to the set command?
-

Copied: releases/0.94/BUGS (from rev 99, trunk/BUGS)

Deleted: releases/0.94/CHANGES
===================================================================
--- trunk/CHANGES	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/CHANGES	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,19 +0,0 @@
-- write some tests to ensure diff works with files that don't end in CR.
-- move INDENT from 04-diff into the stdlib.  Add to docs.
-----
-- Bash3 has made it so that the RE can no longer appear on the same line as
-  the MODIFY command.  I updated all tests and accelerated MODIFY deprecation.
-- Added -n (--no-trailing-newline) capability to STDOUT and STDERR sections.
-- Rewrote the re2c parser in C so we should now be totally binary transparent.
-- Got rid of all AUTHOR and DATE automation.  Too heavyhanded.
-- Standardized licensing: everything under my control is MIT, package is LGPL.
-- When installing locally, it's ~/.tmlib.sh instead of ~/share/tmtest/tmlib.sh
-- Bump to 0.92
-- install now installs config files too.
-- Added the --config option to override default config files.
-- Added timing information to test summary.  Disable with new -q option.
-- Created tmlib, a "standard library" for tests.
-- We now stop running all tests if any test aborts.  DISABLE stops the current
-  test but lets all other tests finish; ABORT stops testing altogether.
-- Tests now start with /tmp as the cwd, not the testdir.
-  The testdir is supplied in $TESTDIR (or $MYDIR inside the testfile)

Copied: releases/0.94/CHANGES (from rev 100, trunk/CHANGES)

Deleted: releases/0.94/Makefile
===================================================================
--- trunk/Makefile	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/Makefile	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,114 +0,0 @@
-# tmtest Makefile
-# Scott Bronson
-# 28 Dec 2004
-#
-# This software is distributed under the LGPL.  See COPYING for more.
-
-
-VERSION=0.92
-
-# override this when installing: "make install prefix=/usr/local"
-#prefix=/usr
-prefix=$(HOME)
-
-
-bindir=$(prefix)/bin
-lib_src=tmlib.sh
-
-ifeq ($(prefix), $(HOME))
-	libdir=$(prefix)
-	stdlib=$(libdir)/.tmlib.sh
-	conf_dst=$(HOME)/.tmtestrc
-else
-	libdir=$(prefix)/share/tmtest
-	stdlib=$(libdir)/tmlib.sh
-	conf_dst=/etc/tmtest.conf
-endif
-
-
-COPTS=-g -Wall -Werror
-
-# utilities:
-CSRC+=curdir.c qscandir.c pcrs.c rel2abs.c
-CHDR+=curdir.h qscandir.h pcrs.h rel2abs.h
-# scanner files
-CSRC+=re2c/read.c re2c/read-fd.c re2c/scan.c
-CHDR+=re2c/read.h re2c/read-fd.h re2c/scan.h
-# program files:
-CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c
-CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h matchval.h
-
-# It makes it rather hard to debug when Make deletes the intermediate files.
-INTERMED=stscan.c
-
-
-tmtest: $(CSRC) $(CHDR) template.c Makefile $(INTERMED)
-	$(CC) $(COPTS) $(CSRC) -lpcre template.c -o tmtest "-DVERSION=$(VERSION)"
-
-template.c: template.sh cstrfy Makefile
-	./cstrfy -n exec_template < template.sh > template.c
-
-%.c: %.re
-	re2c $(REOPTS) $< > $@
-	perl -pi -e 's/^\#line.*$$//' $@
-
-%.o: %.c
-	$(CC) -g -c $< -o $@
-
-.PHONY: test
-test: tmtest
-	./tmtest test
-
-run: tmtest
-	./tmtest
-
-install: tmtest
-	install -d -m755 $(bindir)
-	install tmtest $(bindir)
-	install -d -m755 $(libdir)
-	install tmlib.sh $(stdlib)
-ifeq ($(wildcard $(conf_dst)),$(conf_dst))
-	# configuration already exists, don't overwrite it.
-	@echo "---> Not installing new config file over '$(conf_dst).'"
-	@echo "---> Please merge changes in 'sample.conf' by hand or run 'make uninstall' first."
-else
-	# global configuration file doesn't exist so install it
-	install sample.conf $(conf_dst)
-	@perl -pi -e 's/USER/$(shell whoami)/g' $(conf_dst)
-	@perl -pi -e 's:STDLIB:$(stdlib):g' $(conf_dst)
-endif
-
-# NOTE: This will remove the configuration file too!
-uninstall: tmtest
-	rm $(bindir)/tmtest
-	rm $(stdlib)
-ifeq ($(prefix), $(HOME))
-	rm $(HOME)/.tmtestrc
-else
-	rm /etc/tmtest.conf
-endif
-
-clean:
-	rm -f tmtest template.c tags
-
-# Ensure re2c is installed to regenerate the scanners before making distclean
-distclean: clean
-	rm -f stscan.[co]
-
-tags: $(CSRC) $(CHDR) $(INTERMED)
-	ctags -R
-
-doc:
-	doxygen
-	which pods2html > /dev/null || echo "You must install Pod::Tree off CPAN"
-	pods2html . docs/html
-	$(MAKE) graphs
-
-%.png: %.dot
-	dot -Tpng $< -o $@
-
-rediff:
-	diff ../oe/re2c/ re2c
-	
-reupdate:
-	ls re2c/*.[ch] | (ODIR=`pwd`; cd ../oe; xargs cp --target-directory $$ODIR/re2c)

Copied: releases/0.94/Makefile (from rev 99, trunk/Makefile)

Deleted: releases/0.94/TODO
===================================================================
--- trunk/TODO	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/TODO	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,98 +0,0 @@
-0.94:
-- An empty test with a STDOUT clause should fail without the -n right?
-  I mean, there's no newline in the actual output, but there is in the
-  expected...
-- Add tests for binary transparency.
-- write tests for nesting testfiles with --config.
-        // If the user specifies a config file, we only check directories
-        // not above the given config file.  i.e. if user specifies
-        // "tmtest -c /a/b/cc /a/t/u/t.test", we will look for config files
-        // in /a/t/tmtest.conf and /a/t/u/tmtest.conf.
-- Add the ability to specify test arguments on the command line.
-  I'm picturing something where VAR=val on the command line would be
-  inserted without change into the template.  That way you can use the
-  command line to override default settings in the testfile.
-  - This would allow us to test almost every test to ensure it
-    supports the --config argument (make them DISABLED or something).
-
-0.96:
-- stdin is all buggered up.  why is it that "cat" with no args will print
-  the rest of the test script?  And why is it that if you fork, diff freezes?
-  They're related problems I suspect.
-    Is it because I'm forgetting to close all open filehandles before forking?
-- Tighten up printing a folder name when there are no testfiles in it.
-  No need for double spacing.
-- Add the ability to run multiple tests from one testfile.
-  See tmtest 0.8 for a potential implementation of this.
-  All we'd need to add is a framework to notify the user that multiple
-  tests are in progress; bash can take care of the rest.
-- Shouldn't run every test in a dir if the DISABLED directive is in a config
-  file.
-  Should discover what dir the DISABLED directive came from and refuse
-  to run anything below that.
-  - Yes, if a config file returns DISABLED, then that folder and all its
-    subfolders are skipped.  Just make the test itself call the DISABLED
-	command if you want testing to continue in that subfolder.
-
-0.98:
-- Change the I/O scheme to be event based.  Get rid of the tempfiles.
-  Convert to using the async io library.  Don't use temporary files.
-  This would allow us to recognize that the test is disabled before
-  producing a partial diff, blowing away output sections.
-- Use i/o lib for everything.  No need for temp files.
-  This means that we stream everything EXCEPT stderr, which we memory
-  buffer.  If your stderr is more than 100K or so in size, just redirect
-  it to stdout.
-
-2.0:
-- get rid of all the exit(10) calls in test.c.  We need a better way to
-  abort the test.
-  should get rid of a whole bunch in main.c as well.
-  this should prevent us from dropping turds in /tmp all the time too.
-- Get rid of MODIFY clauses.  It's unnecessary complexity.
-  And it's a LOT.  First remove it from the tests, then from the code.
-
-?:
-- add gcov support so you can see what sort of coverage your tests provide.
-- Provide some sort of automatable XML output?
-- Could take tests from tarfiles.  We would decompress the tarfile into
-  a temporary directory, run the test, and delete the tarfile.  This will
-  make it easier to maintain tests that all need to be run in a certain
-  directory hierarchy.
-- add the ability to run valgrind over each test and print success/failure
-  of that.  (gives deep valgrind coverage)
-  - One problem with this will be all the false warnings.
-
-No longer a problem when we dump pcrs:
-- allow multiple s/// expressions on a single line.  will probably require
-  modifications to pcrs_compile_command, so make it support buf/len at the
-  same time.  These might be non-trivial changes...
-- it's stupid to dup the str just to null-terminate it so it can be passed
-  to pcrs.  Modify pcrs to compile buffers too.
-- Unify the line modifier in compare.c and test.c.  It's hackish now.
-- Wow, the pcrs error messages truly suck.  Is there any way to improve them?
-  "(pcrs:) Syntax error while parsing command (-11)."
-- add a CLEAR_EACHLINE or CLEAR_MODIFY option to to turn off all substitutions.
-  It would be easy to do.  I'm just not convinced that anyone would find it
-  useful.
-
-????:
-- There should be a way to repeatedly run a single test with only tiny
-  differences.  i.e. test all permeutations of DISABLE DISABLE:
-  DISABLED DISABLED:  Hopefully that will clean up 05-08-Disable/Abort.test
-- Add a timeout that will terminate stalled tests.  You can set the timeout
-  in the config file or the test itself.
-
-maybe never:
-- Add STDOUT: trimws and STDERR: trimws - to trim whitespace from
-  the front of each output line.
-  I wanted to add this to simulate the "STDOUT=<<-EOL" heredoc sequence
-  of the original tests (that is nestable, unlinke Bash's.  But now I
-  realize that this problem is pretty much solved from the other direction.
-  Instead of removing indentation from the heredoc, simply add indentation
-  using a MODIFY section (as detailed in the FAQ).
-- Add a "FAILURE-OK" flag for when failure IS an option.  This would print
-  that the test failed, but would not highlight it, and would not count
-  either positively or negatively toward the test results.  That way you
-  can include experimental tests in a production test stack (say you're
-  developing a test and want to know if it's a good idea...)

Copied: releases/0.94/TODO (from rev 99, trunk/TODO)

Deleted: releases/0.94/compare.c
===================================================================
--- trunk/compare.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/compare.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,305 +0,0 @@
-/* compare.c
- * Scott Bronson
- * 31 Dec 2004
- *
- * This file is distrubuted under the MIT License
- * See http://en.wikipedia.org/wiki/MIT_License for more.
- *
- *
- * File comparison.
- *
- * This uses all re2c's mechanisms for creating buffers and loading
- * them with data, but it's not an re2c scanner.
- *
- * Here's what you do:
- * - Create a scanstate that reads from one of the files (or
- *   whatever) that you want to compare and pass it to compare_start.
- * - Call compare_continue with any size data block from the other
- *   file you want to compare.  Keep calling until you're out of
- *   data.  Check compare_in_progress to see if it failed prematurely.
- * - Finally, when you're out of data in the other file, call
- *   compare_end.  It will verify that it's at eof on the first
- *   file.
- * - Read the final result from the matchval.
- *
- * Well, the line buffering for the pcrs library has utterly destroyed
- * the simplicity of this file.
- *
- */
-
-#include <string.h>
-#include "compare.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-
-
-typedef struct {
-	matchval *output;
-	pcrs_job *jobs;
-	const char *pbuf;
-	int pcursor;
-	int plimit;
-    int no_trailing_newline;
-    int nl_suppressed;
-} compare_state;
-
-
-static int compare_fill(scanstate *ss)
-{
-    return (*ss->read)(ss);
-}
-
-
-static void compare_halt(scanstate *ss, matchval newval)
-{
-	compare_state *cmp = (compare_state*)ss->scanref;
-    *cmp->output = newval;
-	if(cmp->pbuf) free((char*)cmp->pbuf);
-	free(cmp);
-    ss->scanref = NULL;
-}
-
-
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *jobs, int nonl)
-{
-	compare_state *cmp = malloc(sizeof(compare_state));
-	if(cmp == NULL) {
-		perror("compare_attach");
-		exit(10);
-	}
-	memset(cmp, 0, sizeof(compare_state));
-
-    *mv = match_inprogress;
-
-	cmp->output = mv;
-	cmp->jobs = jobs;
-    cmp->no_trailing_newline = nonl;
-    cmp->nl_suppressed = 0;;
-    ss->scanref = cmp;
-}
-
-
-
-static void compare_continue_bytes(scanstate *ss, const char *ptr, int len)
-{
-    int n;
-
-    while(len > 0) {
-        n = ss->limit - ss->cursor;
-        if(!n) {
-            n = compare_fill(ss);
-            if(n < 0) {
-                // there was an error while trying to fill the buffer
-                // TODO: this should be propagated to the client somehow.
-                perror("compare_continue_bytes");
-                exit(10);
-            }
-            if(n == 0) {
-                compare_halt(ss, match_no);
-                return;
-            }
-        }
-
-        if(len < n) {
-            n = len;
-        }
-
-        // compare
-        if(memcmp(ptr, ss->cursor, n) != 0) {
-            compare_halt(ss, match_no);
-            return;
-        }
-        ptr += n;
-        ss->cursor += n;
-        len -= n;
-    }
-}
-
-
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize)
-{
-	char *old, *new;
-	int nsubs;
-	int cnt;
-
-	cnt = 0;
-	old = (char*)cp;
-	*newsize = ce - cp;
-
-	while(job) {
-		// Now, run the line through the substitutions.
-		nsubs = pcrs_execute(job, old, *newsize, &new, newsize);
-		if(nsubs < 0) {
-			fprintf(stderr, "error while substituting expr %d: %s (%d).\n",
-					cnt, pcrs_strerror(nsubs), nsubs);
-            if(new) {
-                free(new);
-                new = NULL;
-            }
-			break;
-		}
-
-		assert(strlen(new) == *newsize);
-
-		if(old != cp) {
-			// free the intermediate result.
-			free(old);
-		}
-		old = new;
-		job = job->next;
-		cnt += 1;
-	}
-
-    return new;
-}
-
-
-// This routine is hellish because neither stream is line buffered.
-// Therefore, we line buffer the file and compare in chunks against
-// the input.  "pbuf" is the substitution-modified buffer allocated
-// by the pcre library.
-
-static void compare_continue_lines(scanstate *ss, compare_state *cmp,
-		const char *ptr, size_t len)
-{
-	int n;
-	const char *p;
-    char *new;
-    size_t newsize;
-
-	while(len > 0) {
-		n = cmp->plimit - cmp->pcursor;
-		assert(n >= 0);
-		if(n) {
-			// there's more data in the pbuf.  use it for comparison.
-			if(len < n) n = len;
-			if(memcmp(ptr, cmp->pbuf+cmp->pcursor, n) != 0) {
-				compare_halt(ss, match_no);
-				return;
-			}
-			cmp->pcursor += n;
-			ptr += n;
-			len -= n;
-			assert(len >= 0);
-			if(!len) break;
-		}
-
-		// we've emptied the pbuf so we need to regenerate it.
-		// first see if there's anther line in the line buffer.
-		p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-		if(!p) {
-			// there's no newline in the buffer.  try to refill.
-			n = compare_fill(ss);
-			if(n < 0) {
-				// there was an error while trying to fill the buffer
-				// TODO: this should be propagated to the client somehow.
-				perror("compare_continue_lines");
-				exit(10);
-			}
-			if(n == 0) {
-                compare_halt(ss, match_no);
-                return;
-			}
-
-			p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-			if(!p) {
-				// we'll just have to treat the entire buffer as a full
-				// line and hope for the best.  Subtract one because
-				// the very next line will add one.
-				p = ss->limit - 1;
-			}
-		}
-
-		// move p past the newline so it's at the end of the current line.
-		p += 1;
-		new = substitute_string(cmp->jobs, ss->cursor, p, &newsize);
-        if(!new) {
-            // there must have been an error
-            compare_halt(ss, match_no);
-            return;
-        }
-
-        if(cmp->pbuf) free((char*)cmp->pbuf);
-        cmp->pbuf = new;
-        cmp->pcursor = 0;
-        cmp->plimit = newsize;
-		ss->cursor = p;
-	}
-}
-
-
-void compare_continue(scanstate *ss, const char *ptr, int len)
-{
-	compare_state *cmp = (compare_state*)ss->scanref;
-
-    if(!ss->scanref) {
-        // we already decided the files don't match
-        // so don't waste time comparing more.
-        return;
-    }
-
-    assert(len >= 0);
-
-    if(cmp->no_trailing_newline) {
-        // If the incoming buffer ends in a nl, we need to suppress it
-        // for the comparison.  Note that this won't work well for
-        // MODIFY clauses but I don't care because MODIFY will never
-        // work with -n and, anyway, MODIFY is about to disappear.
-
-        if(cmp->nl_suppressed) {
-            compare_continue_bytes(ss, "\n", 1);
-            cmp->nl_suppressed = 0;
-        }
-
-        if(ptr[len-1] == '\n') {
-            cmp->nl_suppressed = 1;
-            len -= 1;
-        }
-    }
-
-	if(cmp->jobs) {
-		compare_continue_lines(ss, cmp, ptr, len);
-	} else {
-		compare_continue_bytes(ss, ptr, len);
-	}
-}
-
-
-void compare_end(scanstate *ss)
-{
-	compare_state *cmp = (compare_state*)ss->scanref;
-
-    if(!ss->scanref) {
-        // we already decided the files don't match
-        // so don't waste time comparing more.
-        return;
-    }
-
-	assert(cmp->pcursor <= cmp->plimit);
-	assert(ss->cursor <= ss->limit);
-
-	if(cmp->jobs) {
-		// if there's more data in the pbuf then fail.
-		if(cmp->plimit - cmp->pcursor != 0) {
-			compare_halt(ss, match_no);
-			return;
-		}
-	}
-
-	// if we have no data left in the scan buffer
-	if(ss->cursor == ss->limit) {
-		// and our input file is at eof
-		if(compare_fill(ss) == 0) {
-			// then the two data streams match
-			compare_halt(ss, match_yes);
-			return;
-		}
-	}
-
-    // otherwise, they don't.
-    compare_halt(ss, match_no);
-}
-
-

Copied: releases/0.94/compare.c (from rev 99, trunk/compare.c)

Deleted: releases/0.94/compare.h
===================================================================
--- trunk/compare.h	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/compare.h	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,27 +0,0 @@
-/* compare.h
- * Scott Bronson
- * 31 Dec 2004
- *
- * File comparison prototypes.
- *
- * See compare.c for license.
- */
-
-#include "pcrs.h"
-#include "matchval.h"
-#include "re2c/scan.h"
-
-
-/** Returns zero if the compare has stopped (i.e. the files differed).
- */
-
-#define compare_in_progress(ss) ((ss)->scanref)
-
-
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *joblist, int nonl);
-void compare_continue(scanstate *ss, const char *ptr, int len);
-void compare_end(scanstate *cmp);
-
-// no better place to put this for now...
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize);
-

Copied: releases/0.94/compare.h (from rev 99, trunk/compare.h)

Deleted: releases/0.94/curdir.c
===================================================================
--- trunk/curdir.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/curdir.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,140 +0,0 @@
-/* curdir.c
- * 29 Jan 2005
- * Copyright (C) 2005 Scott Bronson
- *
- * This file is distrubuted under the MIT License
- * See http://en.wikipedia.org/wiki/MIT_License for more.
- *
- * Some simple path handling routines
- *
- * Unfortunately this file got hacked to shreds when tmtest was
- * made to run with /tmp as the constant cwd.  It's pretty
- * incomprehensible and in dire need of a rewrite.
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <dirent.h>
-#include <unistd.h>
-#include <assert.h>
-
-#include "curdir.h"
-
-
-static char curdir[CURDIR_SIZE];
-static char *curpart;
-
-
-int curinit(const char *path)
-{
-	if(path) {
-		if(strlen(path)+1 > sizeof(curdir)) {
-			return -1;
-		}
-		strcpy(curdir, path);
-		curpart = NULL;	// don't use partials when inited from a path
-	} else {
-		if(!getcwd(curdir, sizeof(curdir))) {
-			return -1;
-		}
-		curpart = curdir + strlen(curdir) + 1;
-		*curpart = '\0';
-	}
-
-	return 0;
-}
-
-
-/**
- * @returns the number of directories you just pushed.
- * You'll need to pass this value to curpop if you want to pop
- * the same number of directories when you're done.
- */
-
-int curpush(const char *dir)
-{
-	int clen = strlen(curdir);
-	int dlen = strlen(dir);
-	int keep = 1;
-	const char *cp;
-
-	assert(dir);
-	assert(dir[0]);
-	assert(dir[0] != '/');
-
-	// count the number of '/' characters in dir
-	for(cp=dir; (cp=strchr(cp,'/'))!=0; cp++) {
-		keep++;
-	}
-
-	if(clen + dlen + 2 > sizeof(curdir)) {
-		return -1;
-	}
-
-	strcat(curdir, "/");
-	strcat(curdir, dir);
-
-	return keep;
-}
-
-
-void curpop(int keep)
-{
-	assert(keep>0);
-
-	while(keep) {
-		char *cp = strrchr(curdir, '/');
-		assert(curpart <= cp+1);
-		if(!cp) {
-			// we've run out of slashes.
-			assert(!"out of slashes -- that's bad.");
-			return;
-		}
-
-		cp[0] = '\0';	// get rid of the slash.
-		cp[1] = '\0';	// blank out curpart or any other ptrs to this dir.
-		keep -= 1;
-	}
-}
-
-
-/** Resets the curdir so that curabsolute() and currelative()
- *  return what they did after curinit() was first called.
- */
-
-void curreset()
-{
-	if(curpart) {
-		curpart[-1] = '\0';
-		curpart[0] = '\0';
-	}
-}
-
-
-void cursave(struct cursave *save)
-{
-	strcpy(save->buf, curdir);
-	save->part = curpart;
-}
-
-
-void currestore(struct cursave *save)
-{
-	strcpy(curdir, save->buf);
-	curpart = save->part;
-}
-
-
-const char *curabsolute()
-{
-	return curdir;
-}
-
-
-const char *currelative()
-{
-	return curpart ? curpart : curdir;
-}
-
-
-

Copied: releases/0.94/curdir.c (from rev 99, trunk/curdir.c)

Deleted: releases/0.94/examples/docs/Modify3.test
===================================================================
--- trunk/examples/docs/Modify3.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/examples/docs/Modify3.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,7 +0,0 @@
-# This is from http://tmtest.berlios.de/wiki/index.php/MODIFY
-
-date
-MODIFY:
-  s/... +... +[0-9][0-9] +[0-9]?[0-9]:[0-9][0-9]:[0-9][0-9] +... +20[0-9][0-9]/date date date/
-STDOUT:
-date date date

Copied: releases/0.94/examples/docs/Modify3.test (from rev 98, trunk/examples/docs/Modify3.test)

Copied: releases/0.94/examples/docs/testfile (from rev 99, trunk/examples/docs/testfile)

Deleted: releases/0.94/examples/tutorial/20-ArgSuppressNL.test
===================================================================
--- trunk/examples/tutorial/20-ArgSuppressNL.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/examples/tutorial/20-ArgSuppressNL.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,3 +0,0 @@
-echo -n "No newline"
-STDOUT:
-No newline
\ No newline at end of file

Copied: releases/0.94/examples/tutorial/20-ArgSuppressNL.test (from rev 100, trunk/examples/tutorial/20-ArgSuppressNL.test)

Deleted: releases/0.94/main.c
===================================================================
--- trunk/main.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/main.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,904 +0,0 @@
-/* main.c
- * 28 Dec 2004
- * Copyright (C) 2004 Scott Bronson
- * 
- * The main routine for tmtest.
- *
- * This file is distrubuted under the MIT License
- * See http://en.wikipedia.org/wiki/MIT_License for more.
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/wait.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <getopt.h>
-#include <assert.h>
-
-#include "re2c/read-fd.h"
-
-#include "test.h"
-#include "curdir.h"
-#include "qscandir.h"
-#include "vars.h"
-#include "tfscan.h"
-#include "rel2abs.h"
-
-
-#define DIFFPROG "/usr/bin/diff"
-#define SHPROG   "/bin/bash"
-
-
-enum {
-    outmode_test,
-    outmode_dump,
-    outmode_diff
-};
-
-int outmode = outmode_test;
-int allfiles = 0;
-int dumpscript = 0;
-int quiet = 0;
-char *config_file;	// absolute path to the user-specified config file
-					// null if user didn't specify a config file.
-
-
-#define TESTDIR "/tmp/tmtest-XXXXXX"
-char g_testdir[sizeof(TESTDIR)];
-
-#define OUTNAME "stdout"
-#define ERRNAME "stderr"
-#define STATUSNAME "status"
-char g_outname[sizeof(TESTDIR)+sizeof(OUTNAME)];
-char g_errname[sizeof(TESTDIR)+sizeof(ERRNAME)];
-char g_statusname[sizeof(TESTDIR)+sizeof(STATUSNAME)];
-
-// file in tmpdir that holds stdout
-#define DIFFNAME "diff"
-
-
-int g_outfd;
-int g_errfd;
-int g_statusfd;
-
-
-
-// exit values:
-enum {
-    no_error = 0,
-    argument_error,
-    runtime_error,
-    interrupted_error,
-    internal_error,
-	initialization_error,
-};
-
-
-#define xstringify(x) #x
-#define stringify(x) xstringify(x)
-
-
-#define is_dash(s) ((s)[0] == '-' && (s)[1] == '\0')
-
-
-/** Returns zero if s1 ends with s2, nonzero if not.
- */
-
-int strcmpend(const char *s1, const char *s2)
-{
-    size_t n1 = strlen(s1);
-    size_t n2 = strlen(s2);
-
-    if(n2 <= n1) {
-        return strncmp(s1+n1-n2, s2, n2);
-    } else {
-        return 1;
-    }
-}
-
-
-/** Prints the given template to the given file, performing substitutions.
- */
-
-void print_template(struct test *test, const char *tmpl,  FILE *fp)
-{
-    char varbuf[32];
-    const char *cp, *ocp, *ce;
-    int len;
-
-    for(ocp=cp=tmpl; (cp=strchr(cp,'%')); cp++) {
-        if(cp[1] == '(') {
-            // perform a substitution
-            fwrite(ocp, cp - ocp, 1, fp);
-            cp += 2;
-            ce = strchr(cp,')');
-            if(!ce) {
-                fprintf(stderr, "Unterminated template variable: '%.20s'\n", cp);
-                exit(runtime_error);
-            }
-            len = ce - cp;
-            if(len <= 0) {
-                fprintf(stderr, "Garbage template variable: '%.20s'\n", cp);
-                exit(runtime_error);
-            }
-            // truncate variable name if it doesn't fit into varbuf.
-            if(len > sizeof(varbuf)-1) {
-                len = sizeof(varbuf)-1;
-            }
-            memcpy(varbuf, cp, len);
-            varbuf[len] = '\0';
-            if(printvar(test,fp,varbuf) != 0) {
-                // printvar has already printed the error message
-                exit(runtime_error);
-            }
-            ocp = cp = ce+1;
-        }
-    }
-
-    fputs(ocp, fp);
-}
-
-
-/** Checks the actual results against the expected results.
- *
- * Returns 0 if all results match, or a code telling what
- * part didn't match.
- */
-
-
-void reset_fd(int fd, const char *fname)
-{
-    if(lseek(fd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "Couldn't seek to start of %s: %s\n",
-                fname, strerror(errno));
-        exit(runtime_error);
-    }
-
-    if(ftruncate(fd, 0) < 0) {
-        fprintf(stderr, "Couldn't reset file %s: %s\n",
-                fname, strerror(errno));
-        exit(runtime_error);
-    }
-}
-
-
-int wait_for_child(int child, const char *name)
-{
-    int pid;
-    int signal;
-    int status;
-
-    // wait patiently for child to finish.
-    pid = waitpid(child, &status, 0);
-    if(pid < 0) {
-        fprintf(stderr, "Error waiting for %s to finish: %s\n",
-                strerror(errno), name);
-        exit(runtime_error);
-    }
-
-    if(WIFSIGNALED(status)) {
-        signal = WTERMSIG(status);
-        if(signal == SIGINT) {
-            // If test was interrupted with a sigint then raise it on ourselves.
-            // Otherwise it can be hard to interrupt a test battery.
-			kill(getpid(), SIGINT);
-        }
-        // it's probably a SIGABRT if child hit an assertion.
-        // we'll just return 256.
-        return 256;
-    }
-
-    if(!WIFEXITED(status)) {
-        fprintf(stderr, "Unknown status returned by %s: %d\n", name, status);
-        exit(runtime_error);
-    }
-
-    return WEXITSTATUS(status);
-}
-
-
-int open_file(char *fn, const char *name, int flags)
-{
-	strcpy(fn, g_testdir);
-	strcat(fn, "/");
-	strcat(fn, name);
-
-    int fd = open(fn, flags|O_RDWR|O_CREAT/*|O_EXCL*/, S_IRUSR|S_IWUSR);
-    if(fd < 0) {
-        fprintf(stderr, "couldn't open %s: %s\n", fn, strerror(errno));
-        exit(runtime_error);	// TODO
-    }
-
-    return fd;
-}
-
-
-int write_stdin_to_tmpfile(struct test *test)
-{
-	char *buf;
-	int fd;
-
-	buf = malloc(sizeof(TESTDIR) + sizeof(DIFFNAME));
-	if(!buf) {
-		perror("malloc");
-		exit(10);	// TODO
-	}
-
-	test->diffname = buf;
-	fd = open_file(buf, DIFFNAME, 0);
-	assert(strlen(buf) == sizeof(TESTDIR)+sizeof(DIFFNAME)-1);
-	write_raw_file(fd, 0);
-	close(fd);
-
-	return fd;
-}
-
-
-/** Forks off a diff process and sets it up to receive the dumped test.
- */
-
-int start_diff(struct test *test)
-{
-    int pipes[2];
-    int child;
-	const char *filename = NULL;
-
-    assert(test->testfilename);
-	// if the test is coming from stdin, we need to copy it to a
-	// real file before we can diff against it.
-    if(is_dash(test->testfilename)) {
-		// first, write all of our stdin to a tmpfile.
-		write_stdin_to_tmpfile(test);
-		// then, read the test from this file instead of stdin.
-		filename = test->diffname;
-		assert(filename);
-    }
-
-    if(pipe(pipes) < 0) {
-        perror("creating diff pipe");
-        exit(runtime_error);
-    }
-
-    child = fork();
-    if(child < 0) {
-        perror("forking diff");
-        exit(runtime_error);
-    }
-    if(child == 0) {
-        if(dup2(pipes[0], 0) < 0) {
-            perror("dup2ing test output to child's stdin");
-            exit(runtime_error);
-        }
-        close(pipes[0]);
-        close(pipes[1]);
-
-		if(!filename) {
-			// figure out the filename that diff will use
-			if(test->testfilename[0] == '/') {
-				filename = test->testfilename;
-			} else {
-				// since we don't have an absolute path, we need to
-				// cd to the original wd and run the diff with
-				// a relative path.  it takes a bit of computation...
-				curpush(test->testfilename);
-				filename = strdup(currelative());
-				if(!filename) {
-					perror("strdup in start_diff");
-					exit(runtime_error);
-				}
-				curreset();
-				if(0 != chdir(curabsolute())) {
-					fprintf(stderr, "Could not chdir 1 to %s: %s\n", curabsolute(), strerror(errno));
-					exit(runtime_error);
-				}
-			}
-		}
-
-        execl(DIFFPROG, DIFFPROG, "-u", filename, "-", (char*)NULL);
-        perror("executing " DIFFPROG " for test");
-        exit(runtime_error);
-    }
-
-    close(pipes[0]);
-    test->rewritefd = pipes[1];
-
-    return child;
-}
-
-
-/** Waits for the forked diff process to finish.
- */
-
-void finish_diff(struct test *test, int diffpid)
-{
-    close(test->rewritefd);
-
-    int status = wait_for_child(diffpid, "diff");
-
-    if(status != 0 && status != 1) {
-        fprintf(stderr, "diff returned %d!\n", status);
-        exit(runtime_error);
-    }
-}
-
-
-/** Runs the named testfile.
- *
- * If warn_suffix is true and the ffilename doesn't end in ".test"
- * then we'll print a warning to stderr.  This is used when
- * processing the cmdline args so the user will know why a file
- * explicitly named didn't run.
- *
- * When config files are executing, they use the standard stdout
- * and stderr.  That way, the user sees any output while the test
- * is running (should help with debugging).  However, when the
- * test itself is running, its output is redirected into outfd/errfd.
- *
- * It may appear that outmode_dump mixes stdio and Unix I/O, but it
- * doesn't really.  We only print to stdio when testing, and we only
- * dump the file when dumping.  They cannot both happen simultaneously.
- *
- * @returns 1 if we should keep testing, 0 if we should stop now.
- */
-
-int run_test(const char *name, int warn_suffix)
-{
-    struct test test;
-    char buf[BUFSIZ];   // scan buffer for the testfile
-    int pipes[2];
-    int child;
-	int keepontruckin;
-    int diffpid;
-    int fd = -1;
-    FILE *tochild;
-
-    // defined in the exec.c file generated by exec.tmpl.
-    extern const char exec_template[];
-
-    if(!is_dash(name) && !allfiles && (strcmpend(name, ".test") != 0)) {
-        if(warn_suffix) {
-            fprintf(stderr, "%s was skipped because it doesn't end in '.test'.\n", name);
-        }
-        return 1;
-    }
-
-	// so that we can safely single quote filenames in the shell.
-	if(strchr(name, '\'') || strchr(name, '"')) {
-		fprintf(stderr, "%s was skipped because its file name contains a quote character.\n", name);
-		return 1;
-	}
-
-    test_init(&test);
-    test.testfilename = name;
-    test.outfd = g_outfd;
-    test.errfd = g_errfd;
-    test.statusfd = g_statusfd;
-
-    // initialize the test mode
-    switch(outmode) {
-        case outmode_test:
-            // nothing to do
-            break;
-        case outmode_dump:
-            test.rewritefd = STDOUT_FILENO;
-            break;
-        case outmode_diff:
-            diffpid = start_diff(&test);
-            break;
-        default:
-            assert(!"Unhandled outmode 1 in run_test()");
-    }
-
-    // reset the stdout and stderr capture files.
-    reset_fd(test.outfd, "stdout");
-    reset_fd(test.errfd, "stderr");
-    reset_fd(test.statusfd, "status");
-
-    // set up the pipe to feed input to the child.
-    // ignore sigpipes since we don't want a signal raised if child
-    // quits early (which almost always happens since it exits before
-    // it reads its expected stdout/stderr).
-    if(pipe(pipes) < 0) {
-        perror("creating test pipe");
-        exit(runtime_error);
-    }
-
-    // fork child process
-    child = fork();
-    if(child < 0) {
-        perror("forking test");
-        exit(runtime_error);
-    }
-    if(child == 0) {
-        if(dup2(pipes[0], 0) < 0) {
-            perror("dup2ing input to test's stdin");
-            exit(runtime_error);
-        }
-        close(pipes[0]);
-        close(pipes[1]);
-        execl(SHPROG, SHPROG, "-s", (char*)NULL);
-        perror("executing " SHPROG " for test");
-        exit(runtime_error);
-    }
-
-    // create the testfile scanner.  it will either scan from
-    // the testfile itself or from stdin if filename is "-".
-    scanstate_init(&test.testfile, buf, sizeof(buf));
-	if(test.diffname) {
-		if(lseek(test.diff_fd, 0, SEEK_SET) < 0) {
-			fprintf(stderr, "Couldn't seek to start of %s: %s\n",
-					test.diffname, strerror(errno));
-			exit(runtime_error);
-		}
-        readfd_attach(&test.testfile, test.diff_fd);
-	} else if(is_dash(name)) {
-        readfd_attach(&test.testfile, STDIN_FILENO);
-    } else {
-		if(name[0] == '/') {
-			fd = open(name, O_RDONLY);
-		} else {
-			int keep = curpush(name);
-			if(keep <= 0) {
-				fprintf(stderr, "Path is too long.");
-				exit(runtime_error);
-			}
-			fd = open(curabsolute(), O_RDONLY);
-			curpop(keep);
-		}
-        if(fd < 0) {
-            fprintf(stderr, "Could not open %s: %s\n",
-                    curabsolute(), strerror(errno));
-            exit(runtime_error); // TODO
-        }
-        readfd_attach(&test.testfile, fd);
-    }
-    tfscan_attach(&test.testfile);
-
-    if(dumpscript) {
-        print_template(&test, exec_template, stdout);
-        exit(0);  // screw the kid
-    }
-
-    // set up the pipes for the parent
-    close(pipes[0]);
-    tochild = fdopen(pipes[1], "w");
-    if(!tochild) {
-        perror("calling fdopen on pipe");
-        exit(runtime_error);
-    }
-
-    // write the test script to the kid
-    print_template(&test, exec_template, tochild);
-    fclose(tochild);
-
-    // wait for the test to finish
-    test.exitno = wait_for_child(child, "test");
-
-	// read the status file to determine what happened
-	// and store the information in the test struct.
-	scan_status_file(&test);
-
-    // process and output the test results
-    switch(outmode) {
-        case outmode_test:
-            test_results(&test);
-            break;
-        case outmode_dump:
-            dump_results(&test);
-            break;
-        case outmode_diff:
-            dump_results(&test);
-            finish_diff(&test, diffpid);
-            break;
-        default:
-            assert(!"Unhandled outmode 2 in run_test()");
-    }
-
-    // if we had to open the testfile to read it, we now close it.
-    // because the scanner is statically allocated, there's no
-    // need to destroy it.
-    if(fd >= 0) {
-        close(fd);
-    }
-	keepontruckin = !test.aborted;
-    test_free(&test);
-
-	return keepontruckin;
-}
-
-
-/** This routine filters out any dirents that begin with '.'.
- *  We don't want to process any hidden files or special directories.
- */
-
-int select_nodots(const struct dirent *d)
-{
-    return d->d_name[0] != '.';
-}
-
-
-// forward declaration for recursion
-int process_dir();
-
-
-/** Processes a directory specified using an absolute path.
- *
- * We need to save and restore curpath to do this.
- *
- * @returns 1 if we should continue testing, 0 if we should abort.
- */
-
-int process_absolute_file(const char *path, int warn_suffix)
-{
-	struct cursave save;
-	int keepontruckin;
-
-	cursave(&save);
-	curinit("/");
-
-	if(outmode == outmode_test) {
-		printf("\nProcessing %s\n", path);
-	}
-	keepontruckin = run_test(path, warn_suffix);
-
-	currestore(&save);
-	return keepontruckin;
-}
-
-
-/** Processes a directory specified using an absolute path.
- *
- * We need to save and restore curpath to do this.
- */
-
-int process_absolute_dir(const char *path)
-{
-	struct cursave save;
-	int keepontruckin;
-
-	cursave(&save);
-	curinit(path);
-
-	if(outmode == outmode_test) {
-		printf("\nProcessing %s\n", path);
-	}
-	keepontruckin = process_dir();
-
-	currestore(&save);
-
-	return keepontruckin;
-}
-
-
-/** Process all entries in a directory.
- *
- * See run_test() for an explanation of warn_suffix.
- */
-
-int process_ents(char **ents, int warn_suffix)
-{
-    struct stat st;
-    mode_t *modes;
-    int i, n;
-	int keepontruckin;
-
-    for(n=0; ents[n]; n++)
-        ;
-
-    modes = malloc(n * sizeof(mode_t));
-    if(!modes) {
-        fprintf(stderr, "Could not allocate %d mode_t objects.\n", n);
-        exit(runtime_error);
-    }
-    
-    // first collect the stat info for each entry
-    for(i=0; i<n; i++) {
-        if(!is_dash(ents[i])) {
-			const char *cp = ents[i];
-			int keep = 0;
-			if(ents[i][0] != '/') {
-				keep = curpush(ents[i]);
-				if(keep <= 0) {
-					fprintf(stderr, "Path is too long.");
-					exit(runtime_error);
-				}
-				cp = curabsolute();
-			}
-            if(stat(cp, &st) < 0) {
-                fprintf(stderr, "%s: %s\n", cp, strerror(errno));
-                exit(runtime_error);
-            }
-			if(ents[i][0] != '/') curpop(keep);
-            modes[i] = st.st_mode;
-        }
-    }
-
-    // process all files in dir
-    for(i=0; i<n; i++) {
-        if(is_dash(ents[i]) || S_ISREG(modes[i])) {
-			if(ents[i][0] == '/') {
-				keepontruckin = process_absolute_file(ents[i], warn_suffix);
-			} else {
-				keepontruckin = run_test(ents[i], warn_suffix);
-			}
-			if(!keepontruckin) {
-				goto abort;
-			}
-            modes[i] = 0;
-        }
-    }
-
-    // process all subdirs
-    for(i=0; i<n; i++) {
-        if(is_dash(ents[i]) || modes[i] == 0) continue;
-        if(S_ISDIR(modes[i])) {
-			if(ents[i][0] == '/') {
-				keepontruckin = process_absolute_dir(ents[i]);
-			} else {
-				int keep = curpush(ents[i]);
-				if(keep <= 0) {
-					fprintf(stderr, "Path is too long.");
-					exit(runtime_error);
-				}
-				if(outmode == outmode_test) {
-					printf("\nProcessing ./%s\n", currelative());
-				}
-				keepontruckin = process_dir();
-				curpop(keep);
-			}
-			if(!keepontruckin) {
-				goto abort;
-			}
-        }
-    }
-
-abort:
-    free(modes);
-	return keepontruckin;
-}
-
-
-/** Runs all tests in the current directory and all its subdirectories.
- */
-
-int process_dir()
-{
-    char **ents;
-    int i;
-	int keepontruckin;
-
-    ents = qscandir(curabsolute(), select_nodots, qdirentcoll);
-    if(!ents) {
-        // qscandir has already printed the error message
-        exit(runtime_error);
-    }
-
-    keepontruckin = process_ents(ents, 0);
-
-    for(i=0; ents[i]; i++) {
-        free(ents[i]);
-    }
-    free(ents);
-
-	return keepontruckin;
-}
-
-
-static void checkerr(int err, const char *op, const char *name)
-{
-	if(err < 0) {
-		fprintf(stderr, "There was an error %s %s: %s\n",
-				op, name, strerror(errno));
-		// not much else we can do other than complain...
-	}
-}
-
-
-void stop_tests()
-{
-	checkerr(close(g_outfd), "closing", g_outname);
-	checkerr(close(g_errfd), "closing", g_errname);
-	checkerr(close(g_statusfd), "closing", g_statusname);
-
-	checkerr(unlink(g_outname), "deleting", g_outname);
-	checkerr(unlink(g_errname), "deleting", g_errname);
-	checkerr(unlink(g_statusname), "deleting", g_statusname);
-
-	checkerr(rmdir(g_testdir), "removing directory", g_testdir);
-}
-
-
-static void sig_int(int blah)
-{
-	stop_tests();
-	exit(interrupted_error);
-}
-
-
-/** Prepare system for running tests.
- *
- * We do all I/O for all tests through only three file descriptors.
- * We seek to the beginning of each file before running each test.
- * This should save some inode thrashing.
- */
-
-void start_tests()
-{
-	char *cp;
-
-    signal(SIGPIPE, SIG_IGN);
-    signal(SIGINT, sig_int);
-
-	strcpy(g_testdir, TESTDIR);
-	if(!mkdtemp(g_testdir)) {
-		fprintf(stderr, "Could not call mkdtemp() on %s: %s\n", g_testdir, strerror(errno));
-		exit(initialization_error);
-	}
-
-	// errors are handled by open_file.
-    g_outfd = open_file(g_outname, OUTNAME, 0);
-	assert(strlen(g_outname) == sizeof(g_outname)-1);
-    g_errfd = open_file(g_errname, ERRNAME, 0);
-	assert(strlen(g_errname) == sizeof(g_errname)-1);
-    g_statusfd = open_file(g_statusname, STATUSNAME, O_APPEND);
-	assert(strlen(g_statusname) == sizeof(g_statusname)-1);
-
-	if(curinit(NULL) != 0) {
-		fprintf(stderr, "Could not get the cwd: %s\n", strerror(errno));
-		exit(initialization_error);
-	}
-
-	// tmtest always runs with the CWD pointed to the temporary directory
-	cp = getenv("TMPDIR");
-	if(!cp) cp = "/tmp";
-	if(chdir(cp) != 0) {
-		fprintf(stderr, "Could not chdir 2 to %s: %s\n", cp, strerror(errno));
-		exit(initialization_error);
-	}
-}
-
-
-void set_config_file(const char *cfg)
-{
-	char cwd[PATH_MAX];
-	char out[PATH_MAX];
-	char *path;
-
-	if(!getcwd(cwd, PATH_MAX)) {
-		perror("Couldn't get current working directory");
-		exit(runtime_error);
-	}
-
-	path = rel2abs(cfg, cwd, out, PATH_MAX);
-	if(!path) {
-		fprintf(stderr, "Got %d figuring out absolute path for \"%s\": %s",
-				errno, cfg, strerror(errno));
-		exit(runtime_error);
-	}
-
-	config_file = strdup(out);
-	if(!config_file) {
-		perror("strdup");
-		exit(runtime_error);
-	}
-}
-
-
-void usage()
-{
-	printf(
-			"Usage: tmtest [OPTION]... [DLDIR]\n"
-			"  -o: output the test file with the new output.\n"
-			"  -d: output a diff between the expected and actual outputs.\n"
-			"  -V --version: print the version of this program.\n"
-			"  -h --help: prints this help text\n"
-			"Run tmtest with no arguments to run all tests in the current directory.\n"
-		  );
-}
-
-
-void process_args(int argc, char **argv)
-{
-    char buf[256], *cp;
-    int optidx, i, c;
-
-	optidx = 0;
-	static struct option longopts[] = {
-		// name, has_arg (1=reqd,2=opt), flag, val
-		{"all-files", 0, &allfiles, 1},
-		{"config", 1, 0, 'c'},
-		{"diff", 0, 0, 'd'},
-		{"dump-script", 0, &dumpscript, 1},
-		{"help", 0, 0, 'h'},
-		{"output", 0, 0, 'o'},
-		{"quiet", 0, 0, 'q'},
-		{"version", 0, 0, 'V'},
-		{0, 0, 0, 0},
-	};
-
-	// dynamically create the option string from the long
-	// options.  Why oh why doesn't glibc do this for us???
-	cp = buf;
-	for(i=0; longopts[i].name; i++) {
-		if(!longopts[i].flag) {
-			*cp++ = longopts[i].val;
-			if(longopts[i].has_arg > 0) *cp++ = ':';
-			if(longopts[i].has_arg > 1) *cp++ = ':';
-		}
-	}
-	*cp++ = '\0';
-
-	while(1) {
-		c = getopt_long(argc, argv, buf, longopts, &optidx);
-		if(c == -1) break;
-
-		switch(c) {
-			case 'c':
-				set_config_file(optarg);
-				break;
-
-            case 'd':
-                outmode = outmode_diff;
-                break;
-
-			case 'h':
-				usage();
-				exit(0);
-
-			case 'o':
-                outmode = outmode_dump;
-				break;
-
-			case 'q':
-				quiet++;
-				break;
-
-			case 'V':
-				printf("tmtest version %s\n", stringify(VERSION));
-				exit(0);
-
-			case '?':
-				// getopt_long already printed the error message
-				exit(argument_error);
-
-			case 0:
-				// an option was automatically set
-				break;
-
-			default:
-				fprintf(stderr, "getopt_long returned something weird: %d\n", c);
-				exit(internal_error);
-		}
-	}
-}
-
-
-int main(int argc, char **argv)
-{
-	process_args(argc, argv);
-
-    start_tests();
-    if(optind < argc) {
-        process_ents(argv+optind, 1);
-    } else {
-        if(outmode == outmode_test) {
-            printf("\nProcessing .\n");
-        }
-        process_dir();
-    }
-    stop_tests();
-
-    if(outmode == outmode_test) {
-        print_test_summary();
-    }
-
-	return 0;
-}
-

Copied: releases/0.94/main.c (from rev 99, trunk/main.c)

Copied: releases/0.94/make-dist (from rev 89, trunk/make-dist)

Deleted: releases/0.94/re2c/read.c
===================================================================
--- trunk/re2c/read.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/re2c/read.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,52 +0,0 @@
-/* re2c.c
- * Scott Bronson
- * 28 Dec 2004
- */
-
-#include <string.h>
-#include <assert.h>
-#include "scan.h"
-
-
-
-/** Rearrange the scan buffer.  Only called by readprocs.
- *
- * This moves all in-flight data to the bottom of the buffer
- * to free up more room.
- *
- * Your readproc should read as much as it can between ss->limit
- * and ss->buf+ss->bufsiz.  It should adjust ss->limit to point
- * to the new end of data (the end of the buffer if it was able to
- * execute a complete read).
- *
- * Returns the number of bytes available to read in the buffer.
- */
-
-/* TODO: could optimize for the fast case (no data that needs
- * to be shifted).  However, there's no burning need -- it wouldn't
- * offer much speedup  Bigger buffers would help a lot more.
- * NOTE: the middle line of this macro is incomplete!  Don't use!
-
-#define read_shiftbuf(ss) (ss->token == ss->limit ? \
-    (ss->token = ss->cursor = ss->bufptr, 0) : \
-    _read_shiftbuf(ss)) 
-
- */
-
-int read_shiftbuf(scanstate *ss)
-{
-    int cnt = ss->token - ss->bufptr;
-    if(cnt) {
-        memmove((void*)ss->bufptr, ss->token, ss->limit - ss->token);
-        ss->token = ss->bufptr;
-        ss->cursor -= cnt;
-        if(ss->marker) ss->marker -= cnt;
-        ss->limit -= cnt;
-        assert(ss->limit >= ss->bufptr);
-        assert(ss->cursor >= ss->bufptr);
-        assert(ss->cursor <= ss->limit);
-    }
-
-    return ss->bufsiz - (ss->bufptr - ss->limit);
-}
-

Copied: releases/0.94/re2c/read.c (from rev 94, trunk/re2c/read.c)

Deleted: releases/0.94/re2c/scan.h
===================================================================
--- trunk/re2c/scan.h	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/re2c/scan.h	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,311 +0,0 @@
-/* scan.h
- * Scott Bronson
- * 27 Dec 2004
- *
- * This part of support code to make writing re2c scanners much easier.
- *
- * TODO: probably want to split the re2c-specific code from the general
- * code.  This file is overall very useful, but it's got a few limitations
- * imposed by re2c that should probably be placed in its own layer.
- * That way, future versions of re2c won't have to suffer the same
- * limitations.
- */
-
-/** @file scan.h
- *
- * This is the central file for the readers.  They provide data
- * for scanners.
- *
- * TERMINOLOGY
- *
- * allocate: scanstates can be dynamically (dynamicscan_create()) or
- * statically (scanstate_init()) allocated.  The buffers they use to
- * hold data may also be either dynamic or static.  Of course, any
- * time you allocate something dynamically, you must call the
- * corresponding free routine when you're done with it.
- *
- * attach: when the scanner is first initialized (scanstate_init())
- * or allocated (dynamicscan_create()), it is blank.  Trying to
- * pass it to a scanner would result in an assert or a crash.
- * You need to first attach a READER to provide data.
- *
- * initialize: prepare an already-allocated scanner for use.
- * After initializing it, you must ATTACH the scanner to a
- * READER.
- *
- * reader: reads data into the scanstate for the scanner.
- * Examples are readmem.c (read from a contiguous block in
- * memory), readfp.c (read from a FILE*), readfd.c (read
- * from a Unix file descriptor), etc.
- *
- * scanner: the function that actually performs the scanning.
- * It may or may not be written with the assistance of re2c.
- * It accepts a scanstate data structure and returns the next
- * token in the stream.
- *
- * scanstate: the data structure that retains complete state for the
- * scanner.  Scanners are thread safe: they never, ever use global
- * state.
- */
-
-
-#ifndef R2SCAN_H
-#define R2SCAN_H
-
-
-// for re2c...
-#define YYCTYPE     char
-#define YYCURSOR    (ss->cursor)
-#define YYLIMIT     (ss->limit)
-#define YYMARKER    (ss->marker)
-
-/** Fills the scan buffer with more data.
- *
- * This routine needs to force a return if 0 bytes were read because
- * otherwise the re2c scanner will end up scanning garbage way off
- * the end of the buffer.  There's no (good) way to tell the scanner
- * "the file is at eof so just finish the token that you're on" (right?).
- * It will always lose the token at the end of the file unless the file
- * ends in a token delimiter (usually a newline).
- *
- * We ignore n because there can be less than n bytes left in the file,
- * yet one or more tokens will still match.  Therefore, we should always
- * read as much data as we can, and we should return success even if we
- * have less than n bytes in the buffer.  N is totally useless.
- *
- * The last line is the limitation.  If it weren't there, YYFILL would
- * return with an empty buffer so re2c would know it's at EOF and
- * shut down gracefully.  But re2c can't handle that.
- *
- * If you're using the re2c lib but writing your own re2c scanners,
- * call ss->read directly.
- */
-
-#define YYFILL(n)   do { \
-		int r = (*ss->read)(ss); \
-		if(r < 0) return r; \
-		if((ss)->cursor >= (ss)->limit) return 0; \
-	} while(0);
-
-
-// forward declaration
-struct scanstate;
-
-
-/** Prototype of read function
- *
- * You only need to know this if you're writing your own read functions.
- *
- * This function is used to fetch more data for the scanner.  It must
- * first shift the pointers in ss to make room (see read_shiftbuffer())
- * then load new data into the unused bytes at the end of the buffer.
- *
- * I chose the shift technique over a ringbuffer because we should rarely
- * have to shift data.  If you find that your file has gigantic tokens
- * and you're burning a lot of cpu shifting partial tokens from the end
- * of the buffer to the start, you might want to use a ring buffer instead
- * of a shift buffer.  However, re2c itself can't handle ringbuffers or
- * split tokens (nor can most scanners that I'm aware of), so shift
- * buffers are the best we can do.
- *
- * This routine returns 0 when there's no more data (EOF).
- * If it returns a value less than 0, that value will be returned
- * to the caller instead of a token.  This can indicate an error
- * condition, or just a situation such as EWOULDBLOCK.
- *
- * Because of the way re2c handles buffering, it's possible for the
- * read routine to be called multiple times after it has returned eof.
- * This isn't an error.  If your read routine is called when
- * ss->at_eof is true, you should just return without doing anything.
- *
- * All charptrs in the scanstate structure are declared const to help
- * ensure that you don't
- * accidentally end up modifying the buffer as it's being scanned.
- * This means that your read routine must cast them to be mutable
- * (char*) before reading them.  Only the readproc should modify the
- * data that's in the scan buffer.
- *
- * The caller assumes that the read routine will always fill the buffer
- * up as much as possible.  Therefore, if the buffer isn't entirely full,
- * then it knows that the EOF is probably at the end of the data.  This
- * is a fine assumption for files but not so good for pipes, network
- * sockets, anything that is packetized or works in realtime.  It would
- * take a rewrite of re2c to remove this limitation. So, yes, your
- * scanner can assume that the read routine will always fill the buffer
- * up as much as it possibly can.
- */
-
-typedef int (*readproc)(struct scanstate *ss);
-
-
-/** Prototype of scanner function
- *
- * A scanner is simply a function that accepts a scanstate
- * object and returns the next token in that stream.
- * The function will typically be generated with the
- * assistance of re2c, but it doesn't have to be!
- *
- * Once you have created the scanstate data structure,
- * pass it to the scanner.  If the scanner returns 0,
- * you hit EOF.  If the scanner returns a negative number,
- * then some sort of error was encountered.  Or, if you're
- * doing nonblocking I/O, then it just might mean that this
- * there's not enough data available to determine the next
- * token.
- */
-
-typedef int (*scanproc)(struct scanstate *ss);
-
-
-
-/** Represents the current state for a single scanner.
- *
- * This structure is used by a scanner to preserve its state.
- *
- * All charptrs are declared const to help ensure that you don't
- * accidentally end up modifying the buffer as it's being scanned.
- * This means that any time you want to read the buffer, you need
- * to cast the pointers to be nonconst.
- */
-
-struct scanstate {
-    const char *cursor; ///< The current character being looked at by the scanner
-    const char *limit;  ///< The last valid character in the current buffer.  If the previous read was short, then this will not point to the end of the actual buffer (bufptr + bufsiz).
-    const char *marker; ///< Used internally by re2c engine to handle backtracking.
-
-    // (these do a poor job of simulating capturing parens)
-    const char *token;  ///< The start of the current token (manually updated by the scanner).
-    int line;           ///< The scanner may or may not maintain the current line number in this field.
-    int at_eof;         ///< You almost certainly don't want to be using this (unless you're writing a readproc).  Use scan_finished() instead.  This field gets set when the readproc realizes it has hit eof.  by convention 1 means eof, 2 means yes, at_eof is true, but because of an unrecoverable read error (todo: this should be formalized).
-
-    const char *bufptr; ///< The buffer currently in use
-    int bufsiz;         ///< The maximum number of bytes that the buffer can hold
-
-    void *readref;      ///< Data specific to the reader (i.e. for readfp_attach() it's a FILE*).
-    readproc read;      ///< The routine the scanner calls when the buffer needs to be reread.
-
-    void *scanref;      ///< Data specific to the scanner
-    scanproc state;     ///< The entrypoint for the scanning routine.  The name is now anachronistic but might still fit (some scanners are made up of multiple individual scan routines -- they store their state here).
-
-    void *userref;      ///< Never touched by any of our routines (except scanstate_init, which clears both fields).  This can be used to associate a parser with this scanner.
-    void *userproc;     ///< That's just a suggestion though.  These fields are totally under your control.
-};
-typedef struct scanstate scanstate;
-
-
-void scanstate_init(scanstate *ss, const char *bufptr, int bufsiz);
-void scanstate_reset(scanstate *ss);
-
-
-/** Returns true when there's no more data to be scanned.
- *
- * How what this macro does:
- *
- * If there's still more data in the buffer, then we're not finished.
- * If there's no data in the buffer and we're at EOF, then we're finished.
- * If there's no data in the buffer but we're not at eof, then we need
- * to execute a read to see if there's more data available.  If so, we're
- * not finished.  Otherwise, we're all done.
- */
-
-#define scan_finished(ss) \
-    (((ss)->cursor < (ss)->limit) ? 0 : \
-		 ((ss)->at_eof || ((*(ss)->read)(ss) <= 0)) \
-    )
-
-
-/** Fetches the next token in the stream from the scanner.
- */
-
-#define scan_token(ss) ((*((ss)->state))(ss))
-#define scan_next_token(ss) ((*((ss)->state))(ss))
-
-
-/** Returns a pointer to the first character of the
- *  most recently scanned token.
- */
-
-#define token_start(ss) ((ss)->token)
-#define current_token_start(ss) ((ss)->token)
-
-/** Returns a pointer to one past the last character of the
- *  most recently scanned token.
- *
- *  token_end(ss) - token_start(ss) == token_length(ss)
- */
-
-#define token_end(ss) ((ss)->cursor)
-#define current_token_end(ss) ((ss)->cursor)
-
-/** Returns the length of the most recently scanned token.
- */
-
-#define token_length(ss) ((ss)->cursor - (ss)->token)
-#define current_token_length(ss) ((ss)->cursor - (ss)->token)
-
-/** Returns the current token in a malloc'd buffer.
- * (just calls strdup(3) internally).
- */
-
-#define token_dup(ss) strndup(token_start(ss), token_length(ss))
-#define current_token_dup(ss) token_dup(ss)
-
-
-/** Pushes the current token back onto the stream
- *
- * Calling scan_pushback returns the scanner to the state it had
- * just before returning the current token.  If you decide that
- * you don't want to handle this token, you can push it back and
- * it will be returned again the next time scan_token() is called.
- *
- * Note that this only works once.  You cannot push multiple tokens back
- * into the scanner.  Also, the scanner may have internal state of its
- * own that does not get reset.  If so, the scanner may or may not provide
- * a routine to back its internal state up as well.  Beware!!
- *
- * Finally, this doesn't back the line number up.  If you're pushing
- * a token back and you care about having the correct line nubmer,
- * then you'll have to manually restore the line number to what it
- * was before you scanned the token that you're pushing back.
- *
- * i.e.
- *
- *     // First ensure that the scanner you're using doesn't
- *     // have internal state that will be screwed up if you
- *     // re-scan the current token!
- *
- *     oldline = ss->line;
- *     tok = scan_token(ss);
- *     if(tok == push_me_back) {
- *         scan_pushback(ss);
- *         ss->line = oldline;
- *     }
- *
- * Yes, it takes some effort to call this function safely.
- * But it can be worth it when you need it.
- */
-
-#define scan_pushback(ss) ((ss)->cursor = (ss)->token)
-
-
-/** Sets the current line number in the scanner to the given value.
- */
-
-#define scan_set_line(ss,n) (ss->line=(n));
-
-
-/** Increments the current line number by 1.
- */
-
-#define scan_inc_line(ss)   (ss->line++);
-
-
-/**
- * Prepares the scanner to scan a new token.
- * This should be called at the beginning of every scanproc.
- */
-
-#define scanner_enter(ss) ((ss)->token = (ss)->cursor)
-
-#endif
-

Copied: releases/0.94/re2c/scan.h (from rev 93, trunk/re2c/scan.h)

Deleted: releases/0.94/stscan.c
===================================================================
--- trunk/stscan.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/stscan.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,446 +0,0 @@
-/* Generated by re2c 0.9.10 on Mon Feb 27 18:07:08 2006 */
-
-/* stscan.re
- * Scott Bronson
- *
- * This file is covered by the MIT license.
- *
- * Scanner for status files files.
- * This file needs to be processed by re2c, http://re2c.org
- */
-
-#include "stscan.h"
-
-
-/* This scanner scans lines.  When it finds a line that begins
- * with a recognized token, it returns that token with the text
- * of the entire line.  Otherwise, it returns stGARBAGE.
- *
- * Note that this scanner only returns complete lines.  If the file
- * doesn't end with a newline, then the last line will be lost.
- * I think.
- */
-
-int stscan_start(scanstate *ss)
-{
-    scanner_enter(ss);
-    scan_inc_line(ss);
-
-
-
-{
-	YYCTYPE yych;
-	goto yy0;
-	++YYCURSOR;
-yy0:
-	if((YYLIMIT - YYCURSOR) < 8) YYFILL(8);
-	yych = *YYCURSOR;
-	switch(yych){
-	case 0x0A:	goto yy10;
-	case 'A':	goto yy7;
-	case 'C':	goto yy3;
-	case 'D':	goto yy6;
-	case 'P':	goto yy4;
-	case 'R':	goto yy5;
-	case 'S':	goto yy2;
-	default:	goto yy8;
-	}
-yy2:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy77;
-	default:	goto yy9;
-	}
-yy3:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy67;
-	default:	goto yy9;
-	}
-yy4:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy55;
-	default:	goto yy9;
-	}
-yy5:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'U':	goto yy44;
-	default:	goto yy9;
-	}
-yy6:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy23;
-	case 'O':	goto yy24;
-	default:	goto yy9;
-	}
-yy7:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'B':	goto yy12;
-	default:	goto yy9;
-	}
-yy8:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy9;
-yy9:	switch(yych){
-	case 0x0A:	goto yy10;
-	default:	goto yy8;
-	}
-yy10:	++YYCURSOR;
-	goto yy11;
-yy11:
-
-{ return stGARBAGE; }
-
-yy12:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'O':	goto yy13;
-	default:	goto yy9;
-	}
-yy13:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy14;
-	default:	goto yy9;
-	}
-yy14:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy15;
-	default:	goto yy9;
-	}
-yy15:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy16;
-	default:	goto yy9;
-	}
-yy16:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy17;
-	default:	goto yy9;
-	}
-yy17:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy18;
-yy18:	switch(yych){
-	case 0x09:	case ' ':	goto yy17;
-	case 0x0A:	goto yy10;
-	case ':':	goto yy19;
-	default:	goto yy8;
-	}
-yy19:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy20;
-yy20:	switch(yych){
-	case 0x0A:	goto yy21;
-	default:	goto yy19;
-	}
-yy21:	++YYCURSOR;
-	goto yy22;
-yy22:
-
-{ return stABORTED; }
-
-yy23:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'S':	goto yy33;
-	default:	goto yy9;
-	}
-yy24:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy25;
-	default:	goto yy9;
-	}
-yy25:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy26;
-	default:	goto yy9;
-	}
-yy26:	yych = *++YYCURSOR;
-	switch(yych){
-	case 0x09:	case ' ':	goto yy29;
-	case 0x0A:	goto yy27;
-	default:	goto yy8;
-	}
-yy27:	++YYCURSOR;
-	goto yy28;
-yy28:
-
-{ return stDONE; }
-
-yy29:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy30;
-yy30:	switch(yych){
-	case 0x09:	case ' ':	goto yy29;
-	case 0x0A:	goto yy27;
-	default:	goto yy31;
-	}
-yy31:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy32;
-yy32:	switch(yych){
-	case 0x0A:	goto yy27;
-	default:	goto yy31;
-	}
-yy33:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy34;
-	default:	goto yy9;
-	}
-yy34:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'B':	goto yy35;
-	default:	goto yy9;
-	}
-yy35:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'L':	goto yy36;
-	default:	goto yy9;
-	}
-yy36:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy37;
-	default:	goto yy9;
-	}
-yy37:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'D':	goto yy38;
-	default:	goto yy9;
-	}
-yy38:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy39;
-yy39:	switch(yych){
-	case 0x09:	case ' ':	goto yy38;
-	case 0x0A:	goto yy10;
-	case ':':	goto yy40;
-	default:	goto yy8;
-	}
-yy40:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy41;
-yy41:	switch(yych){
-	case 0x0A:	goto yy42;
-	default:	goto yy40;
-	}
-yy42:	++YYCURSOR;
-	goto yy43;
-yy43:
-
-{ return stDISABLED; }
-
-yy44:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy45;
-	default:	goto yy9;
-	}
-yy45:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy46;
-	default:	goto yy9;
-	}
-yy46:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy47;
-	default:	goto yy9;
-	}
-yy47:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy48;
-	default:	goto yy9;
-	}
-yy48:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'G':	goto yy49;
-	default:	goto yy9;
-	}
-yy49:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy50;
-yy50:	switch(yych){
-	case 0x09:	case ' ':	goto yy49;
-	case 0x0A:	goto yy10;
-	case ':':	goto yy51;
-	default:	goto yy8;
-	}
-yy51:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy52;
-yy52:	switch(yych){
-	case 0x0A:	goto yy53;
-	default:	goto yy51;
-	}
-yy53:	++YYCURSOR;
-	goto yy54;
-yy54:
-
-{ return stRUNNING; }
-
-yy55:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy56;
-	default:	goto yy9;
-	}
-yy56:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'P':	goto yy57;
-	default:	goto yy9;
-	}
-yy57:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy58;
-	default:	goto yy9;
-	}
-yy58:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy59;
-	default:	goto yy9;
-	}
-yy59:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'E':	goto yy60;
-	default:	goto yy9;
-	}
-yy60:	yych = *++YYCURSOR;
-	switch(yych){
-	case 0x09:	case ' ':	goto yy63;
-	case 0x0A:	goto yy61;
-	default:	goto yy8;
-	}
-yy61:	++YYCURSOR;
-	goto yy62;
-yy62:
-
-{ return stPREPARE; }
-
-yy63:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy64;
-yy64:	switch(yych){
-	case 0x09:	case ' ':	goto yy63;
-	case 0x0A:	goto yy61;
-	default:	goto yy65;
-	}
-yy65:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy66;
-yy66:	switch(yych){
-	case 0x0A:	goto yy61;
-	default:	goto yy65;
-	}
-yy67:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'N':	goto yy68;
-	default:	goto yy9;
-	}
-yy68:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'F':	goto yy69;
-	default:	goto yy9;
-	}
-yy69:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'I':	goto yy70;
-	default:	goto yy9;
-	}
-yy70:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'G':	goto yy71;
-	default:	goto yy9;
-	}
-yy71:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy72;
-yy72:	switch(yych){
-	case 0x09:	case ' ':	goto yy71;
-	case 0x0A:	goto yy10;
-	case ':':	goto yy73;
-	default:	goto yy8;
-	}
-yy73:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy74;
-yy74:	switch(yych){
-	case 0x0A:	goto yy75;
-	default:	goto yy73;
-	}
-yy75:	++YYCURSOR;
-	goto yy76;
-yy76:
-
-{ return stCONFIG; }
-
-yy77:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'A':	goto yy78;
-	default:	goto yy9;
-	}
-yy78:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'R':	goto yy79;
-	default:	goto yy9;
-	}
-yy79:	yych = *++YYCURSOR;
-	switch(yych){
-	case 'T':	goto yy80;
-	default:	goto yy9;
-	}
-yy80:	yych = *++YYCURSOR;
-	switch(yych){
-	case 0x09:	case ' ':	goto yy83;
-	case 0x0A:	goto yy81;
-	default:	goto yy8;
-	}
-yy81:	++YYCURSOR;
-	goto yy82;
-yy82:
-
-{ return stSTART; }
-
-yy83:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy84;
-yy84:	switch(yych){
-	case 0x09:	case ' ':	goto yy83;
-	case 0x0A:	goto yy81;
-	default:	goto yy85;
-	}
-yy85:	++YYCURSOR;
-	if(YYLIMIT == YYCURSOR) YYFILL(1);
-	yych = *YYCURSOR;
-	goto yy86;
-yy86:	switch(yych){
-	case 0x0A:	goto yy81;
-	default:	goto yy85;
-	}
-}
-
-
-}
-
-
-/** Prepares the given scanner to scan a status file.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* stscan_attach(scanstate *ss)
-{
-    if(ss) {
-        ss->state = stscan_start;
-    }
-
-    return ss;
-}
-

Copied: releases/0.94/stscan.c (from rev 89, trunk/stscan.c)

Deleted: releases/0.94/template.sh
===================================================================
--- trunk/template.sh	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/template.sh	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,38 +0,0 @@
-echo START >&%(STATUSFD)
-
-ABORT ()  { echo "ABORTED: $*" >&%(STATUSFD); exit 0; }
-ABORT: () { ABORT $*; }
-
-ATEXIT ()  { echo "ATEXIT: $*" >&%(STATUSFD); }
-ATEXIT: () { ATEXIT $*; }
-
-DISABLED  () { echo "DISABLED: $*" >&%(STATUSFD); exit 0; }
-DISABLED: () { DISABLED $*; }
-DISABLE   () { DISABLED $*; }
-DISABLE:  () { DISABLED $*; }
-
-TESTDIR='%(TESTDIR)'
-TESTFILE='%(TESTFILE)'
-
-%(CONFIG_FILES)
-
-echo PREPARE >&%(STATUSFD)
-
-STDOUT () { exit 0; }
-STDOUT: () { exit 0; }
-STDERR () { exit 0; }
-STDERR: () { exit 0; }
-RESULT () { exit 0; }
-RESULT: () { exit 0; }
-MODIFY () { exit 0; }
-MODIFY: () { exit 0; }
-
-echo 'RUNNING: %(TESTFILE)' >&%(STATUSFD)
-MYDIR='%(TESTDIR)'
-MYFILE='%(TESTFILE)'
-exec >&%(OUTFD) 2>&%(ERRFD)
-exec %(OUTFD)>&-
-exec %(ERRFD)>&-
-%(TESTEXEC)
-
-echo DONE >&%(STATUSFD)

Copied: releases/0.94/template.sh (from rev 100, trunk/template.sh)

Copied: releases/0.94/test/00-cmdline/10-CfgDir.test (from rev 99, trunk/test/00-cmdline/10-CfgDir.test)

Copied: releases/0.94/test/00-cmdline/11-CfgMissing.test (from rev 99, trunk/test/00-cmdline/11-CfgMissing.test)

Copied: releases/0.94/test/00-cmdline/12-CfgEmpty.test (from rev 99, trunk/test/00-cmdline/12-CfgEmpty.test)

Copied: releases/0.94/test/01-testfile/02-StdOutNK.test (from rev 99, trunk/test/01-testfile/02-StdOutNK.test)

Copied: releases/0.94/test/01-testfile/03-StdErrNK.test (from rev 99, trunk/test/01-testfile/03-StdErrNK.test)

Deleted: releases/0.94/test/01-testfile/08-GarbageInStdout.test
===================================================================
--- trunk/test/01-testfile/08-GarbageInStdout.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/01-testfile/08-GarbageInStdout.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,16 +0,0 @@
-# Scott Bronson
-# 26 Feb 2006
-#
-# Ensures that we recognize when the stdout clause contains garbage.
-
-tmtest -q - <<-EOL
-    echo crapola
-	STDOUT: crapola
-    crapola
-EOL
-STDERR:
-(STDIN) line 2: unknown arguments "crapola"
-STDOUT:
-FAIL (STDIN)                   O..  stdout differed
-
-1 test run, 0 successes, 1 failure.

Copied: releases/0.94/test/01-testfile/08-GarbageInStdout.test (from rev 99, trunk/test/01-testfile/08-GarbageInStdout.test)

Deleted: releases/0.94/test/01-testfile/10-DumpScript.test
===================================================================
--- trunk/test/01-testfile/10-DumpScript.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/01-testfile/10-DumpScript.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,59 +0,0 @@
-# Ensures that the dumpscript is what we expect.
-# This is just so we don't surprise ourselves...  Any time you modify
-# template.sh, you should expect test to fail.
-
-tmtest $args --dump-script - <<-EOL
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 2
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 3
-THE-SCRIPT THE-SCRIPT THE-SCRIPT 4
-EOL
-
-MODIFY:
-  s/DATE='.*'/Date='BLAH BLAH'/
-  s/^(.)/	$1/
-
-STDOUT:
-	echo START >&7
-
-	ABORT ()  { echo "ABORTED: $*" >&7; exit 0; }
-	ABORT: () { ABORT $*; }
-
-	ATEXIT ()  { echo "ATEXIT: $*" >&7; }
-	ATEXIT: () { ATEXIT $*; }
-
-	DISABLED  () { echo "DISABLED: $*" >&7; exit 0; }
-	DISABLED: () { DISABLED $*; }
-	DISABLE   () { DISABLED $*; }
-	DISABLE:  () { DISABLED $*; }
-
-	TESTDIR='/tmp'
-	TESTFILE='/tmp/-'
-
-
-
-	echo PREPARE >&7
-
-	STDOUT () { exit 0; }
-	STDOUT: () { exit 0; }
-	STDERR () { exit 0; }
-	STDERR: () { exit 0; }
-	RESULT () { exit 0; }
-	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
-
-	echo 'RUNNING: /tmp/-' >&7
-	MYDIR='/tmp'
-	MYFILE='/tmp/-'
-	exec >&3 2>&5
-	exec 3>&-
-	exec 5>&-
-	LINENO=0
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 2
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 3
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 4
-
-
-	echo DONE >&7

Copied: releases/0.94/test/01-testfile/10-DumpScript.test (from rev 100, trunk/test/01-testfile/10-DumpScript.test)

Copied: releases/0.94/test/01-testfile/11-InnerConfig.test (from rev 99, trunk/test/01-testfile/11-InnerConfig.test)

Copied: releases/0.94/test/01-testfile/20-TestVars.test (from rev 99, trunk/test/01-testfile/20-TestVars.test)

Copied: releases/0.94/test/01-testfile/21-TestVarsABS.test (from rev 99, trunk/test/01-testfile/21-TestVarsABS.test)

Copied: releases/0.94/test/01-testfile/22-TestVarsRel.test (from rev 99, trunk/test/01-testfile/22-TestVarsRel.test)

Deleted: releases/0.94/test/02-running/21-QuoteFile.test
===================================================================
--- trunk/test/02-running/21-QuoteFile.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/02-running/21-QuoteFile.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,31 +0,0 @@
-# Ensures that a test disabled by a config file doesn't run.
-
-MKDIR dir
-cd "$dir"
-
-cat > "vl'hurg.test" <<-EOs
-	echo hi
-	STDOUT:
-	hi
-EOs
-
-cat > '12".test' <<-EOs
-	echo hi
-	STDOUT:
-	hi
-EOs
-
-tmtest $CFG -q
-rm "vl'hurg.test" '12".test'
-
-
-MODIFY:
-  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
-STDOUT:
-
-Processing .
-
-0 tests run, 0 successes, 0 failures.
-STDERR:
-12".test was skipped because its file name contains a quote character.
-vl'hurg.test was skipped because its file name contains a quote character.

Copied: releases/0.94/test/02-running/21-QuoteFile.test (from rev 99, trunk/test/02-running/21-QuoteFile.test)

Copied: releases/0.94/test/02-running/22-Signal.test (from rev 92, trunk/test/02-running/22-Signal.test)

Copied: releases/0.94/test/02-running/40-Replace.test (from rev 99, trunk/test/02-running/40-Replace.test)

Copied: releases/0.94/test/02-running/41-Indent.test (from rev 99, trunk/test/02-running/41-Indent.test)

Copied: releases/0.94/test/03-results/01-YstderrOut.test (from rev 99, trunk/test/03-results/01-YstderrOut.test)

Copied: releases/0.94/test/03-results/01-YstdoutOut.test (from rev 99, trunk/test/03-results/01-YstdoutOut.test)

Copied: releases/0.94/test/03-results/14-NoNLWarn.test (from rev 99, trunk/test/03-results/14-NoNLWarn.test)

Copied: releases/0.94/test/03-results/15-EmptyWithErr.test (from rev 98, trunk/test/03-results/15-EmptyWithErr.test)

Copied: releases/0.94/test/03-results/15-EmptyWithOut.test (from rev 98, trunk/test/03-results/15-EmptyWithOut.test)

Copied: releases/0.94/test/03-results/16-EmptyWithErrNoNL.test (from rev 98, trunk/test/03-results/16-EmptyWithErrNoNL.test)

Copied: releases/0.94/test/03-results/16-EmptyWithOutNoNL.test (from rev 98, trunk/test/03-results/16-EmptyWithOutNoNL.test)

Copied: releases/0.94/test/03-results/17-NoStderr.test (from rev 99, trunk/test/03-results/17-NoStderr.test)

Copied: releases/0.94/test/03-results/18-NoNLWarnOut.test (from rev 99, trunk/test/03-results/18-NoNLWarnOut.test)

Copied: releases/0.94/test/03-results/30-Binary.test (from rev 95, trunk/test/03-results/30-Binary.test)

Copied: releases/0.94/test/03-results/31-BinaryFail.test (from rev 95, trunk/test/03-results/31-BinaryFail.test)

Copied: releases/0.94/test/03-results/32-BinaryLarge.test (from rev 95, trunk/test/03-results/32-BinaryLarge.test)

Copied: releases/0.94/test/03-results/33-BinaryHuge.test (from rev 99, trunk/test/03-results/33-BinaryHuge.test)

Deleted: releases/0.94/test/04-diff/01-Diff.test
===================================================================
--- trunk/test/04-diff/01-Diff.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/01-Diff.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,30 +0,0 @@
-# Diff
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d
-
-# updated for 2.0 on 27 Jan 2005
-
-
-tmtest -d - <<-EOL
-    echo "right output"
-    STDOUT:
-    wrong output
-EOL
-
-
-MODIFY:
-    s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-    s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,5 @@
-     echo "right output"
-     STDOUT:
-     wrong output
-+STDOUT:
-+right output

Copied: releases/0.94/test/04-diff/01-Diff.test (from rev 99, trunk/test/04-diff/01-Diff.test)

Deleted: releases/0.94/test/04-diff/02-MultiDiff.test
===================================================================
--- trunk/test/04-diff/02-MultiDiff.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/02-MultiDiff.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,42 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests that diff works on multiple files (tmtest -d file1 file2)
-# updated for 2.0 on 29 Jan 2005
-
-
-
-MKFILE t1 <<-EOF
-	echo "test 1 right output"
-	STDOUT:
-	test 1 wrong output
-EOF
-
-MKFILE t2 <<-EOF
-	echo "test 2 right output"
-	STDOUT:
-	test 2 wrong output
-EOF
-
-tmtest --all-files -d "$t1" "$t2"
-
-
-MODIFY:
-  s/^\-\-\-.*\/tmp\/tmtest.*/--- \/tmp\/testfile DATE TIME TZ/,
-  s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-STDOUT:
---- /tmp/testfile DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo "test 1 right output"
- STDOUT:
--test 1 wrong output
-+test 1 right output
---- /tmp/testfile DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo "test 2 right output"
- STDOUT:
--test 2 wrong output
-+test 2 right output

Copied: releases/0.94/test/04-diff/02-MultiDiff.test (from rev 99, trunk/test/04-diff/02-MultiDiff.test)

Deleted: releases/0.94/test/04-diff/05-AbortDiff.test
===================================================================
--- trunk/test/04-diff/05-AbortDiff.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/05-AbortDiff.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,30 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a diff is aborted.
-
-
-
-tmtest -d - <<-EOL
-	ABORT
-	echo "right output"
-	STDOUT:
-	right output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,4 +1,2 @@
- ABORT
- echo "right output"
--STDOUT:
--right output
-STDERR:
-ERROR Test was aborted

Copied: releases/0.94/test/04-diff/05-AbortDiff.test (from rev 99, trunk/test/04-diff/05-AbortDiff.test)

Deleted: releases/0.94/test/04-diff/09-MultiLevelDiff.test
===================================================================
--- trunk/test/04-diff/09-MultiLevelDiff.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/09-MultiLevelDiff.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,101 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d | patch -p0 in a hierarchy
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-# tt/t.test
-# tt/one/t.test
-# tt/two/t1.test
-# tt/two/t2.test
-# tt/two/one/t.test
-
-
-. "$MYDIR/indent.sh"
-
-
-MKDIR tt
-cd "$tt" || ABORT "Could not cd to $tt"
-
-cat > t.test <<-EOL
-	echo "right output1"
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir one
-cat > one/t.test <<-EOL
-	echo "right output2"
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two
-cat > two/t1.test <<-EOL
-	echo "right output3"
-	STDOUT:
-	wrong output
-EOL
-
-cat > two/t2.test <<-EOL
-	echo "right output4"
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two/one
-cat > two/one/t.test <<-EOL
-	echo "right output5"
-	STDOUT:
-	wrong output
-EOL
-
-
-tmtest --all-files -d
-
-rm -rf t.test one two
-
-
-MODIFY:
-  s/^\-\-\- .*/--- TESTFILE DATE TIME TZ/,
-  s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-STDOUT:
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo "right output1"
- STDOUT:
--wrong output
-+right output1
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo "right output2"
- STDOUT:
--wrong output
-+right output2
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo "right output3"
- STDOUT:
--wrong output
-+right output3
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo "right output4"
- STDOUT:
--wrong output
-+right output4
---- TESTFILE DATE TIME TZ
-+++ - DATE TIME TZ
-@@ -1,3 +1,3 @@
- echo "right output5"
- STDOUT:
--wrong output
-+right output5

Copied: releases/0.94/test/04-diff/09-MultiLevelDiff.test (from rev 89, trunk/test/04-diff/09-MultiLevelDiff.test)

Deleted: releases/0.94/test/04-diff/10-Patch.test
===================================================================
--- trunk/test/04-diff/10-Patch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/10-Patch.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,34 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d | patch
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-. "$MYDIR/indent.sh"
-
-
-MKFILE tt <<-EOL
-	echo "right output"
-	STDOUT:
-	wrong output
-EOL
-
-
-# This is a little exotic...  Patch needs the CWD to be the directory
-# containing the file to patch.  "dirname $(tt.test)" gives that dir.
-
-tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch)
-echo "And the patched file:"
-echo
-INDENT < "$tt"
-
-MODIFY:
-  s/^patching .*/patching FILE/
-
-STDOUT:
-patching FILE
-And the patched file:
-
-	echo "right output"
-	STDOUT:
-	right output

Copied: releases/0.94/test/04-diff/10-Patch.test (from rev 89, trunk/test/04-diff/10-Patch.test)

Deleted: releases/0.94/test/04-diff/11-MultiPatch.test
===================================================================
--- trunk/test/04-diff/11-MultiPatch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/11-MultiPatch.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,57 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d | patch
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-. "$MYDIR/indent.sh"
-
-
-MKFILE tt1 <<-EOL
-	echo "right output1"
-	STDOUT:
-	wrong output
-EOL
-
-MKFILE tt2 <<-EOL
-	echo "right output2"
-	STDOUT:
-	wrong output
-EOL
-
-MKFILE tt3 <<-EOL
-	echo "right output3"
-	STDOUT:
-	wrong output
-EOL
-
-
-# All tt* files must be in the same directory.
-
-tmtest --all-files -d "$tt1" "$tt2" "$tt3" | (cd `dirname "$tt1"` && patch)
-echo
-INDENT < "$tt1"
-echo
-INDENT < "$tt2"
-echo
-INDENT < "$tt3"
-
-MODIFY:
-  s/^patching .*/patching FILE/
-
-STDOUT:
-patching FILE
-patching FILE
-patching FILE
-
-	echo "right output1"
-	STDOUT:
-	right output1
-
-	echo "right output2"
-	STDOUT:
-	right output2
-
-	echo "right output3"
-	STDOUT:
-	right output3

Copied: releases/0.94/test/04-diff/11-MultiPatch.test (from rev 89, trunk/test/04-diff/11-MultiPatch.test)

Deleted: releases/0.94/test/04-diff/12-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/12-MultiLevelPatch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/12-MultiLevelPatch.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,100 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# tests tmtest -d | patch -p0 in a hierarchy
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-# tt/t.test
-# tt/one/t.test
-# tt/two/t1.test
-# tt/two/t2.test
-# tt/two/one/t.test
-
-
-. "$MYDIR/indent.sh"
-
-
-MKDIR tt
-cd "$tt" || ABORT "Could not cd to $tt"
-
-cat > t.test <<-EOL
-	echo "right output1"
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir one
-cat > one/t.test <<-EOL
-	echo "right output2"
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two
-cat > two/t1.test <<-EOL
-	echo "right output3"
-	STDOUT:
-	wrong output
-EOL
-
-cat > two/t2.test <<-EOL
-	echo "right output4"
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two/one
-cat > two/one/t.test <<-EOL
-	echo "right output5"
-	STDOUT:
-	wrong output
-EOL
-
-
-tmtest --all-files -d | patch -p0
-echo
-INDENT < t.test
-echo
-INDENT < one/t.test
-echo
-INDENT < two/t1.test
-echo
-INDENT < two/t2.test
-echo
-INDENT < two/one/t.test
-
-rm -rf t.test one two
-
-
-MODIFY:
-  s/^patching .*/patching FILE/
-
-STDOUT:
-patching FILE
-patching FILE
-patching FILE
-patching FILE
-patching FILE
-
-	echo "right output1"
-	STDOUT:
-	right output1
-
-	echo "right output2"
-	STDOUT:
-	right output2
-
-	echo "right output3"
-	STDOUT:
-	right output3
-
-	echo "right output4"
-	STDOUT:
-	right output4
-
-	echo "right output5"
-	STDOUT:
-	right output5

Copied: releases/0.94/test/04-diff/12-MultiLevelPatch.test (from rev 89, trunk/test/04-diff/12-MultiLevelPatch.test)

Deleted: releases/0.94/test/04-diff/13-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/13-MultiLevelPatch.test	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/13-MultiLevelPatch.test	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,101 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Same as 12-MultiLevelPatch.test except that it tests ..
-# Updated for tmtest 2.0 on 29 Jan 2005
-
-# tt/t.test
-# tt/one/t.test
-# tt/two/t1.test
-# tt/two/t2.test
-# tt/two/one/t.test
-
-
-. "$MYDIR/indent.sh"
-
-
-MKDIR tt
-cd "$tt" || ABORT "Could not cd to $tt"
-
-cat > t.test <<-EOL
-	echo "right output1"
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir one
-cat > one/t.test <<-EOL
-	echo "right output2"
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two
-cat > two/t1.test <<-EOL
-	echo "right output3"
-	STDOUT:
-	wrong output
-EOL
-
-cat > two/t2.test <<-EOL
-	echo "right output4"
-	STDOUT:
-	wrong output
-EOL
-
-
-mkdir two/one
-cat > two/one/t.test <<-EOL
-	echo "right output5"
-	STDOUT:
-	wrong output
-EOL
-
-cd two
-
-tmtest --all-files -d .. | patch -p0
-echo
-INDENT < ../t.test
-echo
-INDENT < ../one/t.test
-echo
-INDENT < t1.test
-echo
-INDENT < t2.test
-echo
-INDENT < one/t.test
-
-rm -rf ../t.test ../one ../two
-
-
-MODIFY:
-  s/^patching .*/patching FILE/
-
-STDOUT:
-patching FILE
-patching FILE
-patching FILE
-patching FILE
-patching FILE
-
-	echo "right output1"
-	STDOUT:
-	right output1
-
-	echo "right output2"
-	STDOUT:
-	right output2
-
-	echo "right output3"
-	STDOUT:
-	right output3
-
-	echo "right output4"
-	STDOUT:
-	right output4
-
-	echo "right output5"
-	STDOUT:
-	right output5

Copied: releases/0.94/test/04-diff/13-MultiLevelPatch.test (from rev 89, trunk/test/04-diff/13-MultiLevelPatch.test)

Copied: releases/0.94/test/04-diff/18-NeedNLWarn.test (from rev 99, trunk/test/04-diff/18-NeedNLWarn.test)

Copied: releases/0.94/test/04-diff/20-DiffNoNL.test (from rev 90, trunk/test/04-diff/20-DiffNoNL.test)

Copied: releases/0.94/test/04-diff/21-PatchNoNL.test (from rev 99, trunk/test/04-diff/21-PatchNoNL.test)

Copied: releases/0.94/test/04-diff/22-PatchNoNL2.test (from rev 99, trunk/test/04-diff/22-PatchNoNL2.test)

Copied: releases/0.94/test/04-diff/23-PatchNoNL3.test (from rev 99, trunk/test/04-diff/23-PatchNoNL3.test)

Deleted: releases/0.94/test/04-diff/indent.sh
===================================================================
--- trunk/test/04-diff/indent.sh	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/04-diff/indent.sh	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,9 +0,0 @@
-# This function indents each line of its stdin with a tab.
-
-INDENT ()
-{
-	while read LINE; do
-		echo $'\t'"$LINE"
-	done
-}
-

Copied: releases/0.94/test/04-diff/tmtest.conf (from rev 90, trunk/test/04-diff/tmtest.conf)

Deleted: releases/0.94/test/README
===================================================================
--- trunk/test/README	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/README	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,30 +0,0 @@
-NOTE: If you are looking for examples of testfiles, this is NOT the
-directory for you!  Due to the recursive nature of tmtest testing
-itself, many of these testfiles are very difficult to understand.
-
-See the examples directory instead.
-
-
-These are the test subcategories:
-
-00-cmdline: tests parsing command-line arguments
-    Mostly tests illegal command-line arguments.
-
-01-testfile: tests the parsing of test files.
-    Mostly tests illegal testfiles and ensures proper errors are printed.
-
-02-running: tests running the actual tests
-    Ensures that the test environment is set up properly.
-    For instance, checks that disabled tests are not run, the tmlib
-    calls are performed properly, etc.
-
-03-results: tests the results
-    Ensures that we compare the test results properly.
-    For instance, verifies that we handle results that don't
-    end in newlines, binary characters, etc. properly.
-
-04-diff: ensures diffing and patching works
-
-09-docs: tests that appear in our documentation.
-    This ensures that tmtest behaves exactly like our docs say it will.
-

Copied: releases/0.94/test/README (from rev 91, trunk/test/README)

Deleted: releases/0.94/test/tmtest.sub.conf
===================================================================
--- trunk/test/tmtest.sub.conf	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test/tmtest.sub.conf	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,18 +0,0 @@
-# tmtest.sub.conf
-# Scott Bronson
-# 15 Dec 2005
-
-
-# When you run "make test", this is the only config file read by the
-# testfiles.  This ensures that the tests are not succeeding due some local
-# config setting, and that the correct tmlib routines are being used.
-
-
-# All tests are written to be pedantic.  We want them to exit at the
-# first sign of trouble and have the result code reported in RESULT.
-set -e
-
-
-# Include the standard tmtest functions
-. ../tmlib.sh
-

Copied: releases/0.94/test/tmtest.sub.conf (from rev 99, trunk/test/tmtest.sub.conf)

Deleted: releases/0.94/test.c
===================================================================
--- trunk/test.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,1159 +0,0 @@
-/* test.c
- * 30 Dec 2004
- * Copyright (C) 2004 Scott Bronson
- * 
- * Contains the routines to check/diff/etc test output.
- *
- * This file is covered by the MIT license.
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <errno.h>
-
-// to get PATH_MAX:
-#include <dirent.h>
-
-#include "re2c/read-fd.h"
-
-#include "test.h"
-#include "stscan.h"
-#include "tfscan.h"
-#include "compare.h"
-#include "rusage.h"
-
-
-// This is the maximum line length for the eachline substitution.
-// Lines longer than this will be parsed as 2 separate lines.
-#define MAX_LINE_LENGTH BUFSIZ
-
-// utility function so you can say i.e. write_strconst(fd, "/");
-#define write_strconst(fd, str) write((fd), (str), sizeof(str)-1)
-
-static int test_runs = 0;
-static int test_successes = 0;
-static int test_failures = 0;
-
-
-const char *convert_testfile_name(const char *fn)
-{
-    if(fn[0] == '-' && fn[1] == '\0') {
-        return "(STDIN)";
-    }
-
-	return fn;
-}
-
-
-const char* get_testfile_name(struct test *test)
-{
-    return convert_testfile_name(test->testfilename);
-}
-
-
-/** Tells if the given file descriptor has a nonzero length.
- * NOTE: it changes the file offset to the end of the file.
- *
- * Returns nonzero if file has data, zero if it doesn't.
- * Actually, it just returns the file's length.
- */
-
-int fd_has_data(int fd)
-{
-    off_t pos = lseek(fd, 0, SEEK_END);
-    if(pos < 0) {
-        perror("lseek in fd_has_data");
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    return pos;
-}
-
-
-/** Tries to find the argument in the status line given.
- *
- * @return  nonzero if the argument could be found, zero if not.
- * If the argument was found, then incp and ince are updated to
- * point to its beginning and end.
- */
-
-static int locate_status_arg(const char **incp, const char **ince)
-{
-	const char *cp = *incp;
-	const char *ce = *ince;
-
-	// trim the newline from the end
-	if(ce[-1] == '\n') ce--;
-
-	// skip to colon separating name from arg
-	while(*cp != ':' && *cp != '\n' && cp < ce) cp++;
-	if(*cp == ':') {
-		cp++;					// skip the colon
-		if(*cp == ' ') cp++;	// skip the optional space after it
-		if(cp < ce) {
-			*incp = cp;
-			*ince = ce;
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-
-static char* dup_status_arg(const char *cp, const char *ce)
-{
-	char *ret = NULL;
-
-	if(locate_status_arg(&cp, &ce)) {
-		ret = malloc(ce - cp + 1);
-		if(ret) {
-			memcpy(ret, cp, ce-cp);
-			// replace the NL on the end with the null terminator.
-			ret[ce-cp] = '\0';
-		}
-	}
-
-	return ret;
-}
-
-
-static int copy_status_arg(const char *cp, const char *ce, char *buf, int size)
-{
-	if(locate_status_arg(&cp, &ce)) {
-		int len = ce - cp;
-		if(size-1 < len) len = size-1;
-		memcpy(buf, cp, len);
-		buf[len] = '\0';
-		return 1;
-	}
-
-	return 0;
-}
-
-
-/** Looks through the status file and stores the items of interest
- * in the test structure.
- */
-
-void scan_status_file(struct test *test)
-{
-	char lastfile[PATH_MAX];
-	int lastfile_good = 0;
-    char buf[BUFSIZ];
-    scanstate ss;
-    int tok;
-	int state = 0;
-
-    // first rewind the status file
-    if(lseek(test->statusfd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "read_file lseek for status file: %s\n", strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // then create our scanner
-    scanstate_init(&ss, buf, sizeof(buf));
-    readfd_attach(&ss, test->statusfd);
-    stscan_attach(&ss);
-
-    // now, if we see the token "CBRUNNING" in the token stream,
-    // it means that we attempted to start the test.  If not,
-    // then the test bailed early.
-    do {
-        tok = scan_token(&ss);
-
-		// look for errors...
-        if(tok < 0) {
-            fprintf(stderr, "Error %d pulling status tokens: %s\n", 
-                    tok, strerror(errno));
-            exit(10);
-        } else if(tok == stGARBAGE) {
-			fprintf(stderr, "Garbage on line %d in the status file: '%.*s'\n",
-					ss.line, token_length(&ss)-1, token_start(&ss));
-		} else {
-			state = tok;
-		}
-
-		switch(tok) {
-			case stSTART:
-				// nothing to do
-				break;
-
-			case stCONFIG:
-				if(test->status == test_pending) {
-					test->num_config_files += 1;
-					if(copy_status_arg(token_start(&ss), token_end(&ss), lastfile, sizeof(lastfile))) {
-						lastfile_good = 1;
-					} else {
-						fprintf(stderr, "CONFIG needs arg on line %d of the status file: '%.*s'\n",
-								ss.line, token_length(&ss)-1, token_start(&ss));
-					}
-				} else {
-					fprintf(stderr, "CONFIG but status (%d) wasn't pending on line %d of the status file: '%.*s'\n",
-							test->status, ss.line, token_length(&ss)-1, token_start(&ss));
-				}
-				break;
-
-			case stPREPARE:
-				// nothing to do
-				break;
-
-			case stRUNNING:
-				if(test->status == test_pending) {
-					test->status = test_was_started;
-					if(copy_status_arg(token_start(&ss), token_end(&ss), lastfile, sizeof(lastfile))) {
-						lastfile_good = 1;
-					} else {
-						fprintf(stderr, "RUNNING needs arg on line %d of the status file: '%.*s'\n",
-								ss.line, token_length(&ss)-1, token_start(&ss));
-					}
-				} else {
-					fprintf(stderr, "RUNNING but status (%d) wasn't pending on line %d of the status file: '%.*s'\n",
-							test->status, ss.line, token_length(&ss)-1, token_start(&ss));
-				}
-				break;
-
-			case stDONE:
-				if(test->status == test_was_started) {
-					test->status = test_was_completed;
-				} else {
-					fprintf(stderr, "DONE but status (%d) wasn't RUNNING on line %d of the status file: '%.*s'\n",
-							test->status, ss.line, token_length(&ss)-1, token_start(&ss));
-				}
-				break;
-			
-			case stABORTED:
-				test->status = (test->status >= test_was_started ? test_was_aborted : config_was_aborted);
-				test->status_reason = dup_status_arg(token_start(&ss), token_end(&ss));
-				break;
-
-			case stDISABLED:
-				test->status = (test->status >= test_was_started ? test_was_disabled : config_was_disabled);
-				test->status_reason = dup_status_arg(token_start(&ss), token_end(&ss));
-				break;
-
-			default:
-				fprintf(stderr, "Unknown token (%d) on line %d of the status file: '%.*s'\n",
-						tok, ss.line, token_length(&ss)-1, token_start(&ss));
-		}
-    } while(!scan_finished(&ss));
-
-	if(lastfile_good) {
-		test->last_file_processed = strdup(lastfile);
-	}
-}
-
-
-/**
- * Prints the command section of the test suitable for how the test
- * is being run.
- *
- * If the user is just running the test, nothing is printed.  If the
- * user is diffing or dumping the test, however, the modified command
- * section needs to be printed to the appropriate command.
- *
- * @param test The test being run.
- * @param tok The type of data this is (from tfscan.h).  If 0 then 
- *            this is the EOF and this routine won't be called anymore.
- * @param ptr The data to write.  If tok==0 then ptr is undefined.
- * @param len The amount of data to write.  If tok==0 then len==0.
- *
- * Hm, a year later it ooks like rewriting is a feature that will
- * never need to be implemented...?
- */
-
-void rewrite_command_section(struct test *test, int tok, const char *ptr, int len)
-{
-    // only dump if we're asked to.
-    if(test->rewritefd < 0) {
-        return;
-    }
-
-    // for now we don't modify it at all.
-    write(test->rewritefd, ptr, len);
-}
-
-
-/** Copies the command section of the test to the given fileptr and
- * also supplies it to the dump_command_section() routine.
- *
- * If you don't want to dump to a fileptr (i.e. if you're running
- * the test from a file) just pass NULL for fp.
- *
- * This routine is a whole lot like scan_sections except that it stops
- * at the end of the command section.  It leaves the result sections
- * on the stream to be parsed later.
- */
-
-void test_command_copy(struct test *test, FILE *fp)
-{
-    int oldline;
-
-    do {
-        oldline = test->testfile.line;
-        int tokno = scan_token(&test->testfile);
-        if(tokno < 0) {
-            fprintf(stderr, "Error %d pulling status tokens: %s\n", 
-                    tokno, strerror(errno));
-            exit(10);
-        } else if(tokno == 0) {
-			// if the test file is totally empty.
-			break;
-		}
-
-
-        if(tokno != exCOMMAND) {
-            // now we attempt to push the token back on the stream...
-            scan_pushback(&test->testfile);
-            test->testfile.line = oldline;
-            // The pushback reset the stream, and I restored the line number,
-            // but the scanner is still in a different state.
-            // We need it to be in a COMMAND state, so that when it feeds
-            // the new SECTION token it marks it NEW.  Reattaching resets
-            // the state to a command state, so we can just do that.
-            tfscan_attach(&test->testfile);
-            // Now we're done dumping the command and the scanner
-            // is poised to return the correct section start to the
-            // next client.
-            break;
-        }
-
-        // print the modified data to the output stream.
-        rewrite_command_section(test, tokno, token_start(&test->testfile), token_length(&test->testfile));
-
-        if(fp) {
-            // print the unmodified data to the command script.
-            fwrite(token_start(&test->testfile), token_length(&test->testfile), 1, fp);
-        }
-    } while(!scan_finished(&test->testfile));
-
-    rewrite_command_section(test, 0, NULL, 0);
-}
-
-
-/** Prepares a test section for comparison against actual results.
- *
- * The comparison is handled by compare.c/h.  We just need to set
- * it up.
- */
-
-void compare_section_start(scanstate *cmpscan, int fd, pcrs_job *joblist,
-		matchval *mv, const char *filename, const char *sectionname, int nonl)
-{
-    assert(!compare_in_progress(cmpscan));
-
-    // associates the scanstate with the fd and prepares to compare.
-    if(*mv != match_unknown) {
-        fprintf(stderr, "'%s' has multiple %s sections!\n",
-                filename, sectionname);
-        exit(10);
-    }
-
-    // rewind the file
-    if(lseek(fd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "read_file lseek for status file: %s\n", strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    scanstate_reset(cmpscan);
-    readfd_attach(cmpscan, fd);
-	compare_attach(cmpscan, mv, joblist, nonl);
-
-    // we may want to check the token to see if there are any
-    // special requests (like detabbing).
-}
-
-
-/** Returns true if the given buffer contains non-whitespace characters,
- * false if the buffer consists entirely of whitespace. */
-
-static int contains_nws(const char *cp, int len)
-{
-	const char *ce = cp + len;
-
-	while(cp < ce) {
-		if(!isspace(*cp)) {
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
-
-/** Scans the given buffer for the exit value.
- *
- * Ignores everything except for the first digit and any digits that
- * follow it.
- *
- * If digits are found, then it updates the test structure with
- * whether the exit values match or not.
- * If no digits are found, then this routine does nothing.
- */
-
-void parse_exit_clause(struct test *test, const char *cp, int len)
-{
-	const char *ce = cp + len;
-	unsigned int num = 0;
-
-	// skip to the first digit in the buffer
-	while(!isdigit(*cp) && cp < ce) cp++;
-	if(cp >= ce) return;
-
-	// scan the number
-	while(isdigit(*cp)) {
-		num = 10*num + (*cp - '0');
-		cp++;
-	}
-
-	test->expected_exitno = num;
-	test->exitno_match = (test->exitno == num ? match_yes : match_no);
-}
-
-
-/** Increments cp past the section name.
- *
- * Will not increment cp by more than len bytes.
- * This routine must match the token parsing found in the tfscan_start routine.
- */
-
-const char *skip_section_name(const char *cp, int len)
-{
-	const char *ce = cp + len;
-
-	// skip to colon separating section name from data
-	while(*cp != ':' && *cp != '\n' && cp < ce) cp++;
-	if(*cp == ':') cp++;
-	return cp;
-}
-
-
-void parse_modify_clause(struct test *test, const char *cp, const char *ce)
-{
-	pcrs_job *job, **p;
-	char *string;
-	int err;
-
-	char buf[128];	// holds the pcrs command.  We will dynamically
-		// allocate a buffer if the entire substitution doesn't fit
-		// into this buffer.  The vast majority of substitutions will
-		// be less than 40 chars.
-
-	// skip any leading whitespace
-	while(isspace(*cp) && cp < ce) cp++;
-
-	// ensure there's still data worth parsing
-	if(*cp == '\n' || cp >= ce) {
-		return;
-	}
-
-	// don't parse it if it's a comment
-	if(*cp == '#') {
-		return;
-	}
-
-	// It's retarded that I can't pass a buf/len combo to pcrs_compile_command.
-	// It's also retarded that pcrs won't tell me where it stopped parsing
-	// so that we can have multiple substitution clauses on line line.
-
-	if(ce-cp-1 < sizeof(buf)) {
-		string = buf;
-	} else {
-		string = malloc(ce-cp+1);
-		if(!string) {
-			perror("malloc in parse_modify_clause");
-			exit(10);
-		}
-	}
-
-	memcpy(string, cp, ce-cp);
-	string[ce-cp] = '\0';
-	job = pcrs_compile_command(string, &err);
-	if(job == NULL) {
-        fprintf(stderr, "%s line %d compile error: %s (%d).\n",
-                get_testfile_name(test), test->testfile.line,
-                pcrs_strerror(err), err);
-	}
-
-	if(ce-cp-1 < sizeof(buf)) {
-		// nothing to do; we used the static buffer
-	} else {
-		free(string);
-	}
-
-	if(job == NULL) {
-		return;
-	}
-
-	// link this job onto the end of the list.
-	p = &test->eachline;
-	while(*p) p = &(**p).next;
-	*p = job;
-}
-
-
-/**
- * Calls the given callback routine for each argument found.
- *
- * For now, we just split on whitespace.  In the future, if needed,
- * this routine could be modified to handle \, ", ', etc just like bash.
- */
-
-int parse_section_args(const char *tok, int toklen, const char *file, int line,
-        int (*argproc)(int index, const char *buf, const char *end, 
-            const char *file, int line, void *refcon),
-        void *refcon)
-{
-    const char *end = tok + toklen;
-    const char *cb, *ce;
-    int index = 0;
-    int val = 0;
-
-    ce = tok;
-    while(ce < end) {
-        cb = ce;
-        while(!isspace(*ce) && ce < end) {
-            ce++;
-        }
-
-        val = (*argproc)(index, cb, ce, file, line, refcon);
-        if(val) {
-            break;
-        }
-        index += 1;
-
-        while(isspace(*ce) && ce < end) {
-            ce++;
-        }
-    }
-
-    return val;
-}
-
-
-int constreq(const char *cp, const char *ce, const char *str)
-{
-    int len = strlen(str);
-
-    if(ce - cp != len) {
-        return 0;
-    }
-
-    if(memcmp(cp, str, len) != 0) {
-        return 0;
-    }
-
-    return 1;
-}
-
-
-int start_output_section_argproc(int i, const char *cp, const char *ce,
-        const char *file, int line, void *refcon)
-{
-    if(i == 0) {
-        // index == 0 is the name of this section
-        return 0;
-    }
-
-    // trim colons from arguments...  they can appear anywhere you want.
-    while(*cp == ':' && cp < ce) {
-        cp++;
-    }
-    while(ce[-1] == ':' && ce > cp) {
-        ce--;
-    }
-
-    if(constreq(cp,ce,"-n") || constreq(cp,ce,"--no-trailing-newline")) {
-        *(int*)refcon = 1;
-    } else if(cp < ce) {
-        fprintf(stderr, "%s line %d: unknown arguments \"%.*s\"\n",
-                file, line, ce-cp, cp);
-    }
-
-    return 0;
-}
-
-
-void start_output_section(struct test *test, const char *tok,
-        int toklen, scanstate *cmpscan, int fd, matchval *val,
-        const char *secname)
-{
-    int suppress_trailing_newline = 0;
-
-    parse_section_args(tok, toklen,
-            get_testfile_name(test), test->testfile.line,
-            start_output_section_argproc, 
-            (void*)&suppress_trailing_newline);
-
-    if(*val != match_unknown) {
-        // we've already obtained a value for this section!
-        fprintf(stderr, "%s line %d Error: duplicate %s "
-                "section.  Ignored.\n", get_testfile_name(test),
-                test->testfile.line, secname);
-        // as long as scanref == null, no comparison will happen.
-        assert(!cmpscan->scanref);
-        return;
-    }
-
-    compare_section_start(cmpscan, fd, test->eachline, val,
-        get_testfile_name(test), secname, suppress_trailing_newline);
-}
-
-
-/** This routine parses the tokens returned by scan_sections() and
- * compares them against the actual test results.  It stores the
- * results in test->match_stdout, match_stderr, and match_result.
- *
- * The refcon needs to be an allocated scanner.  It need not be
- * attached to anything -- this routine will take care of attaching
- * and detaching it as needed.
- *
- */
-
-void parse_section_compare(struct test *test, int sec,
-        const char *datap, int len, void *refcon)
-{
-    #define get_cur_state(ss)    ((int)(ss)->userref)
-    #define set_cur_state(ss,x)  ((ss)->userref=(void*)(x))
-
-    // compscan is the comparison scanner -- it is used to diff the
-    // current output section (either stdout or stderr).
-    scanstate *cmpscan = refcon;
-
-    // the section that we're entering (without the NEW flag attached)
-    int newsec = EX_TOKEN(sec);
-
-    if(get_cur_state(cmpscan) == 0) {
-        // This is the first time this scanner has been used.
-        set_cur_state(cmpscan, exCOMMAND);
-    }
-
-    if(!is_section_token(newsec) && sec != 0) {
-        // We only work with result section tokens.  Ignore all
-        // non-section-tokens except the eof token.
-        return;
-    }
-
-    if(EX_ISNEW(sec) || sec == 0) {
-        // ensure previoius section is finished
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-            case exSTDERR:
-                compare_end(cmpscan);
-                break;
-            default:
-                ;
-        }
-
-        // then fire up the new section
-        set_cur_state(cmpscan, newsec);
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-                start_output_section(test, datap, len, cmpscan,
-                        test->outfd, &test->stdout_match, "STDOUT");
-                break;
-            case exSTDERR:
-                start_output_section(test, datap, len, cmpscan,
-                        test->errfd, &test->stderr_match, "STDERR");
-                break;
-            case exRESULT:
-				parse_exit_clause(test, datap, len);
-                break;
-            case exMODIFY:
-				parse_modify_clause(test, skip_section_name(datap,len),
-                        datap+len);
-                break;
-            case exCOMMAND:
-                fprintf(stderr, "%s line %d Error: Well, this is impossible.  "
-                        "How did you start a new command section??\n",
-                        get_testfile_name(test), test->testfile.line);
-                // it should be harmless to continue but this definitely
-                // indicates a bug in the scanner.
-                break;
-        }
-    } else {
-        // we're continuing an already started section.
-        assert(get_cur_state(cmpscan) == newsec);
-
-        switch(get_cur_state(cmpscan)) {
-            case exSTDOUT:
-            case exSTDERR:
-                compare_continue(cmpscan, datap, len);
-                break;
-            case exRESULT:
-				if(contains_nws(datap, len)) {
-					fprintf(stderr, "%s line %d Error: RESULT clause "
-                            "contains garbage.\n",
-							get_testfile_name(test), test->testfile.line);
-                    // Harmless to continue.  The testfile needs to be fixed.
-				}
-                break;
-            case exMODIFY:
-				parse_modify_clause(test, datap, datap+len);
-                break;
-            case exCOMMAND:
-                break;
-        }
-    }
-}
-
-
-/** Scans the output sections of the test and calls the supplied parser
- * for each token.
- *
- * Tokens are defined by the tfscan_start() routine.  Currently they're
- * full lines.  If the line starts with a recognized section heading,
- *
- *
- * @param scanner: used to provide the section tokens.
- */
-
-void scan_sections(struct test *test, scanstate *scanner,
-        void (*parseproc)(struct test *test, int sec, const char *datap,
-                int len, void *refcon), void *refcon)
-{
-    // if the testfile is already at its eof, it means that
-    // it didn't have any sections.  therefore, we'll assume
-    // defaults for all values.  we're done.
-    if(scan_finished(scanner)) {
-        return;
-    }
-    
-    do {
-        int tokno = scan_token(scanner);
-        if(tokno < 0) {
-            fprintf(stderr, "Error %d pulling status tokens: %s\n", 
-                    tokno, strerror(errno));
-            exit(10);
-        } else if(tokno == 0) {
-			break;
-		}
-
-        (*parseproc)(test, tokno, token_start(scanner),
-                token_length(scanner), refcon);
-
-    } while(!scan_finished(scanner));
-
-    // give the parser an eof token so it can finalize things.
-    (*parseproc)(test, 0, NULL, 0, refcon);
-}
-
-
-static void print_reason(struct test *test, const char *name, const char *prep)
-{
-	printf("%s %-25s ", name, get_testfile_name(test));
-	if(!was_started(test->status)) {
-		printf("%s %s", prep, test->last_file_processed);
-		if(test->status_reason) {
-			printf(": ");
-		}
-	}
-	if(test->status_reason) {
-		printf("%s", test->status_reason);
-	}
-	printf("\n");
-}
-
-
-/** Checks the actual results against the expected results.
- */
-
-void test_results(struct test *test)
-{
-    scanstate scanner;
-    char scanbuf[MAX_LINE_LENGTH];
-	int stdo, stde, exno;	// true if there are differences.
-	
-	if(was_aborted(test->status)) {
-		print_reason(test, "ABRT", "by");
-		test_failures++;
-		test->aborted = 1;
-		return;
-	}
-
-	if(was_disabled(test->status)) {
-		print_reason(test, "dis ", "by");
-		return;
-	}
-
-    if(!was_started(test->status)) {
-		print_reason(test, "ERR ", "error in");
-        test_failures++;
-        return;
-    }
-
-    test->exitno_match = match_unknown;
-    test->stdout_match = match_unknown;
-    test->stderr_match = match_unknown;
-
-    scanstate_init(&scanner, scanbuf, sizeof(scanbuf));
-    scan_sections(test, &test->testfile, parse_section_compare, &scanner);
-
-    assert(test->stdout_match != match_inprogress);
-    assert(test->stderr_match != match_inprogress);
-
-    // convert any unknowns into a solid yes/no
-    if(test->exitno_match == match_unknown) {
-		test->expected_exitno = 0;
-        test->exitno_match = (test->exitno == 0 ? match_yes : match_no);
-    }
-    if(test->stdout_match == match_unknown) {
-        test->stdout_match = (fd_has_data(test->outfd) ? match_no : match_yes);
-    }
-    if(test->stderr_match == match_unknown) {
-        test->stderr_match = (fd_has_data(test->errfd) ? match_no : match_yes);
-    }
-
-    stdo = (test->stdout_match != match_yes);
-    stde = (test->stderr_match != match_yes);
-    exno = (test->exitno_match != match_yes);
-
-    if(!stdo && !stde && !exno) {
-        test_successes++;
-        printf("ok   %s \n", get_testfile_name(test));
-    } else {
-        test_failures++;
-        printf("FAIL %-25s ", get_testfile_name(test));
-		printf("%c%c%c  ",
-				(stdo ? 'O' : '.'),
-				(stde ? 'E' : '.'),
-				(exno ? 'X' : '.'));
-		if(stdo || stde) {
-			if(stdo) printf("stdout ");
-			if(stdo && stde) printf("and ");
-			if(stde) printf("stderr ");
-			printf("differed");
-		}
-		if((stdo || stde) && exno) printf(", ");
-		if(exno) printf("result was %d not %d", test->exitno, test->expected_exitno);
-		printf("\n");
-    }
-
-    return;
-}
-
-
-static void write_exit_no(int fd, int exitno)
-{
-    char buf[512];
-    int cnt;
-
-    cnt = snprintf(buf, sizeof(buf), "RESULT: %d\n", exitno);
-    write(fd, buf, cnt);
-}
-
-
-void write_raw_file(int outfd, int infd)
-{
-    char buf[BUFSIZ];
-    int rcnt, wcnt;
-
-    // first rewind the input file
-    if(lseek(infd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "write_file lseek on %d: %s\n", infd, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // then write the file.
-    do {
-        do {
-            rcnt = read(infd, buf, sizeof(buf));
-        } while(rcnt < 0 && errno == EINTR);
-        if(rcnt > 0) {
-            do {
-                wcnt = write(outfd, buf, rcnt);
-            } while(wcnt < 0 && errno == EINTR);
-            if(wcnt < 0) {
-                // write error.  do something!
-                perror("writing in write_file");
-                break;
-            }
-        } else if (rcnt < 0) {
-            // read error.  do something!
-            perror("reading in write_file");
-            break;
-        }
-    } while(rcnt);
-}
-
-
-static void write_modified_file(int outfd, int infd, pcrs_job *job)
-{
-    // this routine is fairly similar to compare_continue_lines.
-    // it would be nice to unify them.  that would take some fairly
-    // major surgery though.
-
-    scanstate scanner, *ss = &scanner;
-    char scanbuf[MAX_LINE_LENGTH];
-    const char *p;
-    char *new;
-    size_t newsize;
-    int rcnt, wcnt;
-
-    // first rewind the input file
-    if(lseek(infd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "write_file lseek on %d: %s\n", infd, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // create the scanner we'll use to buffer the lines
-    scanstate_init(ss, scanbuf, sizeof(scanbuf));
-    readfd_attach(ss, infd);
-
-    do {
-        p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-        if(!p) {
-            rcnt = (*ss->read)(ss);
-            if(rcnt < 0) {
-                // read error.  do something!
-                perror("reading in write_modified_file");
-                break;
-            }
-            p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-            if(!p) {
-                p = ss->limit - 1;
-            }
-        }
-
-        p += 1;
-        new = substitute_string(job, ss->cursor, p, &newsize);
-        if(!new) {
-            // substitution error!  message already printed.
-            break;
-        }
-
-        do {
-            wcnt = write(outfd, new, newsize);
-        } while(wcnt < 0 && errno == EINTR);
-        free(new);
-        if(wcnt < 0) {
-            // write error.  do something!
-            perror("writing in write_modified_file");
-            break;
-        }
-        ss->cursor = p;
-    } while(rcnt);
-}
-
-
-static void write_file(int outfd, int infd, pcrs_job *job)
-{
-	if(!job) {
-		// use the simple, fast routine
-		write_raw_file(outfd, infd);
-	} else {
-		// use the line buffered routine
-		write_modified_file(outfd, infd, job);
-	}
-}
-
-
-/** Writes the actual results in place of the expected results.
- */
-
-void parse_section_output(struct test *test, int sec,
-        const char *datap, int len, void *refcon)
-{
-    int *needs_nl = (int*)refcon;
-
-    assert(sec >= 0);
-
-    if(sec & exNEW) {
-        // check to see if previous section needs a newline appended.
-        if(*needs_nl) {
-            write_strconst(test->rewritefd, "\n");
-        }
-
-        *needs_nl = 0;
-    }
-
-    switch(sec) {
-        case 0:
-            if(*needs_nl) {
-                write_strconst(test->rewritefd, "\n");
-            }
-            break;
-
-        case exSTDOUT|exNEW:
-            parse_section_args(datap, len,
-                    get_testfile_name(test), test->testfile.line,
-                    start_output_section_argproc, needs_nl);
-            write(test->rewritefd, datap, len);
-            write_file(test->rewritefd, test->outfd, test->eachline);
-            test->stdout_match = match_yes;
-            break;
-        case exSTDOUT:
-            // ignore all data in the expected stdout.
-            break;
-
-        case exSTDERR|exNEW:
-            parse_section_args(datap, len,
-                    get_testfile_name(test), test->testfile.line,
-                    start_output_section_argproc, needs_nl);
-            write(test->rewritefd, datap, len);
-            write_file(test->rewritefd, test->errfd, test->eachline);
-            test->stderr_match = match_yes;
-            break;
-        case exSTDERR:
-            // ignore all data in the expected stderr
-            break;
-
-        case exRESULT|exNEW:
-            test->exitno_match = match_yes;
-            write_exit_no(test->rewritefd, test->exitno);
-            break;
-        case exRESULT:
-            // allow random garbage in result section to pass
-            write(test->rewritefd, datap, len);
-            break;
-
-        case exMODIFY|exNEW:
-            parse_modify_clause(test, skip_section_name(datap,len), datap+len);
-            write(test->rewritefd, datap, len);
-            break;
-        case exMODIFY:
-            // parse modify sections and still print them.
-            parse_modify_clause(test, datap, datap+len);
-            write(test->rewritefd, datap, len);
-            break;
-            
-        default:
-            write(test->rewritefd, datap, len);
-    }
-}
-
-
-static void dump_reason(struct test *test, const char *name)
-{
-	fprintf(stderr, "ERROR Test %s", name);
-	if(!was_started(test->status)) {
-		fprintf(stderr, " by %s", convert_testfile_name(test->last_file_processed));
-		if(test->status_reason) {
-			printf(": ");
-		}
-	}
-	if(test->status_reason) {
-		fprintf(stderr, ": %s", test->status_reason);
-	}
-	fprintf(stderr, "\n");
-}
-
-
-/** Prints the actual result sections in the same order as they
- * appear in the testfile.
- */
-
-void dump_results(struct test *test)
-{
-    int tempref = 0;
-
-	if(was_aborted(test->status)) {
-		dump_reason(test, "was aborted");
-		test->aborted = 1;
-		return;
-	}
-
-	if(was_disabled(test->status)) {
-		dump_reason(test, "is disabled");
-		return;
-
-	}
-
-    if(!was_started(test->status)) {
-        fprintf(stderr, "Error: %s was not started due to errors in %s.\n",
-				get_testfile_name(test), test->last_file_processed);
-        test_failures++;
-        return;
-    }
-
-    // The command section has already been dumped.  We just
-    // need to dump the result sections.  The trick is, though,
-    // that we need to dump them in the same order as they occur
-    // in the testfile otherwise the diff will be all screwed up.
-
-    test->exitno_match = match_unknown;
-    test->stdout_match = match_unknown;
-    test->stderr_match = match_unknown;
-
-    // ensure that we haven't yet parsed any modify sections.
-    assert(!test->eachline);
-
-    scan_sections(test, &test->testfile, parse_section_output, &tempref);
-
-    // if any sections haven't been output, but they differ from
-    // the default, then they need to be output here at the end.
-
-    if(test->exitno_match == match_unknown && test->exitno != 0) {
-        write_exit_no(test->rewritefd, test->exitno);
-    }
-    if(test->stderr_match == match_unknown && fd_has_data(test->errfd)) {
-		write_strconst(test->rewritefd, "STDERR:\n");
-        write_file(test->rewritefd, test->errfd, test->eachline);
-    }
-    if(test->stdout_match == match_unknown && fd_has_data(test->outfd)) {
-		write_strconst(test->rewritefd, "STDOUT:\n");
-        write_file(test->rewritefd, test->outfd, test->eachline);
-    }
-}
-
-
-void print_test_summary()
-{
-    printf("\n");
-    printf("%d test%s run, ", test_runs, (test_runs != 1 ? "s" : ""));
-    printf("%d success%s, ", test_successes, (test_successes != 1 ? "es" : ""));
-    printf("%d failure%s.", test_failures, (test_failures != 1 ? "s" : ""));
-
-	if(!quiet) {
-		printf("    ");
-		print_rusage();
-	}
-	
-	printf("\n");
-}
-
-
-void test_init(struct test *test)
-{
-    test_runs++;
-    memset(test, 0, sizeof(struct test));
-    test->rewritefd = -1;
-}
-
-
-void test_free(struct test *test)
-{
-	int err;
-
-	// the buffer for the testfile scanner is allocated on the stack.
-	if(test->eachline) {
-		pcrs_free_joblist(test->eachline);
-	}
-
-	if(test->diffname) {
-		err = close(test->diff_fd);
-		if(err < 0) {
-			fprintf(stderr, "Could not close %s: %s\n", test->diffname, strerror(errno));
-		}
-		err = unlink(test->diffname);
-		if(err < 0) {
-			fprintf(stderr, "Could not remove %s: %s\n", test->diffname, strerror(errno));
-		}
-		free(test->diffname);
-	}
-
-	if(test->status_reason) {
-		free(test->status_reason);
-	}
-
-	if(test->last_file_processed) {
-		free(test->last_file_processed);
-	}
-}
-
-

Copied: releases/0.94/test.c (from rev 99, trunk/test.c)

Deleted: releases/0.94/test.h
===================================================================
--- trunk/test.h	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/test.h	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,85 +0,0 @@
-/* test.h
- * Scott Bronson
- * 29 Dec 2004
- *
- * All the data needed to run a test and print the results.
- * This file is covered by the MIT License.
- */
-
-#include "pcrs.h"
-#include "matchval.h"
-#include "re2c/scan.h"
-
-
-typedef enum {
-	test_pending=0,			///< still processing config files
-	config_was_aborted,		///< some config file called ABORT
-	config_was_disabled, 	///< some config file called DISABLED
-
-	test_was_started=16,	///< test was started but we haven't received an exit status yet.
-	test_was_completed,		///< test completed normally.  tests may abort prematurely but still consider it a successful run, so use test_was_started.  this status is largely useless.
-	test_was_aborted,		///< somebody called abort in the middle of the test.
-	test_was_disabled,		///< the test was disabled by somebody.
-} test_status;
-
-
-#define was_started(st)  ((st) >= test_was_started)
-#define was_aborted(st)  ((st) == config_was_aborted || (st) == test_was_aborted)
-#define was_disabled(st) ((st) == config_was_disabled || (st) == test_was_disabled)
-
-
-// Nonzero if we want to be as silent as possible
-// (only print results, no statistics or other useful conversation).
-extern int quiet;
-
-// If this is set, then we should use it as the config file rather than
-// checking /etc/tmtest.conf, ~/.tmtestrc, etc.
-extern char *config_file;
-
-// all strings are malloc'd and need to be freed when the test is finished.
-
-struct test {
-    const char *testfilename;   ///< will be "-" if reading from stdin.
-    scanstate testfile;         ///< scans the testfile.  may be stdin so seeking is not allowed.
-
-    int rewritefd;          ///< where to dump the rewritten test.  -1 if we're just running the tests, or the fd of the file that should receive the test contents.
-
-    int outfd;				///< the file that receives the test's stdout.
-    int errfd;				///< the file that receives the test's stderr.
-    int statusfd;			///< receives the runtime test status messages.
-    int exitno;				///< the test's actual exit value.
-
-	pcrs_job *eachline;		///< a linked list of pcrs jobs to be applied to each line.
-
-	char *diffname;			///< if we're diffing against stdin, this contains the name of the required tempfile.
-	int diff_fd;			///< if diffname is set, then this is the fd of the tempfile we're using to store stdin.
-
-	test_status status;		///< Tells what happened with the test.
-	char *status_reason;	///< If the test was aborted or disabled, and the user gave a reason why, that reason is stored here.  Allocated dynamically -- free it when done.
-
-	int num_config_files;	///< the number of config files we started processing.  If the status is higher than test_was_started, then this gives the total number of config files processed.
-	char *last_file_processed; ///< if it could be discovered, this contains the name of the last file to be started.  must be freed.
-	int aborted;			///< true if the test was aborted (and therefore no further tests should be run).
-
-	int expected_exitno;	///< the test's expected exit value.  this is only valid when stderr_match != match_unknown.
-
-    matchval exitno_match;	///< tells whether the expected and actual exit values match.
-    matchval stdout_match;	///< tells whether the expected and actual stdout matches.
-    matchval stderr_match;	///< tells whether the expected and actual stderr matches.
-};
-
-
-void scan_status_file(struct test *test);
-void test_command_copy(struct test *test, FILE *fp);
-
-void test_results(struct test *test);
-void dump_results(struct test *test);
-void print_test_summary();
-
-void test_init(struct test *test);
-void test_free(struct test *test);
-
-
-// random utility function for start_diff:
-void write_raw_file(int outfd, int infd);
-

Copied: releases/0.94/test.h (from rev 99, trunk/test.h)

Deleted: releases/0.94/tfscan.c
===================================================================
--- trunk/tfscan.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/tfscan.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,261 +0,0 @@
-/* tfscan.c
- * Scott Bronson
- * 30 Dec 2004
- *
- * Scanner for test files.  This used to be a re2c scanner but
- * I couldn't get it to work with no LF at the end of file.
- *
- * This file is covered by the MIT License.
- */
-
-// TOTEST: >8K token not containing a cr
-// STDOUT:, STDERR:, etc at the EOF with no data.
-// STDOUT at the beginning of the file.
-// keyword without a colon
-// 		NO NO NO keyword without a colon is still the keyword.
-// 		And a keyword without a NL is still the keyword.
-// 		But it must always start at the beginning of a new line.
-// exit clauses with invalid numbers
-// What happens with a MODIFY larger than BUFSIZ.
-// DOS/Mac/Unix line endings.
-// 		What happes when platform doesn't match the testfile?
-// 	Get rid of rewrite_command_section
-
-// NOTE: because we linebuffer the MODIFY clause, a single MODIFY
-// may not be larger than the BUFSIZ on your system (usually 8192 bytes).
-// Technically this is true of RESULT as well but when are you ever going
-// to run into an 8K result code?
-
-#include "tfscan.h"
-
-
-#define START(x) (ss->scanref=(void*)(x))
-
-#ifndef NULL
-#define NULL ((void*)0)
-#endif
-
-
-int tfscan_tok_start(scanstate *ss);
-int tfscan_nontok_start(scanstate *ss);
-
-
-/*!re2c
- 
-  // This is almost the scanner that this file implements, except that
-  // this file handles data at EOF correctly.
-
-WS      = [ \t];
-ANYN    = [\000-\377]\[\n];
-
-"STDOUT" WS* ":" ANYN* "\n"  { START(exSTDOUT); return exNEW|exSTDOUT; }
-"STDERR" WS* ":" ANYN* "\n"  { START(exSTDERR); return exNEW|exSTDERR; }
-"RESULT" WS* ":" ANYN* "\n"  { START(exRESULT); return exNEW|exRESULT; }
-"MODIFY" WS* ":" ANYN* "\n"  { START(exMODIFY); return exNEW|exMODIFY; }
-
-ANYN* "\n"                  { return (int)ss->scanref; }
-
-
-// What it does:
-// Returns exCOMMAND for all data chunks.
-// When it sees the start of a section, it returns exNEW|TOK
-// (i.e. (exNEW|exSTDOUT).  This tells you that the old section
-// has ended and a new one is starting.  Then it continues
-// returning exSTDOUT without the exNEW flag until another
-// seciton starts.
-
-*/
-
-
-
-static int scan_to_end_of_keyword(scanstate *ss, int tok)
-{
-	// We assume that we're immediately at the end of a keyword
-	// section.  The first six bytes just guarantees the keyword.
-
-	// skip all characters up to the final nl.
-
-	while(*YYCURSOR != '\r' && *YYCURSOR != '\n') {
-		YYCURSOR++;
-		if(YYCURSOR >= YYLIMIT) {
-			break;
-		}
-	}
-
-	if(*YYCURSOR == '\r') YYCURSOR++;
-	if(*YYCURSOR == '\n') YYCURSOR++;
-
-    ss->line += 1;
-
-	START(tok);
-	return exNEW|tok;
-}
-
-
-/* When it finds a line that begins
- * with a new section, it returns the token name of that section
- * with the exNEW flag turned on.  After that, it returns each
- * line in the section with the token's identifier.  Then, when it
- * finds a new section, you get a exNEW+TOKEN of the new section.
- */
-
-int tfscan_tok_start(scanstate *ss)
-{
-    scanner_enter(ss);
-
-    // if we can read at least 8 more bytes from the current buffer,
-    // we won't bother reloading it.  This should cut down drastically
-    // on the number of small reads we make.
-	if(YYCURSOR+8 >= YYLIMIT) {
-		int r = (*ss->read)(ss);
-		// if there was an error, return an error token.
-		if(r < 0) return r;
-		// Only if we're _completely_ out of data, return eof.
-		// (this is why we can't use re2c for this scanner)
-		if(ss->token >= ss->limit) return 0;
-	}
-
-	// At this point in the scanner, we know that we are at the beginning
-    // of a line (previous character was either start-of-file or \n).
-	// So check to see if there's a token.
-
-	if(YYCURSOR + 8 < YYLIMIT) {
-		// There's enough data in this buffer to contain a keyword.
-		// If there are less than 8 bytes in the buffer then it means
-		// that we're 7 bytes from the EOF and there's no chance that
-		// there's another keyword to scan.  (6 bytes for the keyword,
-		// 1 byte for the colon, one byte for the newline).
-		switch(*YYCURSOR) {
-			case 'S':
-				if(YYCURSOR[1] == 'T' && YYCURSOR[2] == 'D') {
-					if(YYCURSOR[3]=='O' && YYCURSOR[4]=='U' && YYCURSOR[5]=='T') {
-						return scan_to_end_of_keyword(ss, exSTDOUT);
-					}
-					if(YYCURSOR[3]=='E' && YYCURSOR[4]=='R' && YYCURSOR[5]=='R') {
-						return scan_to_end_of_keyword(ss, exSTDERR);
-					}
-				}
-				// else it wasn't a token so we can just keep scanning.
-				break;
-			case 'R':
-				if(YYCURSOR[1]=='E' && YYCURSOR[2]=='S' &&
-					YYCURSOR[3]=='U' && YYCURSOR[4]=='L' && YYCURSOR[5]=='T')
-				{
-					return scan_to_end_of_keyword(ss, exRESULT);
-				}
-				break;
-			case 'M':
-				if(YYCURSOR[1]=='O' && YYCURSOR[2]=='D' &&
-					YYCURSOR[3]=='I' && YYCURSOR[4]=='F' && YYCURSOR[5]=='Y')
-				{
-					return scan_to_end_of_keyword(ss, exMODIFY);
-				}
-				break;
-			default:
-				break;
-		}
-	}
-
-	// So there wasn't a keyword at this point in the buffer.
-	// We just treat it as random data.  Since we haven't moved the
-    // cursor we can just call straight into the nontok routine.
-	ss->state = tfscan_nontok_start;
-	return tfscan_nontok_start(ss);
-}
-
-
-int tfscan_nontok_start(scanstate *ss)
-{
-	scanner_enter(ss);
-
-	if(YYCURSOR >= YYLIMIT) {
-		int r = (*ss->read)(ss);
-		// if there was an error, return an error token.
-		if(r < 0) return r;
-		// if we're completely out of data, return eof.
-		// (this is why we can't use re2c for this scanner)
-		if(ss->token >= ss->limit) return 0;
-	}
-
-	// Since it's impossible to have a token at this point so we
-	// scan forward to the next CR/LF.
-	while(YYCURSOR < YYLIMIT) {
-		if(*YYCURSOR == '\r' || *YYCURSOR == '\n') break;
-		YYCURSOR++;
-	}
-	if(YYCURSOR >= YYLIMIT) {
-		// We have to assume that we previously read as much data as
-		// possible.  So the entire buffer is just data with no tokens
-		// and no CR/LF.
-		return (int)ss->scanref;
-	}
-
-	if(*YYCURSOR == '\r') YYCURSOR++;
-	if(*YYCURSOR == '\n') YYCURSOR++;
-
-    ss->line += 1;
-
-	// We have potential for finding a token at this point.
-	ss->state = tfscan_tok_start;
-	return (int)ss->scanref;
-}
-	
-
-
-/** Prepares the given scanner to scan a testfile.
- *
- *  @param ss the scanstate to attach to.  Passing NULL is safely ignored.
- *  @returns ss.  Always.  This routine makes no calls that can fail.
- */
-
-scanstate* tfscan_attach(scanstate *ss)
-{
-    if(ss) {
-        START(exCOMMAND);
-        ss->state = tfscan_tok_start;
-    }
-
-    return ss;
-}
-
-/*
-
-SOME MORE THOUGHTS ON SCANNING:
-
-
-We know we're at the beginning of the buffer or immediately
-after a newline.
-	Do we have enough data for a keyword?
-		No: fill buffer with more data.
-	We know we have enough data for a keyword.  Use strstr.
-	
-See if a keyword is here.
-If 
-
-
-So what's the problem?
-	Read might return:
-		error, just return error code as negative number.
-		0, eof.
-			If we have more data in the buffer, we need to make sure
-			to return that data.
-			(actaully, with re2c, that's not the case.  It screws up the
-			last token in the file unless the file ends on a token delimiter).
-			- If there's no more data in the buffer then we just return 0.
-		positive number: we read data.
-
-So the problem is that re2c scanners can't handle it if the file doesn't
-end on a token delim.  We can't return if we hit eol and haven't scanned
-more data even if there's more data in the buffer.  The stupid re2c
-scanner will just start scanning in the garbage past the end of the buffer.
-Sigh.
-
-That means I can't use it for the testfile scanner.
-
-That furthermore means that I can't use YYFILL on the non-broken scanner.
-I should probably add a different macro that can be used everywhere,
-zero-length reads (as in a network packet), file ending with a non-delim
-character, etc.
-
-*/
-

Copied: releases/0.94/tfscan.c (from rev 99, trunk/tfscan.c)

Deleted: releases/0.94/tmlib.sh
===================================================================
--- trunk/tmlib.sh	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/tmlib.sh	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,180 +0,0 @@
-# tmlib.sh
-
-# Utilities useful for writing tmtest testfiles.
-# This file is covered by the MIT License.
-
-
-# TODO: should these routines be prefixed by "TM"?
-
-
-# Current functions:
-# ASSERT: Stop a test if a condition fails
-# ATEXIT: Ensure something gets cleaned up even if the test fails.
-# MKFILE MKFILE_EMPTY: create temporary files
-# MKDIR: create a temporary directory
-
-
-
-#
-# ASSERT
-#
-# If you include this file from either a config file or your
-# test file (". assert.sh" or "source assert.sh"),
-# you can then use asserts in your test scripts.
-
-# usage:
-#   . assert.sh
-# 	assert 42 -eq $((0x2A))		# true, so test continues as normal
-# 	assert 1 -eq 2				# false, so the test is aborted.
-
-ASSERT ()
-{
-	if [ ! $* ]; then
-		msg=''
-		if [ ${BASH_VERSINFO[0]} -ge 3 ]; then
-			# bash2 doesn't provide BASH_SOURCE or BASH_LINENO
-			msg=" on ${BASH_SOURCE[1]} line ${BASH_LINENO[0]}"
-		fi
-		ABORT assertion failed$msg: \"$*\"
-	fi  
-}    
-
-
-#
-# TRAP
-#
-# This function makes trap behave more like atexit(3), where you can
-# install multiple commands to execute for the same condition.
-# I'm surprised that Bash doesn't do this by default.
-#
-# NOTE: you must not mix use of TRAP and trap on the same conndition.
-# The builtin trap will remove TRAP's condition, and all the commands
-# installed using TRAP will not be run.
-#
-# Call this routine exactly like the trap builtin: "TRAP cmd cond"
-#
-# Example:
-#
-#     TRAP "echo debug!" DEBUG
-#
-
-TRAP ()
-{
-	# install the trap if this is the first time TRAP is called for
-	# the given condition.  (Is there any way to get rid of "local var"??)
-
-	local var=TRAP_$2
-	if [ ! -n "${!var}" ]; then
-		trap "eval \"\$TRAP_$2\"" $2
-	fi
-
-
-	# This just adds $1 to the front of the string given by TRAP_$2.
-	# In Perl:		$TRAP{$2} = $1.($TRAP{$2} ? "; " : "").$TRAP{$2}
-
-	eval TRAP_$2=\"$1'${'TRAP_$2':+; }$'TRAP_$2\"
-}
-
-
-#
-# ATEXIT
-#
-# This behaves just like atexit(3) call.  Supply a command to be executed
-# when the shell exits.  Commands are executed in the reverse order that
-# they are supplied.
-#
-# Example:  (will produce "BA" on stdout when the test ends)
-#
-#     ATEXIT echo A
-#     ATEXIT echo -n B
-
-ATEXIT ()
-{
-	TRAP "$*" EXIT
-}
-
-
-#
-# MKFILE
-#
-# Creates a file and assigns the new filename to the given variable.
-# Fills in the new file with the supplied data.  Ensures that it is
-# deleted when the test ends.
-#
-# argument 1: varname, the name of the variable that will contain the new filename.
-# argument 2: filename, (optional) the name/fullpath to give the file.
-#
-# You need to be aware that if you supply an easily predictable filename
-# (such as a PID), you are exposing your users to symlink attacks.  You
-# should never supply a filename unless you know EXACTLY what you are doing.
-#
-# Examples:
-#
-# create a new file with a random name in $TMPDIR or /tmp:
-#
-#     MKFILE fn <<-EOL
-#     	Initial file contents.
-#     EOL
-#     cat "$fn"		<-- prints "Initial file contents."
-#
-# create a new empty file with the given name (open to symlink attack,
-# DO NOT USE UNLESS YOU ARE SURE WHAT YOU ARE DOING).
-#
-#     MKFILE ttf /tmp/$mydir/tt1 < /dev/null
-#
-
-MKFILE ()
-{
-	local name=${2-`mktemp -t tmtest.XXXXXX || ABORT MKFILE: could not mktemp`}
-	eval "$1='$name'"
-	cat > "$name"
-	ATEXIT "rm '$name'"
-}
-
-
-#
-# MKFILE_EMPTY
-#
-# I can't figure out how to get bash to bail instead of blocking.
-# Therefore, if you just want to create an empty file, you either
-# call MKFILE piped from /dev/null or just call MKFILE_EMPTY.
-#
-
-MKFILE_EMPTY ()
-{
-	MKFILE "$*" < /dev/null
-}
-
-
-#
-# MKDIR
-#
-# Like MKFILE, but creates a directory instead of a file.  If you
-# supply a directory name, and that directory already exists, then
-# MKDIR ensures it is deleted when the script ends.  The directory
-# will not be deleted if it still contains any files.
-#
-# argument 1: varname, the name of the variable that will contain the new directory name.
-# argument 2: dirname, (optional) the name/fullpath to give the directory.
-#
-# Examples:
-#
-# create a new directory with a random name in $TMPDIR or /tmp:
-#
-#     MKDIR dn
-#     cd "$dn"
-#
-
-MKDIR ()
-{
-	local name=${2}
-	if [ -z "$name" ]; then
-		name=`mktemp -d -t tmtest.XXXXXX || ABORT MKDIR: could not mktemp`
-	else
-		[ -d $name ] || mkdir --mode 0600 $name || ABORT "MKDIR: could not 'mkdir \"$name\"'"
-	fi
-
-	eval "$1='$name'"
-	ATEXIT "rmdir '$name'"
-}
-

Copied: releases/0.94/tmlib.sh (from rev 99, trunk/tmlib.sh)

Deleted: releases/0.94/tmtest.conf
===================================================================
--- trunk/tmtest.conf	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/tmtest.conf	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,63 +0,0 @@
-# tmtest.conf
-# Scott Bronson
-# 31 Dec 2004
-
-
-# This file tells how to run tests on tmtest itself.
-# See tmtestetc or tmtestrc for examples of globally-installed
-# configuration files.
-
-
-# This can be a little confusing because one copy of tmtest runs another
-# copy and checks its output.  We'll call the executable doing the testing
-# the superexec, and the program being tested the subexec.
-#
-# Because the user launched the superexec, we have no control over which
-# executable is used to run the tests.  Hopefully it's reasonably stable.
-#
-# This configuration file, tmtest.conf, tells the superexec how to run the
-# test battery.  Local settings are read from /etc/tmtest.conf, ~/.tmtestrc,
-# etc., then this file is loaded.
-#
-# The subtests do not read any configuration files outside of the test
-# directory except for one, tmtest.sub.conf.
-
-
-# turn on debugging
-# set -x
-
-
-# All tests are written to be pedantic.  We want them to exit at the
-# first sign of trouble and have the result code reported in RESULT.
-
-set -e
-
-
-
-# Add the current directory at the front of the PATH environment variable.
-# This means that while the test is running, any executables in this
-# directory will take priority over similarly-named executables anywhere
-# else (like /usr/bin or ~/bin).  This ensures that we lauch the unstable
-# copy of tmtest to handle each subtest.
-
-PATH="$MYDIR:$PATH";
-
-
-# All testfiles include $args in the arguments to the subexec.
-# (if they don't, it's a bug in the test).
-#
-# This allows us to specify default commands for all tests being run.
-# For instance, forcing the config file ensures that no config files
-# outside the test directory will be read.  This way we can be sure
-# that the tests are not succeeding due to some local configuration;
-# their environment is as clean as we can possibly make it.
-
-args="--config=$MYPATH/test/tmtest.sub.conf"
-
-
-# This allows us to run tests without installing tmtest first.
-# (todo: will this cause problems if you DO have a currently-installed
-# tmtest?)
-
-. tmlib.sh
-

Copied: releases/0.94/tmtest.conf (from rev 99, trunk/tmtest.conf)

Deleted: releases/0.94/tmtest.pod
===================================================================
--- trunk/tmtest.pod	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/tmtest.pod	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,188 +0,0 @@
-=head1 NAME
-
-tmtest - Makes functional tests as easy to write as shell scripts.
-
-=head1 SYNOPSIS
-
-B<tmtest> [B<-d>|B<-o>] [I<dir>|I<testfile>...]
-
-=head1 DESCRIPTION
-
-
-
-=head1 OPTIONS
-
-=over 8
-
-=item B<-c> B<--config>
-
-Specifies the config file to be read before running the test file.
-Prevents the standard config files (/etc/tmtest.conf, /etc/tmtest/tmtest.conf,
-~/.tmtestrc) from being read.  Also doesn't read config files unless they
-are below the directory that contains the specified file.
-
-=item B<-d> B<--diff>
-
-Prints a diff of the expected results against the actual results.
-The expected results are the lines prefixed with a '-',
-and the actual results are prefixed with a '+'.
-In other words, the '+' lines are ones that the test erroneously added,
-and the '-' lines are ones that the test erroneously didn't print.
-
-You can pipe the output straight into the patch
-program to modify the test files.  This works when running tests
-in subdirectories too, but you need to invoke C<patch -p0> becaue
-the patch utility doesn't enter subdirectories by default.
-
-    tmtest -d | less        # view patch to ensure no bad changes
-    tmtest -d | patch -p0   # update every testfile.  Beware!
-
-DANGER!!!  This is the perfect way to let subtle bugs slip
-into your test deck.  Make sure you know exactly what you
-changed, right down to the whitespace.
-
-=item B<-q> B<--quiet>
-
-Tells tmtest to be quiet while running tests.  tmtest only prints the
-test results, and a final passed/failed/disabled summary.  So, it's
-quieter than it normally is but it certainly isn't silent.
-
-=back
-
-=head1 TESTFILE
-
-=over 8
-
-=item MODIFY
-
-Specifies a perl-compatible substitution command to be executed
-on each line of the program's output.  For instance,
-the following modify clause will replace DATE='2005-10-02' with
-DATE='DATE DATE'.
-
-	MODIFY: s/DATE='.*'/DATE='DATE DATE'/
-
-Due to a pcrs limitation, you may only specify one substitution
-command per MODIFY clause.  ("MODIFY: s/1/one/ s/2/two/" will not
-work.
-
-=back
-
-=head1 CONFIGURATION
-
-tmtest reads its configuration first from F</etc/tmtest.conf> and
-F<~/.tmtest.conf>.  Then it starts at the root directory and works
-its way up to the current directory looking for files named "tmtest.conf"
-Therefore, /home/test/a/b/tmtest.conf overrides /home/test/tmtest.conf
-(because the latter is read and executed before the former).
-It executes each config files every time it runs a test.  If you're
-running 40 tests, your config files will each get executed 40 times.
-
-Note that while config files are running, the current directory
-is set to the testfile's directory.  For convenience, in each
-config file, the MYFILE variable gives the full pathname to the config
-file, and MYDIR gives just the directory portion (MYFILE and MYDIR
-are available when running the test script too -- MYDIR is just the
-current working directory).
-
-Any output produced by the config files goes straight to the screen.
-It will not contaminate the test results.  tmtest only cares about
-the output produced by the testfile itself.
-
-=over 8
-
-=item ABORT
-
-Causes the test to abort immediately.  You can optionally specify
-a message.  See the example in L</MKDIR>.
-
-    ABORT: too bad this test won't live
-
-=item DISABLE
-=item DISABLED
-
-Marks the test disabled.  If put in a config file, marks all tests in
-that directory and all subdirectories disabled.
-
-You can supply a reason string too
-
-   DISABLED: this test is just too lame.
-
-=back
-
-=head1 EXIT VALUE
-
-tmtest returns a nonzero error code only if one or more tests
-could not be run for some reason.  If all tests are successfully run,
-even if they all fail, tmtest returns 0.
-
-=head1 SUGGESTIONS
-
-Look in the "examples" directory that came with this distribution.
-You may find some helpful utilities.
-
-If you want to be more pedantic, you might want to "set -e" in your
-test file or configuration file.  This will make it so the test will
-stop at the very first command that returns a nonzero exit status.
-
-If you can't figure out what your test is doing, you might want
-to add "set -v" or "set -x" to the top of the testfile.  This will
-show you line-by-line what is happening.  You can also put them in
-a config file if you're having configuration issues.
-
-Never create files in /tmp with static or easily predictable file names.
-This opens you up to symlink attacks.  Instead, use mktemp(1)
-or tempfile(1).  Also check the examples directory for functions
-to make working with files easier.
-
-	file=`mktemp -t 02-XXXXXX` || ABORT can't mktemp.
-
-=head1 FAQ
-
-How do I indent my stdout section?  My test prints the word "STDOUT" at
-the beginning of the line, causing tmtest to choke on the multiple STDOUT
-sections.
-
-A: Yes, tmtest is pedantic about finding sections in a file.  This is
-because it can be easy to get confused about what line applies where.
-Easiest just to ensure that there is a single section.
-
-But what to do if your test's output would contain a section break?
-Simply indent every line of your test's output by some number of spaces:
-
-	MODIFY : s/^(.)/   $1/
-
-The complex expression is because some versions of pcrs mistakenly
-add two spaces after tine final newline.  This ensures that the line
-actually contains a character before indenting it.
-
-=head1 HISTORY
-
-The original tmtest script was written in June of 2000 when I got frustrated
-with the TrestleMail mail relay program.  TrestleMail, now large and complex,
-required some serious reorganization.  I wrote tmtest as a quick one-off Perl
-hack to allow me to tear TrestleMail to shreds and have some hope of getting
-the peices back together.
-
-The Perl version was too slow and its testfile format took some learking.
-So, in early 2005, I rewrote the good parts in C and tried to make it as
-much like Bash as possible.
-
-=head1 LICENSE
-
-tmtest is distributed under the Lesser General Public License.
-See the COPYING file included with this tmtest distribution for
-more details or L<http://www.gnu.org/copyleft/lesser.html>.
-
-=head1 FILES
-
-L<tmtest.conf(5)>
-
-=head1 SEE ALSO
-
-L<testfile(1)>, L<tmtest.conf(5)>
-
-=head1 AUTHOR
-
-Scott Bronson <S<bronson at rinspin.com>>
-

Copied: releases/0.94/tmtest.pod (from rev 90, trunk/tmtest.pod)

Deleted: releases/0.94/vars.c
===================================================================
--- trunk/vars.c	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/vars.c	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,267 +0,0 @@
-/* vars.c
- * Scott Bronson
- * 29 Dec 2004
- *
- * Interpolates $(VARS) in the test template (template.sh).
- * This file is covered by the MIT License.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <pwd.h>
-#include <assert.h>
-
-#include "test.h"
-#include "vars.h"
-#include "curdir.h"
-
-#define CONFIG_FILE "tmtest.conf"
-#define HOME_CONFIG_FILE ".tmtestrc"
-
-
-/** @file vars.c
- *
- * Generates values for all the variables that appear in the
- * shell template.
- *
- * The functions in this file return errors only when there's a config
- * error (i.e. bad template variable, can't get user's login, etc).
- * They should ignore write errors.  They will happpen whenever the
- * test (or a config file) exits early and should properly be ignored.
- *
- * NOTE: this file is the only place in this project that we use
- * fileptrs.  Well, other than printing status information from main.c,
- * and, by proxy, the test_command_copy() routine.
- * Everywhere else we use Unix I/O.  Ensure they never mix.
- */
-
-static int var_testfile(struct test *test, FILE* fp, const char *var)
-{
-	fprintf(fp, "%s/%s", curabsolute(), test->testfilename);
-    return 0;
-}
-
-static int var_testdir(struct test *test, FILE* fp, const char *var)
-{
-	fputs(curabsolute(), fp);
-    return 0;
-}
-
-
-static int var_testexec(struct test *test, FILE* fp, const char *var)
-{
-    // If the filename is a dash, it means we should feed the test
-    // from stdin.  Otherwise, just have the shell execute the testfile.
-
-    if(test->testfilename[0] == '-' && test->testfilename[1] == '\0') {
-		// bash doesn't support setting LINENO any more but,
-		// what the hell, it's worth a shot.
-		fprintf(fp, "LINENO=0\n");
-        test_command_copy(test, fp);
-    } else {
-        test_command_copy(test, NULL);
-        fprintf(fp, ". '%s/%s'", curabsolute(), test->testfilename);
-    }
-
-    return 0;
-}
-
-
-static int var_outfd(struct test *test, FILE *fp, const char *var)
-{
-    fprintf(fp, "%d", test->outfd);
-    return 0;
-}
-
-static int var_errfd(struct test *test, FILE *fp, const char *var)
-{
-    fprintf(fp, "%d", test->errfd);
-    return 0;
-}
-
-static int var_statusfd(struct test *test, FILE *fp, const char *var)
-{
-    fprintf(fp, "%d", test->statusfd);
-    return 0;
-}
-
-
-/** Returns the full path to the user's home directory.
- */
-
-static char* get_home_dir()
-{
-	char *cp;
-	struct passwd *entry;
-	
-	cp = getenv("HOME");
-	if(cp) return cp;
-	cp = getenv("LOGDIR");
-	if(cp) return cp;
-
-	entry = getpwuid(getuid());
-	if(entry) {
-		cp = entry->pw_dir;
-		if(cp) return cp;
-	}
-
-	fprintf(stderr, "Could not locate your home directory!\n");
-	exit(10);
-}
-
-
-/** Returns true if the given file exists, false if not.
- */
-
-int file_exists(char *path)
-{
-	struct stat st;
-	return stat(path, &st) == 0 && S_ISREG(st.st_mode);
-}
-
-
-
-#define check_config_str(t,f,s,n) check_config((t),(f),(s),strlen(s),(n))
-
-
-/** Checks to see if the file exists and, if it does, then it
- *  outputs the appropriate commands.
- *
- *  @param base The path.
- *  @param len The number of characters from base to use.
- *  @param name The filename.  It will be concatenated with a '/'
- *  onto the end of base.  Optional: if name is null then base will
- *  be used directly.  This is a 0-terminated string.
- *
- *  @see var_config_files()
- */
-
-static void check_config(struct test *test, FILE *fp,
-		const char *base, int len, const char *name)
-{
-	char buf[PATH_MAX];
-	
-	// if the buffer isn't big enough then don't even try.
-	if(len+(name?strlen(name):0)+2 > sizeof(buf)) return;
-
-	// assemble the file name
-	memcpy(buf, base, len);
-	buf[len]='\0';
-
-	// append the filename if supplied
-	if(name) {
-		buf[len] = '/';
-		buf[len+1] = 0;
-		strcat(buf+len+1, name);
-	}
-
-	if(config_file && strcmp(buf,config_file) == 0) {
-		// If buf == config_file then it means the user must have
-		// specified a config file within the current search path.
-		// This ensures that we don't include it twice.
-		return;
-	}
-
-	if(file_exists(buf)) {
-		fprintf(fp, "echo 'CONFIG: %s' >&%d\n", buf, test->statusfd);
-		fprintf(fp, "MYDIR='%.*s'\nMYFILE='%s'\n. '%s'\n", len, buf, buf, buf);
-	}
-}
-
-
-/** Prints the shell commands needed to read in all available config files.
- *
- * for instance:
- *
- *     echo 'CONFIG: /etc/tmtest' >&5
- *     . '/etc/tmtest'
- *     echo 'CONFIG: /home/bronson/tmtest/tmtest.conf' >&5
- *     . '/home/bronson/tmtest/tmtest.conf'
- *
- *     and so on...
- */
-
-static int var_config_files(struct test *test, FILE *fp, const char *var)
-{
-	char buf[PATH_MAX];
-    char *cp;
-	int confbaselen;
-
-	// check global configuration files
-	if(config_file) {
-		// Need to obliterate config_file, otherwise it will think that
-		// it has included config_file twice and refuse to include it.
-		char *oldcfg = config_file;
-		config_file = NULL;
-		check_config_str(test, fp, oldcfg, NULL);
-		config_file = oldcfg;
-	} else {
-		check_config_str(test, fp, "/etc", CONFIG_FILE);
-		check_config_str(test, fp, "/etc/tmtest", CONFIG_FILE);
-		check_config_str(test, fp, get_home_dir(), HOME_CONFIG_FILE);
-	}
-
-	// check config files in the current hierarchy
-	strncpy(buf, curabsolute(), sizeof(buf));
-	if(config_file) {
-		confbaselen = strrchr(config_file, '/') - config_file;
-	}
-    for(cp=buf; (cp=strchr(cp,'/')); cp++) {
-		// If the user specifies a config file, we only check directories
-		// not above the given config file.  i.e. if user specifies
-		// "tmtest -c /a/b/cc /a/t/u/t.test", we will look for config files
-		// in /a/t/tmtest.conf and /a/t/u/tmtest.conf.
-		if(config_file && cp-buf <= confbaselen &&
-				memcmp(buf, config_file, cp-buf)==0) {
-			continue;
-		}
-		check_config(test, fp, buf, cp-buf, CONFIG_FILE);
-    }
-	check_config_str(test, fp, buf, CONFIG_FILE);
-
-    return 0;
-}
-
-
-/** Prints the value for variable varname to file fp.
- * Returns zero if successful, nonzero if not.
- */
-
-int printvar(struct test *test, FILE *fp, const char *varname)
-{
-    int i;
-
-    struct {
-        char *name;
-        int (*func)(struct test *test, FILE *fp, const char *var);
-    } funcs[] = {
-        { "CONFIG_FILES",   var_config_files },
-        { "OUTFD",          var_outfd },
-        { "ERRFD",          var_errfd },
-        { "STATUSFD",       var_statusfd },
-        { "TESTFILE",       var_testfile },
-        { "TESTEXEC",       var_testexec },
-        { "TESTDIR",        var_testdir },
-    };
-
-    for(i=0; i<sizeof(funcs)/sizeof(funcs[0]); i++) {
-        if(strcmp(varname, funcs[i].name) == 0) {
-            if(funcs[i].func) {
-                return (*funcs[i].func)(test, fp, varname);
-            } else {
-                fprintf(fp, "<<<%s>>>", varname);
-                return 0;
-            }
-        }
-    }
-
-    fprintf(stderr, "Unknown variable '%s' in template.\n", varname);
-    return 1;
-}
-

Copied: releases/0.94/vars.c (from rev 99, trunk/vars.c)

Deleted: releases/0.94/vars.h
===================================================================
--- trunk/vars.h	2006-02-28 00:50:58 UTC (rev 88)
+++ releases/0.94/vars.h	2006-03-03 00:12:52 UTC (rev 102)
@@ -1,2 +0,0 @@
-struct test;
-int printvar(struct test *test, FILE *fp, const char *varname);

Copied: releases/0.94/vars.h (from rev 99, trunk/vars.h)

Added: releases/tmtest-0.92.tar.gz
===================================================================
(Binary files differ)


Property changes on: releases/tmtest-0.92.tar.gz
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: releases/tmtest-0.94.tar.gz
===================================================================
(Binary files differ)


Property changes on: releases/tmtest-0.94.tar.gz
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream





From tmtest-commits at berlios.de  Sun Mar  5 05:31:18 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Sun, 5 Mar 2006 05:31:18 +0100
Subject: [Tmtest-commits] [103] trunk: Tmtest would get confused by .
Message-ID: <200603050431.k254VIOi008571@sheep.berlios.de>

Revision: 103
Author:   bronson
Date:     2006-03-05 05:30:56 +0100 (Sun, 05 Mar 2006)

Log Message:
-----------
Tmtest would get confused by . and .. passed on the command line.
Fix that, make the path handling regular.  As if main.c could get
any more messy...

Modified Paths:
--------------
    trunk/Makefile
    trunk/TODO
    trunk/curdir.c
    trunk/curdir.h
    trunk/main.c
    trunk/sample.conf
    trunk/test/02-running/05-Running.test
    trunk/test/03-results/30-Binary.test
    trunk/test/03-results/31-BinaryFail.test
    trunk/test/03-results/32-BinaryLarge.test
    trunk/test/03-results/33-BinaryHuge.test
    trunk/test/04-diff/02-MultiDiff.test
    trunk/test/04-diff/05-AbortDiff.test
    trunk/test/tmtest.sub.conf
    trunk/test.c
    trunk/test.h
    trunk/tmlib.sh
    trunk/tmtest.conf

Added Paths:
-----------
    trunk/pathconv.c
    trunk/pathconv.h
    trunk/test/01-testfile/23-TestVarsDeep.test
    trunk/test/01-testfile/24-TestVarsRoot.test
    trunk/test/01-testfile/dumpscript/
    trunk/test/01-testfile/dumpscript/10-Stdout.test
    trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test
    trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test
    trunk/test/01-testfile/dumpscript/13-BareParentDir.test
    trunk/test/01-testfile/dumpscript/14-DeepDir.test
    trunk/test/01-testfile/dumpscript/15-PathOps.test
    trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test
    trunk/test/01-testfile/dumpscript/README
    trunk/test/01-testfile/dumpscript/tmtest.conf
    trunk/test/02-running/50-OpenFDsTest.test
    trunk/test/02-running/51-OpenFDsConfig.tst

Removed Paths:
-------------
    trunk/rel2abs.c
    trunk/rel2abs.h
    trunk/test/01-testfile/10-DumpScript.test
Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/Makefile	2006-03-05 04:30:56 UTC (rev 103)
@@ -5,19 +5,19 @@
 # This software is distributed under the LGPL.  See COPYING for more.
 
 
-VERSION=0.94
+VERSION=0.95
 
-# override this when installing: "make install prefix=/usr/local"
+# override this for make install.  "make install prefix=/usr/local"
 #prefix=/usr
 prefix=$(HOME)
 
-
+# figure out where to install the software:
 bindir=$(prefix)/bin
 lib_src=tmlib.sh
 
 ifeq ($(prefix), $(HOME))
-	libdir=$(prefix)
-	stdlib=$(libdir)/.tmlib.sh
+	libdir=$(HOME)
+	stdlib=$(HOME)/.tmlib.sh
 	conf_dst=$(HOME)/.tmtestrc
 else
 	libdir=$(prefix)/share/tmtest
@@ -29,8 +29,8 @@
 COPTS=-g -Wall -Werror
 
 # utilities:
-CSRC+=curdir.c qscandir.c pcrs.c rel2abs.c
-CHDR+=curdir.h qscandir.h pcrs.h rel2abs.h
+CSRC+=curdir.c qscandir.c pcrs.c pathconv.c
+CHDR+=curdir.h qscandir.h pcrs.h pathconv.h
 # scanner files
 CSRC+=re2c/read.c re2c/read-fd.c re2c/scan.c
 CHDR+=re2c/read.h re2c/read-fd.h re2c/scan.h

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/TODO	2006-03-05 04:30:56 UTC (rev 103)
@@ -1,4 +1,15 @@
 0.96:
+- Make tmtest only execute config files owned by either the user or root.
+  Print a big fat warning when the config file is skipped.  This prevents
+  a malicious user from putting a config file in /tmp and having it
+  executed.  But is this a good idea?  I may want to run tests in another
+  user's directory.  Would it be better to just ensure that we never
+  read a config file from /tmp?  No, cause sticky dirs could be anywhere.
+  Maybe here's the deal: if a config file is in or below a world-writable
+  dir, it must be owned by the current user to be exectued.  Not even root.
+  That's probably the most agreeable.
+  We will not read either config or test files from a world-writable directory.
+  Ever.
 - Put $args into EVERY test we run.
 - There's some sort of a bug with 10-DumpScript.test.  When running with
   -o or -d, sometimes it complains about a missing newline.  Odd.
@@ -29,6 +40,9 @@
 - Figure out how to ensure that we run the binary in the project tree
   when testing rather than the globally installed one.  What happened?
 - Ensure it compiles and runs on freebsd.
+- Add some unit tests.  http://kooditakomo.cs.tut.fi/projects/gunit/
+  http://pvanhoof.be/blog/index.php/2006/03/03/tinymail-unit-testing-and-creating-messages     Actually, this looks better: http://cutest.sourceforge.net/
+  Potential units: curdir, path normalization
 
 0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.
@@ -44,6 +58,8 @@
   buffer.  If your stderr is more than 100K or so in size, just redirect
   it to a file, then cat the file at the end.  We truncate stderr if it
   gets too big.
+- Is there any way to record memory and swap usage for each test?
+  sure, it's in the rusage. prolly add a "tmtest -v" to print it for each test.
 - stdin is all buggered up.  why is it that "cat" with no args will print
   the rest of the test script?  And why is it that if you fork, diff freezes?
   They're related problems I suspect.

Modified: trunk/curdir.c
===================================================================
--- trunk/curdir.c	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/curdir.c	2006-03-05 04:30:56 UTC (rev 103)
@@ -10,6 +10,36 @@
  * Unfortunately this file got hacked to shreds when tmtest was
  * made to run with /tmp as the constant cwd.  It's pretty
  * incomprehensible and in dire dire DIRE need of a rewrite.
+ *
+ * There's also now a pretty serious impedance mismatch...
+ * The caller must handle all occurrences of "//" "/.", ".."
+ * etc. in the partial path before passing it here.  But
+ * that's stupid because properly handling those requires
+ * converting the parital to an absolute path before normalizing.
+ * This library should normalize the path after catting, then
+ * return the number of normalized directories added.  This is
+ * pretty decidedly nontrivial, of course, because if I push
+ * "..", a directory gets removed from the path, then I push
+ * "dir", then I pop twice, I need to return to the original
+ * directory.
+ *
+ * So for now, alas, it's hacked in main.c.
+ *
+ * What this file should have been:
+ *
+ * A completely flexible path lib.  You can init the path with an
+ * arbitrary string or from the cwd.  You can push an arbitrary
+ * path onto the end (including "..") and it will return a pointer
+ * to an "undo" struct.  Then, when you want to pop the pushed
+ * path, you pass the undo struct, and everything is reverted to
+ * the way it was before.  You can push an arbitrary number of
+ * times.  Push/pop must always be nested of course.  And, of
+ * course, you must be able to save and restore the state of the
+ * curdir.  Finally, it should not use globals so multiple threads
+ * etc. can all maintain their own curdirs.
+ *
+ * If we had a module that could do this, main.c could be
+ * *drastically* cleaned up.  Sigh.
  */
 
 #include <stdio.h>
@@ -98,19 +128,6 @@
 }
 
 
-/** Resets the curdir so that curabsolute() and currelative()
- *  return what they did after curinit() was first called.
- */
-
-void curreset()
-{
-	if(curpart) {
-		curpart[-1] = '\0';
-		curpart[0] = '\0';
-	}
-}
-
-
 void cursave(struct cursave *save)
 {
 	strcpy(save->buf, curdir);

Modified: trunk/curdir.h
===================================================================
--- trunk/curdir.h	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/curdir.h	2006-03-05 04:30:56 UTC (rev 103)
@@ -18,7 +18,6 @@
 int curinit(const char *path);
 int curpush(const char *dir);
 void curpop(int keep);
-void curreset();
 void cursave(struct cursave *save);
 void currestore(struct cursave *save);
 const char *curabsolute();

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/main.c	2006-03-05 04:30:56 UTC (rev 103)
@@ -29,7 +29,7 @@
 #include "qscandir.h"
 #include "vars.h"
 #include "tfscan.h"
-#include "rel2abs.h"
+#include "pathconv.h"
 
 
 #define DIFFPROG "/usr/bin/diff"
@@ -46,9 +46,12 @@
 int allfiles = 0;
 int dumpscript = 0;
 int quiet = 0;
+const char *orig_cwd;		// tmtest runs with the cwd pointed to /tmp
 char *config_file;	// absolute path to the user-specified config file
 					// null if user didn't specify a config file.
 
+int arg_was_absolute;	// this is an absolutely awful hack.  it's true
+		// if the current path is absolute, false if it's relative.
 
 #define TESTDIR "/tmp/tmtest-XXXXXX"
 char g_testdir[sizeof(TESTDIR)];
@@ -136,7 +139,6 @@
 		st = &sts;
 	}
 
-
 	if(stat(file, st) < 0) {
 		fprintf(stderr, "Could not locate %s: %s\n", file, strerror(errno));
 		return 0;
@@ -339,9 +341,10 @@
 					perror("strdup in start_diff");
 					exit(runtime_error);
 				}
-				curreset();
+				curpop(1);
 				if(0 != chdir(curabsolute())) {
-					fprintf(stderr, "Could not chdir 1 to %s: %s\n", curabsolute(), strerror(errno));
+					fprintf(stderr, "Could not chdir 1 to %s: %s\n",
+							curabsolute(), strerror(errno));
 					exit(runtime_error);
 				}
 			}
@@ -405,7 +408,7 @@
  * @returns 1 if we should keep testing, 0 if we should stop now.
  */
 
-static int run_test(const char *name, int warn_suffix)
+static int run_test(const char *name, const char *dispname, int warn_suffix)
 {
     struct test test;
     char buf[BUFSIZ];   // scan buffer for the testfile
@@ -550,7 +553,7 @@
         // process and output the test results
         switch(outmode) {
             case outmode_test:
-                test_results(&test);
+                test_results(&test, dispname);
                 break;
             case outmode_dump:
                 dump_results(&test);
@@ -589,15 +592,11 @@
 }
 
 
-// forward declaration for recursion
-int process_dir();
-
-
 /**
  * Sucks the dirname from an absolute file path and calls curinit with it.
  */
 
-static void init_path(const char *path)
+static void init_absolute_filepath(const char *path)
 {
 	const char *cp;
 	int loc;
@@ -620,9 +619,12 @@
 	curinit(buf);
 }
 
-/** Processes a directory specified using an absolute path.
+
+/** Processes a directory specified using an absolute or deep
+ * path.  We need to save and restore curpath to do this.
  *
- * We need to save and restore curpath to do this.
+ * It's illegal to call this routine with a path that doesn't
+ * include at least one / character.
  *
  * @returns 1 if we should continue testing, 0 if we should abort.
  */
@@ -633,33 +635,115 @@
 	int keepontruckin;
 
 	cursave(&save);
-	init_path(path);
+	init_absolute_filepath(path);
 
+	keepontruckin = run_test(strrchr(path,'/')+1, path, warn_suffix);
+
+	currestore(&save);
+	return keepontruckin;
+}
+
+
+static void init_path(const char *base, const char *path)
+{
+	char buf[PATH_MAX];
+
+	strncpy(buf, curabsolute(), PATH_MAX);
+	strncat(buf, "/", PATH_MAX);
+	strncat(buf, path, PATH_MAX);
+	buf[PATH_MAX-1] = '\0';
+
+	normalize_absolute_path(buf);
+
+	curinit(buf);
+}
+
+
+
+/**
+ * This is actually a hassle.  The user may have specified
+ * "../.." which means we need to normalize an absolute path
+ * and use that.
+ */
+
+static int process_deep_file(const char *path, int warn_suffix)
+{
+	struct cursave save;
+	int keepontruckin;
+
+	cursave(&save);
+	init_path(orig_cwd, path);
+	curpop(1);	// get rid of the filename
+
+	keepontruckin = run_test(strrchr(path,'/')+1, path, warn_suffix);
+
+	currestore(&save);
+	return keepontruckin;
+}
+
+
+// forward declaration for recursion
+int process_dir();
+
+static int process_absolute_dir(const char *path)
+{
+	struct cursave save;
+	int keepontruckin;
+
+	cursave(&save);
+	curinit(path);
+
+	// we are certain the fullpath has already been normalized.
+	// no need to do it again.
+
 	if(outmode == outmode_test) {
 		printf("\nProcessing %s\n", path);
 	}
-	keepontruckin = run_test(path, warn_suffix);
+	keepontruckin = process_dir();
 
 	currestore(&save);
+
 	return keepontruckin;
 }
 
 
-/** Processes a directory specified using an absolute path.
+static void print_relative_dir()
+{
+	char buf[PATH_MAX];
+
+	if(arg_was_absolute) {
+		printf("\nProcessing %s\n", curabsolute());
+	} else {
+		if(!abs2rel(curabsolute(), orig_cwd, buf, PATH_MAX)) {
+			printf("Path couldn't be converted \"\%s\"\n", curabsolute());
+			exit(runtime_error);
+		}
+		printf("\nProcessing ./%s\n", buf);
+	}
+}
+
+
+/**
+ * This routine used to be a simple "push the dir onto curpath,
+ * run, and pop" affair.  Now, with ".." being fairly nontrivial,
+ * we just need to save and restore.  Arg.  But at least this
+ * works.
  *
- * We need to save and restore curpath to do this.
+ * The relative path can't be normalied because it might be
+ * simply "..".  Therefore, it's one above whatever the cwd
+ * is.  Gotta figure that out at runtime.
  */
 
-static int process_absolute_dir(const char *path)
+static int process_relative_dir(const char *path)
 {
 	struct cursave save;
 	int keepontruckin;
 
 	cursave(&save);
-	curinit(path);
+	init_path(curabsolute(), path);
 
 	if(outmode == outmode_test) {
-		printf("\nProcessing %s\n", path);
+		print_relative_dir();
 	}
 	keepontruckin = process_dir();
 
@@ -671,10 +755,13 @@
 
 /** Process all entries in a directory.
  *
- * See run_test() for an explanation of warn_suffix.
+ * @param is_topmost True if we are not recursing.  This allows us to
+ * tell whether we should display pathnames absolute or relative
+ * (if the user specified them relative on the command line, we
+ * show them relative, and vice versa).
  */
 
-static int process_ents(char **ents, int warn_suffix)
+static int process_ents(char **ents, int is_topmost)
 {
 	struct stat st;
     mode_t *modes;
@@ -718,9 +805,12 @@
     for(i=0; i<n; i++) {
         if(is_dash(ents[i]) || S_ISREG(modes[i])) {
 			if(ents[i][0] == '/') {
-				keepontruckin = process_absolute_file(ents[i], warn_suffix);
+				// we know the path has already been fully normalized.
+				keepontruckin = process_absolute_file(ents[i], is_topmost);
+			} else if(strchr(ents[i], '/')) {
+				keepontruckin = process_deep_file(ents[i], is_topmost);
 			} else {
-				keepontruckin = run_test(ents[i], warn_suffix);
+				keepontruckin = run_test(ents[i], ents[i], is_topmost);
 			}
 			if(!keepontruckin) {
 				goto abort;
@@ -733,19 +823,16 @@
     for(i=0; i<n; i++) {
         if(is_dash(ents[i]) || modes[i] == 0) continue;
         if(S_ISDIR(modes[i])) {
+			if(is_topmost) {
+				// this is an unfortunate hack.  we display the path the same
+				// way the user specified (absolute or relative) so we need
+				// to remember which one it is.
+				arg_was_absolute = (ents[i][0] == '/');
+			}
 			if(ents[i][0] == '/') {
 				keepontruckin = process_absolute_dir(ents[i]);
 			} else {
-				int keep = curpush(ents[i]);
-				if(keep <= 0) {
-					fprintf(stderr, "Path is too long.");
-					exit(runtime_error);
-				}
-				if(outmode == outmode_test) {
-					printf("\nProcessing ./%s\n", currelative());
-				}
-				keepontruckin = process_dir();
-				curpop(keep);
+				keepontruckin = process_relative_dir(ents[i]);
 			}
 			if(!keepontruckin) {
 				goto abort;
@@ -861,35 +948,33 @@
 
 static void set_config_file(const char *cfg)
 {
-	char cwd[PATH_MAX];
-	char out[PATH_MAX];
-	char *path;
+	char buf[PATH_MAX];
 
 	if(cfg[0] == '\0') {
 		fprintf(stderr, "You must specify a directory for --config.\n");
 		exit(argument_error);
 	}
 
-	if(!getcwd(cwd, PATH_MAX)) {
-		perror("Couldn't get current working directory");
-		exit(runtime_error);
+	if(cfg[0] == '/') {
+		strncpy(buf, cfg, PATH_MAX);
+		buf[PATH_MAX-1] = '\0';
+	} else {
+		strncpy(buf, orig_cwd, PATH_MAX);
+		strncat(buf, "/", PATH_MAX);
+		strncat(buf, cfg, PATH_MAX);
+		buf[PATH_MAX-1] = '\0';
 	}
 
-	path = rel2abs(cfg, cwd, out, PATH_MAX);
-	if(!path) {
-		fprintf(stderr, "Got %d figuring out absolute path for \"%s\": %s",
-				errno, cfg, strerror(errno));
-		exit(runtime_error);
-	}
+	normalize_absolute_path(buf);
 
 	// need to ensure as well as we can that the file is readable because
 	// we don't open it ourselves.  Bash does.  And that can lead to some
 	// really cryptic error messages.
-	if(!verify_readable(out,NULL,1)) {
+	if(!verify_readable(buf,NULL,1)) {
 		exit(runtime_error);
 	}
 
-	config_file = strdup(out);
+	config_file = strdup(buf);
 	if(!config_file) {
 		perror("strdup");
 		exit(runtime_error);
@@ -924,7 +1009,6 @@
 		{"dump-script", 0, &dumpscript, 1},
 		{"help", 0, 0, 'h'},
 		{"output", 0, 0, 'o'},
-		{"patch", 0, 0, 'p'},
 		{"quiet", 0, 0, 'q'},
 		{"version", 0, 0, 'V'},
 		{0, 0, 0, 0},
@@ -963,10 +1047,6 @@
                 outmode = outmode_dump;
 				break;
 
-			case 'p':
-                outmode = outmode_diff;
-                break;
-
 			case 'q':
 				quiet++;
 				break;
@@ -991,13 +1071,109 @@
 }
 
 
+/*
+ * I wish I could use canonicalize_path(3), but that routine resolves
+ * symbolic links and provides no way to turn that behavior off.
+ * How stupid!  This isn't as much of a hack as it looks because
+ * "./../.." still needs to resolve to a real directory.
+ *
+ * @param original: the path to be normalized
+ * @param outpath: the normalized path.  this may or may not be the same
+ *     as original.
+ */
+
+static void normalize_path(char *original, char **outpath)
+{
+    char buf[PATH_MAX];
+    char normalized[PATH_MAX];
+
+    if(original[0] == '/') {
+		if(strlen(original) > PATH_MAX-1) {
+			fprintf(stderr, "Path is too long: %s\n", original);
+			exit(runtime_error);
+		}
+		strcpy(normalized, original);
+		normalize_absolute_path(normalized);
+    } else {
+        strncpy(buf, curabsolute(), PATH_MAX);
+		strncat(buf, "/", PATH_MAX);
+		strncat(buf, original, PATH_MAX);
+		buf[PATH_MAX-1] = '\0';
+		normalize_absolute_path(buf);
+
+		// convert it back to a relative path so it prints the
+		// way the user intends.  We need to beware later on
+		// to trim .. from the leading path.
+		if(!abs2rel(buf, curabsolute(), normalized, PATH_MAX)) {
+            fprintf(stderr, "Could not reabsize %s: %s\n",
+				original, strerror(errno));
+			exit(runtime_error);
+		}
+    }
+
+	if(strcmp(original,normalized) == 0) {
+		*outpath = original;
+	} else {
+		*outpath = strdup(normalized);
+	}
+}
+
+
+static void normalize_free(const char *original, char *outpath)
+{
+    if(outpath != original) {
+        free(outpath);
+    }
+}
+
+
+/**
+ * Normalize all the passed-in paths, then call process_ents()
+ * with the normalized paths.  It's easiest to just dup argv
+ * and modify that.
+ */
+
+static void process_argv(char **argv)
+{
+	char **ents;
+	int i, n;
+
+    for(n=0; argv[n]; n++) { }
+
+	ents = malloc((n+1)*sizeof(*ents));
+	ents[n] = NULL;
+
+	for(i=0; i<n; i++) { normalize_path(argv[i], &ents[i]); }
+	process_ents(ents, 1);
+	for(i=0; i<n; i++) { normalize_free(argv[i], ents[i]); }
+}
+
+
+/**
+ * The Gnu version of getcwd can do this for us but that's not portable.
+ */
+
+static const char* dup_cwd()
+{
+	char buf[PATH_MAX];
+
+	if(!getcwd(buf, PATH_MAX)) {
+		perror("Couldn't get current working directory");
+		exit(runtime_error);
+	}
+
+	return strdup(buf);
+}
+
+
 int main(int argc, char **argv)
 {
+	orig_cwd = dup_cwd();
 	process_args(argc, argv);
 
     start_tests();
     if(optind < argc) {
-        process_ents(argv+optind, 1);
+		process_argv(argv+optind);
     } else {
         if(outmode == outmode_test) {
             printf("\nProcessing .\n");
@@ -1010,6 +1186,7 @@
         print_test_summary();
     }
 
+	free((char*)orig_cwd);
 	return 0;
 }
 

Added: trunk/pathconv.c
===================================================================
--- trunk/pathconv.c	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/pathconv.c	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,184 @@
+/* Copyright (c) 1997 Shigio Yamaguchi. All rights reserved.
+   Copyright (c) 1999 Tama Communications Corporation. All rights reserved.
+
+   The Pathconvert Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The Pathconvert Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include "pathconv.h"
+
+
+/*
+ * abs2rel: convert an absolute path name into relative.
+ *
+ *	i)	path	absolute path
+ *	i)	base	base directory (must be absolute path)
+ *	o)	result	result buffer
+ *	i)	size	size of result buffer
+ *	r)		!= NULL: relative path
+ *			== NULL: error
+ */
+char *
+abs2rel(path, base, result, size)
+	const char *path;
+	const char *base;
+	char *result;
+	const size_t size;
+{
+	const char *pp, *bp, *branch;
+	/*
+	 * endp points the last position which is safe in the result buffer.
+	 */
+	const char *endp = result + size - 1;
+	char *rp;
+
+	if (*path != '/') {
+		if (strlen(path) >= size)
+			goto erange;
+		strcpy(result, path);
+		goto finish;
+	} else if (*base != '/' || !size) {
+		errno = EINVAL;
+		return (NULL);
+	} else if (size == 1)
+		goto erange;
+	/*
+	 * seek to branched point.
+	 */
+	branch = path;
+	for (pp = path, bp = base; *pp && *bp && *pp == *bp; pp++, bp++)
+		if (*pp == '/')
+			branch = pp;
+	if ((*pp == 0 || (*pp == '/' && *(pp + 1) == 0)) &&
+	    (*bp == 0 || (*bp == '/' && *(bp + 1) == 0))) {
+		rp = result;
+		*rp++ = '.';
+		if (*pp == '/' || *(pp - 1) == '/')
+			*rp++ = '/';
+		if (rp > endp)
+			goto erange;
+		*rp = 0;
+		goto finish;
+	}
+	if ((*pp == 0 && *bp == '/') || (*pp == '/' && *bp == 0))
+		branch = pp;
+	/*
+	 * up to root.
+	 */
+	rp = result;
+	for (bp = base + (branch - path); *bp; bp++)
+		if (*bp == '/' && *(bp + 1) != 0) {
+			if (rp + 3 > endp)
+				goto erange;
+			*rp++ = '.';
+			*rp++ = '.';
+			*rp++ = '/';
+		}
+	if (rp > endp)
+		goto erange;
+	*rp = 0;
+	/*
+	 * down to leaf.
+	 */
+	if (*branch) {
+		if (rp + strlen(branch + 1) > endp)
+			goto erange;
+		strcpy(rp, branch + 1);
+	} else
+		*--rp = 0;
+finish:
+	return result;
+erange:
+	errno = ERANGE;
+	return (NULL);
+}
+
+
+// Copyright (c) 2006 Scott Bronson
+// The following code can be distributed under the LGPL as above
+// or, at your option, the much simpler MIT license.
+
+/**
+ * Normalizes the absolute path in-place.
+ * A path can only get shorter when it's normalized, never longer.
+ *
+ * This is not the way I'd like to write this routine.  I'd like
+ * to walk two pointers through the string copying bits from the
+ * src to the dst so I don't spend so much time moving the same
+ * bytes over and over.  Alas, I'm out of time so I'm going to
+ * resort to this loathesome coding style for less chance of bugs.
+ *
+ * @returns 1 if this was a relative path and therefore the function
+ * did nothing.  Otherwise returns 0.
+ *
+ * TODO: split this out into a unit and make some unit tests for it.
+ */
+
+int normalize_absolute_path(char *buf)
+{
+	char *cp;
+	int end;
+
+	if(buf[0] != '/') {
+		// refuse to normalize a relative path
+		return 1;
+	}
+
+	cp = buf + 1;
+	end = strlen(buf) - 1;
+
+	while(end > 0) {
+		// we're just past the slash of the prev directory
+		if(cp[0] == '/') {
+			// turn '//' into '/'
+			memmove(cp, cp+1, end);
+			end -= 1;
+		} else if(cp[0] == '.' && (cp[1] == '/' || end == 1)) {
+			// turn '/./' into '/'
+			memmove(cp, cp+2, end-1);
+			end -= 2;
+		} else if(cp[0] == '.' && cp[1] == '.' && (cp[2] == '/' || end == 2)) {
+			// save our position
+			char *src = cp+3;
+			// back up one dir, not moving past the base dir
+			cp -= 1;
+			while(cp > buf+1 && cp[-1] != '/') cp -= 1;
+			memmove(cp, src, end-2);
+			end -= 3;
+		} else {
+			// skip a directory name
+			while(*cp != '/' && end > 0) {
+				cp += 1;
+				end -= 1;
+			}
+			if(*cp == '/' && end > 0) {
+				cp += 1;
+				end -= 1;
+			}
+		}
+	}
+
+	if(cp[-1] == '/') {
+		cp -= 1;
+	}
+
+	*cp = '\0';
+
+	return 0;
+}
+
+

Added: trunk/pathconv.h
===================================================================
--- trunk/pathconv.h	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/pathconv.h	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,11 @@
+// The rel2abs that comes with pathconv is hopeless. It removes .. without
+// moving up a directory and the code is pretty bad so it has been purged.
+// Just use strcat and then normalize the absolute path.
+//
+// char *rel2abs(const char *path, const char *base, char *result,
+// 		const size_t size);
+
+char *abs2rel(const char *path, const char *base, char *result,
+		const size_t size);
+
+int normalize_absolute_path(char *buf);

Deleted: trunk/rel2abs.c
===================================================================
--- trunk/rel2abs.c	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/rel2abs.c	2006-03-05 04:30:56 UTC (rev 103)
@@ -1,126 +0,0 @@
-/* Copyright (c) 1997 Shigio Yamaguchi. All rights reserved.
-   Copyright (c) 1999 Tama Communications Corporation. All rights reserved.
-
-   The Pathconvert Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The Pathconvert Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <stdlib.h>
-#include <string.h>
-/*
- * rel2abs: convert an relative path name into absolute.
- *
- *	i)	path	relative path
- *	i)	base	base directory (must be absolute path)
- *	o)	result	result buffer
- *	i)	size	size of result buffer
- *	r)		!= NULL: absolute path
- *			== NULL: error
- */
-char *
-rel2abs(path, base, result, size)
-	const char *path;
-	const char *base;
-	char *result;
-	const size_t size;
-{
-	const char *pp, *bp;
-	/*
-	 * endp points the last position which is safe in the result buffer.
-	 */
-	const char *endp = result + size - 1;
-	char *rp;
-	int length;
-
-	if (*path == '/') {
-		if (strlen(path) >= size)
-			goto erange;
-		strcpy(result, path);
-		goto finish;
-	} else if (*base != '/' || !size) {
-		errno = EINVAL;
-		return (NULL);
-	} else if (size == 1)
-		goto erange;
-
-	length = strlen(base);
-
-	if (!strcmp(path, ".") || !strcmp(path, "./")) {
-		if (length >= size)
-			goto erange;
-		strcpy(result, base);
-		/*
-		 * rp points the last char.
-		 */
-		rp = result + length - 1;
-		/*
-		 * remove the last '/'.
-		 */
-		if (*rp == '/') {
-			if (length > 1)
-				*rp = 0;
-		} else
-			rp++;
-		/* rp point NULL char */
-		if (*++path == '/') {
-			/*
-			 * Append '/' to the tail of path name.
-			 */
-			*rp++ = '/';
-			if (rp > endp)
-				goto erange;
-			*rp = 0;
-		}
-		goto finish;
-	}
-	bp = base + length;
-	if (*(bp - 1) == '/')
-		--bp;
-	/*
-	 * up to root.
-	 */
-	for (pp = path; *pp && *pp == '.'; ) {
-		if (!strncmp(pp, "../", 3)) {
-			pp += 3;
-			while (bp > base && *--bp != '/')
-				;
-		} else if (!strncmp(pp, "./", 2)) {
-			pp += 2;
-		} else if (!strncmp(pp, "..\0", 3)) {
-			pp += 2;
-			while (bp > base && *--bp != '/')
-				;
-		} else
-			break;
-	}
-	/*
-	 * down to leaf.
-	 */
-	length = bp - base;
-	if (length >= size)
-		goto erange;
-	strncpy(result, base, length);
-	rp = result + length;
-	if (*pp || *(pp - 1) == '/' || length == 0)
-		*rp++ = '/';
-	if (rp + strlen(pp) > endp)
-		goto erange;
-	strcpy(rp, pp);
-finish:
-	return result;
-erange:
-	errno = ERANGE;
-	return (NULL);
-}

Deleted: trunk/rel2abs.h
===================================================================
--- trunk/rel2abs.h	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/rel2abs.h	2006-03-05 04:30:56 UTC (rev 103)
@@ -1,2 +0,0 @@
-char * rel2abs(const char *path, const char *base, char *result, const size_t size);
-

Modified: trunk/sample.conf
===================================================================
--- trunk/sample.conf	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/sample.conf	2006-03-05 04:30:56 UTC (rev 103)
@@ -1,12 +1,14 @@
-# This is the system-wide configuration file for tmtest.  tmtest
-# configuration files are read in the following order.  Settings
-# in later files override settings in earlier ones.
+# This is the system-wide configuration file for tmtest.
+
+# tmtest configuration files are read in the following order:
 #
 #    /etc/tmtest.conf
 #    /etc/tmtest/tmtest.conf
 #    ~/.tmtestrc
-#    /tmtest.conf				(starts at root dir and works its way
-#    / ... ./tmtest.conf		up to the dir containing the testfile.
+#    /tmtest.conf				(starts at root dir and works its way up to
+#    / ... ./tmtest.conf		 the dir containing the testfile being run)
+#
+# Settings in later files override earlier ones.
 
 
 # include the standard utility functions

Deleted: trunk/test/01-testfile/10-DumpScript.test
===================================================================
--- trunk/test/01-testfile/10-DumpScript.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/10-DumpScript.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -1,70 +0,0 @@
-# Ensures that the dumpscript is what we expect.
-# This is just so we don't surprise ourselves...  Any time you modify
-# template.sh, you should expect test to fail.
-
-SANIFY ()
-{
-	# This function cleans the absolute pathnames specifying the
-	# 'tmtest.sub.conf' config file from the script.
-
-	sed \
-	-e "s/echo 'CONFIG: .*tmtest.sub.conf' .*/echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD/" \
-	-e "s/MYDIR='.*test'/MYDIR='...test'/" \
-	-e "s/MYFILE='.*tmtest.sub.conf'/MYFILE='...tmtest.sub.conf'/" \
-	-e "s/\\. '.*tmtest.sub.conf'/. '...tmtest.sub.conf'/"
-}
-
-tmtest $args --dump-script - <<-EOL | SANIFY
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 2
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 3
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 4
-EOL
-
-MODIFY:
-  s/DATE='.*'/Date='BLAH BLAH'/
-  s/^(.)/	$1/
-
-STDOUT:
-	echo START >&7
-
-	ABORT ()  { echo "ABORTED: $*" >&7; exit 0; }
-	ABORT: () { ABORT $*; }
-
-	DISABLED  () { echo "DISABLED: $*" >&7; exit 0; }
-	DISABLED: () { DISABLED $*; }
-	DISABLE   () { DISABLED $*; }
-	DISABLE:  () { DISABLED $*; }
-
-	TESTDIR='/tmp'
-	TESTFILE='(STDIN)'
-
-	echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD
-	MYDIR='...test'
-	MYFILE='...tmtest.sub.conf'
-	. '...tmtest.sub.conf'
-
-
-	echo PREPARE >&7
-
-	STDOUT () { exit 0; }
-	STDOUT: () { exit 0; }
-	STDERR () { exit 0; }
-	STDERR: () { exit 0; }
-	RESULT () { exit 0; }
-	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
-
-	echo 'RUNNING: (STDIN)' >&7
-	MYDIR='/tmp'
-	MYFILE='(STDIN)'
-	exec >&3 2>&5 3>&- 5>&-
-	LINENO=0
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 1
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 2
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 3
-	THE-SCRIPT THE-SCRIPT THE-SCRIPT 4
-
-
-	echo DONE >&7

Added: trunk/test/01-testfile/23-TestVarsDeep.test
===================================================================
--- trunk/test/01-testfile/23-TestVarsDeep.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/23-TestVarsDeep.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,27 @@
+# Make sure the variables are set up correctly when we are running a
+# test with a relative pathname.
+
+MKDIR do
+
+MKDIR di "$do/di"
+
+MKFILE tt "$do/di/tt.test" <<-'EOL'
+	echo MYDIR:    "$MYDIR"
+	echo MYFILE:   "$MYFILE"
+	echo TESTDIR:  "$TESTDIR"
+	echo TESTFILE: "$TESTFILE"
+EOL
+
+cd "$do"
+tmtest $config -o -q "di/tt.test" <<-EOL | REPLACE $do /tmp/DIR | INDENT
+
+STDOUT:
+    echo MYDIR:    "$MYDIR"
+    echo MYFILE:   "$MYFILE"
+    echo TESTDIR:  "$TESTDIR"
+    echo TESTFILE: "$TESTFILE"
+    STDOUT:
+    MYDIR: /tmp/DIR/di
+    MYFILE: /tmp/DIR/di/tt.test
+    TESTDIR: /tmp/DIR/di
+    TESTFILE: /tmp/DIR/di/tt.test

Added: trunk/test/01-testfile/24-TestVarsRoot.test
===================================================================
--- trunk/test/01-testfile/24-TestVarsRoot.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/24-TestVarsRoot.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,23 @@
+# Make sure the variables are set up correctly when we are running a
+# test with a relative pathname.
+
+MKFILE tt <<-'EOL'
+	echo MYDIR:    "$MYDIR"
+	echo MYFILE:   "$MYFILE"
+	echo TESTDIR:  "$TESTDIR"
+	echo TESTFILE: "$TESTFILE"
+EOL
+
+cd `dirname "$tt"`
+tmtest $args --all-files -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
+
+STDOUT:
+    echo MYDIR:    "$MYDIR"
+    echo MYFILE:   "$MYFILE"
+    echo TESTDIR:  "$TESTDIR"
+    echo TESTFILE: "$TESTFILE"
+    STDOUT:
+    MYDIR: /tmp
+    MYFILE: /tmp/FILE
+    TESTDIR: /tmp
+    TESTFILE: /tmp/FILE

Added: trunk/test/01-testfile/dumpscript/10-Stdout.test
===================================================================
--- trunk/test/01-testfile/dumpscript/10-Stdout.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/dumpscript/10-Stdout.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,53 @@
+# Ensures that the dumpscript is what we expect.
+# This is just so we don't surprise ourselves...  Any time you modify
+# template.sh, you should expect test to fail.
+
+# The --config directive disables reading config files from the directory
+# containing the named config file and all its parent directories.
+
+tmtest $args --dump-script - <<-EOL | FIX_SCRIPT
+	this test is never run but we do need to specify a file so tmtest
+	knows what config files to include.
+EOL
+
+STDOUT:
+	echo START >&FD
+	
+	ABORT ()  { echo "ABORTED: $*" >&FD; exit 0; }
+	ABORT: () { ABORT $*; }
+	
+	DISABLED  () { echo "DISABLED: $*" >&FD; exit 0; }
+	DISABLED: () { DISABLED $*; }
+	DISABLE   () { DISABLED $*; }
+	DISABLE:  () { DISABLED $*; }
+	
+	TESTDIR='/tmp'
+	TESTFILE='(STDIN)'
+	
+	echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD
+	MYDIR='...test'
+	MYFILE='...tmtest.sub.conf'
+	. '...tmtest.sub.conf'
+	
+	
+	echo PREPARE >&FD
+	
+	STDOUT () { exit 0; }
+	STDOUT: () { exit 0; }
+	STDERR () { exit 0; }
+	STDERR: () { exit 0; }
+	RESULT () { exit 0; }
+	RESULT: () { exit 0; }
+	MODIFY () { exit 0; }
+	MODIFY: () { exit 0; }
+	
+	echo 'RUNNING: (STDIN)' >&FD
+	MYDIR='/tmp'
+	MYFILE='(STDIN)'
+	exec >&FD FD>&FD FD>&- FD>&-
+	LINENO=0
+	this test is never run but we do need to specify a file so tmtest
+	knows what config files to include.
+	
+	
+	echo DONE >&FD

Added: trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,65 @@
+# Ensures we prepare tests properly even when the --config
+# file is entirely outside the testdir.
+
+# tmtest 0.94 and earlier had a bug where if you supplied a
+# trailing slash after a directory name on the command line,
+# it would include config files from that directory twice.
+# This test ensures that won't happen anymore.
+
+
+MKDIR dd
+
+MKFILE tt1 "$dd/tmtest.conf" <<'EOL'
+	config="yes!"
+EOL
+
+MKFILE tt2 "$dd/tt.test" <<'EOL'
+	echo "$config"
+EOL
+
+tmtest $args --dump-script "$dd/" | REPLACE "$dd" /tmp/DIR | FIX_SCRIPT
+
+STDOUT:
+	
+	Processing /tmp/DIR
+	echo START >&FD
+	
+	ABORT ()  { echo "ABORTED: $*" >&FD; exit 0; }
+	ABORT: () { ABORT $*; }
+	
+	DISABLED  () { echo "DISABLED: $*" >&FD; exit 0; }
+	DISABLED: () { DISABLED $*; }
+	DISABLE   () { DISABLED $*; }
+	DISABLE:  () { DISABLED $*; }
+	
+	TESTDIR='/tmp/DIR'
+	TESTFILE='/tmp/DIR/tt.test'
+	
+	echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD
+	MYDIR='...test'
+	MYFILE='...tmtest.sub.conf'
+	. '...tmtest.sub.conf'
+	echo 'CONFIG: /tmp/DIR/tmtest.conf' >&FD
+	MYDIR='/tmp/DIR'
+	MYFILE='/tmp/DIR/tmtest.conf'
+	. '/tmp/DIR/tmtest.conf'
+	
+	
+	echo PREPARE >&FD
+	
+	STDOUT () { exit 0; }
+	STDOUT: () { exit 0; }
+	STDERR () { exit 0; }
+	STDERR: () { exit 0; }
+	RESULT () { exit 0; }
+	RESULT: () { exit 0; }
+	MODIFY () { exit 0; }
+	MODIFY: () { exit 0; }
+	
+	echo 'RUNNING: /tmp/DIR/tt.test' >&FD
+	MYDIR='/tmp/DIR'
+	MYFILE='/tmp/DIR/tt.test'
+	exec >&FD FD>&FD FD>&- FD>&-
+	. '/tmp/DIR/tt.test'
+	
+	echo DONE >&FD

Added: trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,83 @@
+# Ensures we prepare tests properly even when the --config
+# file is entirely outside the testdir.
+
+# tmtest 0.94 and earlier had a bug where if you supplied a
+# trailing slash after a directory name on the command line,
+# it would include config files from that directory twice.
+# This test ensures that won't happen anymore.
+
+
+MKDIR do
+
+MKDIR di "$do/di"
+
+MKFILE cc1 "$do/tmtest.conf" <<'EOL'
+	config="yes!"
+EOL
+
+echo "$di/tmtest.conf" >> /tmp/tt
+
+MKFILE cc2 "$di/tmtest.conf" <<'EOL'
+	config="yes!"
+EOL
+
+MKFILE tt2 "$di/tt.test" <<'EOL'
+	echo "$config"
+EOL
+
+
+tmtest $args --dump-script "$di/.." | REPLACE "$do" /tmp/DIR | FIX_SCRIPT
+
+
+STDOUT:
+	
+	Processing /tmp/DIR
+	
+	Processing /tmp/DIR/di
+	echo START >&FD
+	
+	ABORT ()  { echo "ABORTED: $*" >&FD; exit 0; }
+	ABORT: () { ABORT $*; }
+	
+	DISABLED  () { echo "DISABLED: $*" >&FD; exit 0; }
+	DISABLED: () { DISABLED $*; }
+	DISABLE   () { DISABLED $*; }
+	DISABLE:  () { DISABLED $*; }
+	
+	TESTDIR='/tmp/DIR/di'
+	TESTFILE='/tmp/DIR/di/tt.test'
+	
+	echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD
+	MYDIR='...test'
+	MYFILE='...tmtest.sub.conf'
+	. '...tmtest.sub.conf'
+	echo 'CONFIG: /tmp/DIR/tmtest.conf' >&FD
+	MYDIR='/tmp/DIR'
+	MYFILE='/tmp/DIR/tmtest.conf'
+	. '/tmp/DIR/tmtest.conf'
+	echo 'CONFIG: /tmp/DIR/di/tmtest.conf' >&FD
+	MYDIR='/tmp/DIR/di'
+	MYFILE='/tmp/DIR/di/tmtest.conf'
+	. '/tmp/DIR/di/tmtest.conf'
+	
+	
+	echo PREPARE >&FD
+	
+	STDOUT () { exit 0; }
+	STDOUT: () { exit 0; }
+	STDERR () { exit 0; }
+	STDERR: () { exit 0; }
+	RESULT () { exit 0; }
+	RESULT: () { exit 0; }
+	MODIFY () { exit 0; }
+	MODIFY: () { exit 0; }
+	
+	echo 'RUNNING: /tmp/DIR/di/tt.test' >&FD
+	MYDIR='/tmp/DIR/di'
+	MYFILE='/tmp/DIR/di/tt.test'
+	exec >&FD FD>&FD FD>&- FD>&-
+	. '/tmp/DIR/di/tt.test'
+	
+	echo DONE >&FD
+RESULT: 0
+STDERR:

Added: trunk/test/01-testfile/dumpscript/13-BareParentDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/13-BareParentDir.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/dumpscript/13-BareParentDir.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,82 @@
+# Ensures we prepare tests properly even when the --config
+# file is entirely outside the testdir.
+
+# tmtest 0.94 and earlier had a bug where if you supplied a
+# trailing slash after a directory name on the command line,
+# it would include config files from that directory twice.
+# This test ensures that won't happen anymore.
+
+
+MKDIR do
+
+MKDIR di "$do/di"
+
+MKFILE cc1 "$do/tmtest.conf" <<'EOL'
+	config="yaksula"
+EOL
+
+MKFILE cc2 "$di/tmtest.conf" <<'EOL'
+	config="excellent"
+EOL
+
+MKFILE tt2 "$di/tt.test" <<'EOL'
+	echo "$config"
+EOL
+
+
+cd "$di"
+tmtest $args --dump-script ".." | REPLACE "$do" /tmp/DIR | FIX_SCRIPT
+
+
+STDOUT:
+	
+	Processing ./..
+	
+	Processing ./.
+	echo START >&FD
+	
+	ABORT ()  { echo "ABORTED: $*" >&FD; exit 0; }
+	ABORT: () { ABORT $*; }
+	
+	DISABLED  () { echo "DISABLED: $*" >&FD; exit 0; }
+	DISABLED: () { DISABLED $*; }
+	DISABLE   () { DISABLED $*; }
+	DISABLE:  () { DISABLED $*; }
+	
+	TESTDIR='/tmp/DIR/di'
+	TESTFILE='/tmp/DIR/di/tt.test'
+	
+	echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD
+	MYDIR='...test'
+	MYFILE='...tmtest.sub.conf'
+	. '...tmtest.sub.conf'
+	echo 'CONFIG: /tmp/DIR/tmtest.conf' >&FD
+	MYDIR='/tmp/DIR'
+	MYFILE='/tmp/DIR/tmtest.conf'
+	. '/tmp/DIR/tmtest.conf'
+	echo 'CONFIG: /tmp/DIR/di/tmtest.conf' >&FD
+	MYDIR='/tmp/DIR/di'
+	MYFILE='/tmp/DIR/di/tmtest.conf'
+	. '/tmp/DIR/di/tmtest.conf'
+	
+	
+	echo PREPARE >&FD
+	
+	STDOUT () { exit 0; }
+	STDOUT: () { exit 0; }
+	STDERR () { exit 0; }
+	STDERR: () { exit 0; }
+	RESULT () { exit 0; }
+	RESULT: () { exit 0; }
+	MODIFY () { exit 0; }
+	MODIFY: () { exit 0; }
+	
+	echo 'RUNNING: /tmp/DIR/di/tt.test' >&FD
+	MYDIR='/tmp/DIR/di'
+	MYFILE='/tmp/DIR/di/tt.test'
+	exec >&FD FD>&FD FD>&- FD>&-
+	. '/tmp/DIR/di/tt.test'
+	
+	echo DONE >&FD
+RESULT: 0
+STDERR:

Added: trunk/test/01-testfile/dumpscript/14-DeepDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/14-DeepDir.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/dumpscript/14-DeepDir.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,84 @@
+# Ensures we prepare tests properly even when the --config
+# file is entirely outside the testdir.
+
+# Note that this test assumes that MKDIR will create its directory
+# in /tmp.  If this is not the case, and the test is failing, just
+# add a replace directive to fix it and send me a patch.
+
+# tmtest 0.94 and earlier had a bug where if you supplied a
+# trailing slash after a directory name on the command line,
+# it would include config files from that directory twice.
+# This test ensures that won't happen anymore.
+
+
+MKDIR do
+
+MKDIR di "$do/di"
+
+MKFILE cc1 "$do/tmtest.conf" <<'EOL'
+	config="yaksula"
+EOL
+
+MKFILE cc2 "$di/tmtest.conf" <<'EOL'
+	config="excellent"
+EOL
+
+MKFILE tt2 "$di/tt.test" <<'EOL'
+	echo "$config"
+EOL
+
+
+cd `dirname "$do"`
+tmtest $args --dump-script "$(basename $do)/di" | REPLACE "$(basename $do)" DIR | FIX_SCRIPT
+
+
+STDOUT:
+	
+	Processing ./DIR/di
+	echo START >&FD
+	
+	ABORT ()  { echo "ABORTED: $*" >&FD; exit 0; }
+	ABORT: () { ABORT $*; }
+	
+	DISABLED  () { echo "DISABLED: $*" >&FD; exit 0; }
+	DISABLED: () { DISABLED $*; }
+	DISABLE   () { DISABLED $*; }
+	DISABLE:  () { DISABLED $*; }
+	
+	TESTDIR='/tmp/DIR/di'
+	TESTFILE='/tmp/DIR/di/tt.test'
+	
+	echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD
+	MYDIR='...test'
+	MYFILE='...tmtest.sub.conf'
+	. '...tmtest.sub.conf'
+	echo 'CONFIG: /tmp/DIR/tmtest.conf' >&FD
+	MYDIR='/tmp/DIR'
+	MYFILE='/tmp/DIR/tmtest.conf'
+	. '/tmp/DIR/tmtest.conf'
+	echo 'CONFIG: /tmp/DIR/di/tmtest.conf' >&FD
+	MYDIR='/tmp/DIR/di'
+	MYFILE='/tmp/DIR/di/tmtest.conf'
+	. '/tmp/DIR/di/tmtest.conf'
+	
+	
+	echo PREPARE >&FD
+	
+	STDOUT () { exit 0; }
+	STDOUT: () { exit 0; }
+	STDERR () { exit 0; }
+	STDERR: () { exit 0; }
+	RESULT () { exit 0; }
+	RESULT: () { exit 0; }
+	MODIFY () { exit 0; }
+	MODIFY: () { exit 0; }
+	
+	echo 'RUNNING: /tmp/DIR/di/tt.test' >&FD
+	MYDIR='/tmp/DIR/di'
+	MYFILE='/tmp/DIR/di/tt.test'
+	exec >&FD FD>&FD FD>&- FD>&-
+	. '/tmp/DIR/di/tt.test'
+	
+	echo DONE >&FD
+RESULT: 0
+STDERR:

Added: trunk/test/01-testfile/dumpscript/15-PathOps.test
===================================================================
--- trunk/test/01-testfile/dumpscript/15-PathOps.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/dumpscript/15-PathOps.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,60 @@
+# Specify a whole bunch of pathops.  Despite the pathops,
+# this should resolve to be the exact same test as 11-NamedDir.test.
+
+
+MKDIR dd
+
+MKFILE tt1 "$dd/tmtest.conf" <<'EOL'
+	config="yes!"
+EOL
+
+MKFILE tt2 "$dd/tt.test" <<'EOL'
+	echo "$config"
+EOL
+
+tmtest $args --dump-script "$dd//abc/./..//def/ghi//./../../" | REPLACE "$dd" /tmp/DIR | FIX_SCRIPT
+
+STDOUT:
+	
+	Processing /tmp/DIR
+	echo START >&FD
+	
+	ABORT ()  { echo "ABORTED: $*" >&FD; exit 0; }
+	ABORT: () { ABORT $*; }
+	
+	DISABLED  () { echo "DISABLED: $*" >&FD; exit 0; }
+	DISABLED: () { DISABLED $*; }
+	DISABLE   () { DISABLED $*; }
+	DISABLE:  () { DISABLED $*; }
+	
+	TESTDIR='/tmp/DIR'
+	TESTFILE='/tmp/DIR/tt.test'
+	
+	echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD
+	MYDIR='...test'
+	MYFILE='...tmtest.sub.conf'
+	. '...tmtest.sub.conf'
+	echo 'CONFIG: /tmp/DIR/tmtest.conf' >&FD
+	MYDIR='/tmp/DIR'
+	MYFILE='/tmp/DIR/tmtest.conf'
+	. '/tmp/DIR/tmtest.conf'
+	
+	
+	echo PREPARE >&FD
+	
+	STDOUT () { exit 0; }
+	STDOUT: () { exit 0; }
+	STDERR () { exit 0; }
+	STDERR: () { exit 0; }
+	RESULT () { exit 0; }
+	RESULT: () { exit 0; }
+	MODIFY () { exit 0; }
+	MODIFY: () { exit 0; }
+	
+	echo 'RUNNING: /tmp/DIR/tt.test' >&FD
+	MYDIR='/tmp/DIR'
+	MYFILE='/tmp/DIR/tt.test'
+	exec >&FD FD>&FD FD>&- FD>&-
+	. '/tmp/DIR/tt.test'
+	
+	echo DONE >&FD

Added: trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,83 @@
+# Ensures we prepare tests properly even when the --config
+# file is entirely outside the testdir.
+
+# Note that this test assumes that MKDIR will create its directory
+# in /tmp.  If this is not the case, and the test is failing, just
+# add a replace directive to fix it and send me a patch.
+
+# tmtest 0.94 and earlier had a bug where if you supplied a
+# trailing slash after a directory name on the command line,
+# it would include config files from that directory twice.
+# This test ensures that won't happen anymore.
+
+
+MKDIR do
+
+MKDIR di "$do/di"
+
+MKFILE cc1 "$do/tmtest.conf" <<'EOL'
+	config="yaksula"
+EOL
+
+MKFILE cc2 "$di/tmtest.conf" <<'EOL'
+	config="excellent"
+EOL
+
+MKFILE tt2 "$di/tt.test" <<'EOL'
+	echo "$config"
+EOL
+
+
+tmtest $args --dump-script "$do/di//../di" | REPLACE "$do" DIR | FIX_SCRIPT
+
+
+STDOUT:
+	
+	Processing DIR/di
+	echo START >&FD
+	
+	ABORT ()  { echo "ABORTED: $*" >&FD; exit 0; }
+	ABORT: () { ABORT $*; }
+	
+	DISABLED  () { echo "DISABLED: $*" >&FD; exit 0; }
+	DISABLED: () { DISABLED $*; }
+	DISABLE   () { DISABLED $*; }
+	DISABLE:  () { DISABLED $*; }
+	
+	TESTDIR='DIR/di'
+	TESTFILE='DIR/di/tt.test'
+	
+	echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD
+	MYDIR='...test'
+	MYFILE='...tmtest.sub.conf'
+	. '...tmtest.sub.conf'
+	echo 'CONFIG: DIR/tmtest.conf' >&FD
+	MYDIR='DIR'
+	MYFILE='DIR/tmtest.conf'
+	. 'DIR/tmtest.conf'
+	echo 'CONFIG: DIR/di/tmtest.conf' >&FD
+	MYDIR='DIR/di'
+	MYFILE='DIR/di/tmtest.conf'
+	. 'DIR/di/tmtest.conf'
+	
+	
+	echo PREPARE >&FD
+	
+	STDOUT () { exit 0; }
+	STDOUT: () { exit 0; }
+	STDERR () { exit 0; }
+	STDERR: () { exit 0; }
+	RESULT () { exit 0; }
+	RESULT: () { exit 0; }
+	MODIFY () { exit 0; }
+	MODIFY: () { exit 0; }
+	
+	echo 'RUNNING: DIR/di/tt.test' >&FD
+	MYDIR='DIR/di'
+	MYFILE='DIR/di/tt.test'
+	exec >&FD FD>&FD FD>&- FD>&-
+	. 'DIR/di/tt.test'
+	
+	echo DONE >&FD
+RESULT: 0
+STDERR:

Added: trunk/test/01-testfile/dumpscript/README
===================================================================
--- trunk/test/01-testfile/dumpscript/README	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/dumpscript/README	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,4 @@
+These tests verify that the testfile can be named on the command
+line in any way possible, yet each config file gets included
+exactly once and MYDIR and MYFILE are normalized and correct
+each time.

Added: trunk/test/01-testfile/dumpscript/tmtest.conf
===================================================================
--- trunk/test/01-testfile/dumpscript/tmtest.conf	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/01-testfile/dumpscript/tmtest.conf	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,14 @@
+# This tries to remove all the changing elements in the dumpscript.
+# Turns out there's a lot...
+
+FIX_SCRIPT ()
+{
+	sed \
+	-e "s/echo 'CONFIG: .*tmtest.sub.conf' .*/echo 'CONFIG: ...tmtest.sub.conf' >STATUSFD/" \
+	-e "s/MYDIR='.*test'/MYDIR='...test'/" \
+	-e "s/MYFILE='.*tmtest.sub.conf'/MYFILE='...tmtest.sub.conf'/" \
+	-e "s/\\. '.*tmtest.sub.conf'/. '...tmtest.sub.conf'/" \
+	-e "s/&[0-9]/\\&FD/g" -e "s/[0-9]>/FD>/g" \
+		| INDENT "\t"
+}
+

Modified: trunk/test/02-running/05-Running.test
===================================================================
--- trunk/test/02-running/05-Running.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/02-running/05-Running.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -55,16 +55,16 @@
 Processing ./.
 ok   mid.test 
 
-Processing ././sub
+Processing ./sub
 ok   sub.test 
 
 Processing ./..
 ok   sup.test 
 
-Processing ./../mid
+Processing ./.
 ok   mid.test 
 
-Processing ./../mid/sub
+Processing ./sub
 ok   sub.test 
 
 9 tests run, 9 successes, 0 failures.

Added: trunk/test/02-running/50-OpenFDsTest.test
===================================================================
--- trunk/test/02-running/50-OpenFDsTest.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/02-running/50-OpenFDsTest.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,20 @@
+# Ensure we don't leak fds to the running test.
+# Ideally, there would be NO open FDs.  This will be the case for tmtest 0.98.
+
+tmtest -o $CFG -q - <<-'EOL' | INDENT
+	for i in `seq 3 255`; do
+		exec 2>/dev/null
+		echo -n >&$i && echo open: $i
+	done
+EOL
+
+STDOUT:
+    for i in `seq 3 255`; do
+    exec 2>/dev/null
+    echo -n >&$i && echo open: $i
+    done
+    STDOUT:
+    open: 4
+    open: 6
+    open: 7
+    open: 10

Added: trunk/test/02-running/51-OpenFDsConfig.tst
===================================================================
--- trunk/test/02-running/51-OpenFDsConfig.tst	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/02-running/51-OpenFDsConfig.tst	2006-03-05 04:30:56 UTC (rev 103)
@@ -0,0 +1,40 @@
+# Ensure we don't leak fds to the running test.
+# Ideally, there would be NO open FDs.  This will be the case for tmtest 0.98.
+
+
+# creates a temporary directory DD:
+# /tmp/DD/tmtest.conf   -- stores the open fds in $openfds
+# /tmp/DD/tt.test       -- prints $openfds as its test result
+
+
+MKDIR dd
+
+MKFILE tt1 "$dd/tmtest.conf" <<'EOL'
+	openfds=$(
+		for i in `seq 3 255`; do
+			exec 2>/dev/null
+			echo -n >&$i && echo open: $i
+		done
+	)
+EOL
+
+
+MKFILE tt2 "$dd/tt.test" <<'EOL'
+	echo "$openfds"
+EOL
+
+while [ -f /tmp/s ]; do sleep 1; done
+
+tmtest $args -o "$dd" | INDENT
+
+
+STDOUT:
+    for i in `seq 3 255`; do
+    exec 2>/dev/null
+    echo -n >&$i && echo open: $i
+    done
+    STDOUT:
+    open: 4
+    open: 6
+    open: 7
+    open: 10

Modified: trunk/test/03-results/30-Binary.test
===================================================================
--- trunk/test/03-results/30-Binary.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/03-results/30-Binary.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -17,8 +17,6 @@
 tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
-
-Processing /tmp/FILE
 ok   /tmp/FILE 
 
 1 test run, 1 success, 0 failures.

Modified: trunk/test/03-results/31-BinaryFail.test
===================================================================
--- trunk/test/03-results/31-BinaryFail.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/03-results/31-BinaryFail.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -17,8 +17,6 @@
 tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
-
-Processing /tmp/FILE
 FAIL /tmp/FILE        O..  stdout differed
 
 1 test run, 0 successes, 1 failure.

Modified: trunk/test/03-results/32-BinaryLarge.test
===================================================================
--- trunk/test/03-results/32-BinaryLarge.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/03-results/32-BinaryLarge.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -28,8 +28,6 @@
 tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
-
-Processing /tmp/FILE
 ok   /tmp/FILE 
 
 1 test run, 1 success, 0 failures.

Modified: trunk/test/03-results/33-BinaryHuge.test
===================================================================
--- trunk/test/03-results/33-BinaryHuge.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/03-results/33-BinaryHuge.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -22,8 +22,6 @@
 tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
-
-Processing /tmp/FILE
 ok   /tmp/FILE 
 
 1 test run, 1 success, 0 failures.

Modified: trunk/test/04-diff/02-MultiDiff.test
===================================================================
--- trunk/test/04-diff/02-MultiDiff.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/04-diff/02-MultiDiff.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -18,7 +18,7 @@
 	test 2 wrong output
 EOF
 
-tmtest --all-files -p "$t1" "$t2"
+tmtest --all-files -d "$t1" "$t2"
 
 
 MODIFY:

Modified: trunk/test/04-diff/05-AbortDiff.test
===================================================================
--- trunk/test/04-diff/05-AbortDiff.test	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/04-diff/05-AbortDiff.test	2006-03-05 04:30:56 UTC (rev 103)
@@ -5,7 +5,7 @@
 
 
 
-tmtest --patch - <<-EOL
+tmtest --diff - <<-EOL
 	ABORT
 	echo "right output"
 	STDOUT:

Modified: trunk/test/tmtest.sub.conf
===================================================================
--- trunk/test/tmtest.sub.conf	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test/tmtest.sub.conf	2006-03-05 04:30:56 UTC (rev 103)
@@ -12,7 +12,6 @@
 # first sign of trouble and have the result code reported in RESULT.
 set -e
 
-
 # Include the standard tmtest functions
 . "$MYDIR/../tmlib.sh"
 

Modified: trunk/test.c
===================================================================
--- trunk/test.c	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test.c	2006-03-05 04:30:56 UTC (rev 103)
@@ -792,9 +792,10 @@
 
 
 /** Checks the actual results against the expected results.
+ * dispname is the name we should display for the test.
  */
 
-void test_results(struct test *test)
+void test_results(struct test *test, const char *dispname)
 {
     scanstate scanner;
     char scanbuf[MAX_LINE_LENGTH];
@@ -846,10 +847,10 @@
 
     if(!stdo && !stde && !exno) {
         test_successes++;
-        printf("ok   %s \n", get_testfile_name(test));
+        printf("ok   %s \n", convert_testfile_name(dispname));
     } else {
         test_failures++;
-        printf("FAIL %-25s ", get_testfile_name(test));
+        printf("FAIL %-25s ", convert_testfile_name(dispname));
         if(test->exitsignal) {
             printf("terminated by signal %d%s", test->exitsignal,
                     (test->exitcored ? " with core" : ""));
@@ -994,7 +995,7 @@
 	// know that MODIFY sections are going away in the
 	// next release anyway)
 	write_modified_file(outfd, infd, job);
-	return 0;
+	return 1;
 }
 
 

Modified: trunk/test.h
===================================================================
--- trunk/test.h	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/test.h	2006-03-05 04:30:56 UTC (rev 103)
@@ -74,7 +74,7 @@
 void scan_status_file(struct test *test);
 void test_command_copy(struct test *test, FILE *fp);
 
-void test_results(struct test *test);
+void test_results(struct test *test, const char *dispname);
 void dump_results(struct test *test);
 void print_test_summary();
 

Modified: trunk/tmlib.sh
===================================================================
--- trunk/tmlib.sh	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/tmlib.sh	2006-03-05 04:30:56 UTC (rev 103)
@@ -8,7 +8,6 @@
 # will be lost!
 
 
-# TODO: should these routines be prefixed by "TM"?
 # TODO: is there any way to get rid of MKFILE_EMPTY?  Can't MKFILE notice
 #       if read would block and, if so, just create an empty file.?
 
@@ -168,6 +167,11 @@
 # argument 1: varname, the name of the variable that will contain the new directory name.
 # argument 2: dirname, (optional) the name/fullpath to give the directory.
 #
+#	NOTE: unless you really know what you are doing, specifying argument2
+#   is a major security risk.  Always use the single argument version.
+#   The one exception is if you're creating a directory inside another
+#   directory that was created with the single arg.
+#
 # Examples:
 #
 # create a new directory with a random name in $TMPDIR or /tmp:
@@ -175,6 +179,9 @@
 #     MKDIR dn
 #     cd "$dn"
 #
+# TODO: should emulate mkdir -p too.  Right now tmtest forces you to
+# call MKDIR for each dir you want to create.  Too wordy.
+#
 
 MKDIR ()
 {
@@ -182,7 +189,7 @@
 	if [ -z "$name" ]; then
 		name=`mktemp -d -t tmtest.XXXXXX || ABORT MKDIR: could not mktemp`
 	else
-		[ -d $name ] || mkdir --mode 0600 $name || ABORT "MKDIR: could not 'mkdir \"$name\"'"
+		[ -d $name ] || mkdir --mode 0700 $name || ABORT "MKDIR: could not 'mkdir \"$name\"'"
 	fi
 
 	eval "$1='$name'"

Modified: trunk/tmtest.conf
===================================================================
--- trunk/tmtest.conf	2006-03-03 00:12:52 UTC (rev 102)
+++ trunk/tmtest.conf	2006-03-05 04:30:56 UTC (rev 103)
@@ -61,7 +61,7 @@
 # a particular function has been defined and include tmlib only
 # if it hasn't.
 
-. tmlib.sh
+. "$MYDIR/tmlib.sh"
 
 
 # We set OUTER_CONFIG_FILE so that we can check later that this file





From tmtest-commits at berlios.de  Sun Mar  5 06:07:14 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Sun, 5 Mar 2006 06:07:14 +0100
Subject: [Tmtest-commits] [104] trunk: Remove MODIFY from the template, update tests to match.
Message-ID: <200603050507.k2557Eeg018254@sheep.berlios.de>

Revision: 104
Author:   bronson
Date:     2006-03-05 06:07:12 +0100 (Sun, 05 Mar 2006)

Log Message:
-----------
Remove MODIFY from the template, update tests to match.

Modified Paths:
--------------
    trunk/template.sh
    trunk/test/01-testfile/dumpscript/10-Stdout.test
    trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test
    trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test
    trunk/test/01-testfile/dumpscript/13-BareParentDir.test
    trunk/test/01-testfile/dumpscript/14-DeepDir.test
    trunk/test/01-testfile/dumpscript/15-PathOps.test
    trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test
Modified: trunk/template.sh
===================================================================
--- trunk/template.sh	2006-03-05 04:30:56 UTC (rev 103)
+++ trunk/template.sh	2006-03-05 05:07:12 UTC (rev 104)
@@ -21,8 +21,6 @@
 STDERR: () { exit 0; }
 RESULT () { exit 0; }
 RESULT: () { exit 0; }
-MODIFY () { exit 0; }
-MODIFY: () { exit 0; }
 
 echo 'RUNNING: %(TESTFILE)' >&%(STATUSFD)
 MYDIR='%(TESTDIR)'

Modified: trunk/test/01-testfile/dumpscript/10-Stdout.test
===================================================================
--- trunk/test/01-testfile/dumpscript/10-Stdout.test	2006-03-05 04:30:56 UTC (rev 103)
+++ trunk/test/01-testfile/dumpscript/10-Stdout.test	2006-03-05 05:07:12 UTC (rev 104)
@@ -38,8 +38,6 @@
 	STDERR: () { exit 0; }
 	RESULT () { exit 0; }
 	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
 	
 	echo 'RUNNING: (STDIN)' >&FD
 	MYDIR='/tmp'

Modified: trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test	2006-03-05 04:30:56 UTC (rev 103)
+++ trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test	2006-03-05 05:07:12 UTC (rev 104)
@@ -53,8 +53,6 @@
 	STDERR: () { exit 0; }
 	RESULT () { exit 0; }
 	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
 	
 	echo 'RUNNING: /tmp/DIR/tt.test' >&FD
 	MYDIR='/tmp/DIR'

Modified: trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test	2006-03-05 04:30:56 UTC (rev 103)
+++ trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test	2006-03-05 05:07:12 UTC (rev 104)
@@ -69,8 +69,6 @@
 	STDERR: () { exit 0; }
 	RESULT () { exit 0; }
 	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
 	
 	echo 'RUNNING: /tmp/DIR/di/tt.test' >&FD
 	MYDIR='/tmp/DIR/di'

Modified: trunk/test/01-testfile/dumpscript/13-BareParentDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/13-BareParentDir.test	2006-03-05 04:30:56 UTC (rev 103)
+++ trunk/test/01-testfile/dumpscript/13-BareParentDir.test	2006-03-05 05:07:12 UTC (rev 104)
@@ -68,8 +68,6 @@
 	STDERR: () { exit 0; }
 	RESULT () { exit 0; }
 	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
 	
 	echo 'RUNNING: /tmp/DIR/di/tt.test' >&FD
 	MYDIR='/tmp/DIR/di'

Modified: trunk/test/01-testfile/dumpscript/14-DeepDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/14-DeepDir.test	2006-03-05 04:30:56 UTC (rev 103)
+++ trunk/test/01-testfile/dumpscript/14-DeepDir.test	2006-03-05 05:07:12 UTC (rev 104)
@@ -70,8 +70,6 @@
 	STDERR: () { exit 0; }
 	RESULT () { exit 0; }
 	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
 	
 	echo 'RUNNING: /tmp/DIR/di/tt.test' >&FD
 	MYDIR='/tmp/DIR/di'

Modified: trunk/test/01-testfile/dumpscript/15-PathOps.test
===================================================================
--- trunk/test/01-testfile/dumpscript/15-PathOps.test	2006-03-05 04:30:56 UTC (rev 103)
+++ trunk/test/01-testfile/dumpscript/15-PathOps.test	2006-03-05 05:07:12 UTC (rev 104)
@@ -48,8 +48,6 @@
 	STDERR: () { exit 0; }
 	RESULT () { exit 0; }
 	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
 	
 	echo 'RUNNING: /tmp/DIR/tt.test' >&FD
 	MYDIR='/tmp/DIR'

Modified: trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test	2006-03-05 04:30:56 UTC (rev 103)
+++ trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test	2006-03-05 05:07:12 UTC (rev 104)
@@ -69,8 +69,6 @@
 	STDERR: () { exit 0; }
 	RESULT () { exit 0; }
 	RESULT: () { exit 0; }
-	MODIFY () { exit 0; }
-	MODIFY: () { exit 0; }
 	
 	echo 'RUNNING: DIR/di/tt.test' >&FD
 	MYDIR='DIR/di'





From tmtest-commits at berlios.de  Sun Mar  5 16:30:58 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Sun, 5 Mar 2006 16:30:58 +0100
Subject: [Tmtest-commits] [105] trunk: First part of the modify purge is complete: rewrite or
Message-ID: <200603051530.k25FUwEq001874@sheep.berlios.de>

Revision: 105
Author:   bronson
Date:     2006-03-05 16:30:53 +0100 (Sun, 05 Mar 2006)

Log Message:
-----------
First part of the modify purge is complete: rewrite or remove all tests
that depend on it.

Modified Paths:
--------------
    trunk/CHANGES
    trunk/test/02-running/11-Assert.test
    trunk/test/02-running/13-DisabledDir.test
    trunk/test/02-running/14-AbortConf.test
    trunk/test/02-running/15-DisabledDir.test
    trunk/test/02-running/16-ConfigError.test
    trunk/test/02-running/17-ConfigError.test
    trunk/test/02-running/18-TestError.test
    trunk/test/02-running/21-QuoteFile.test
    trunk/test/03-results/11-NoNLOutput.test
    trunk/test/03-results/11-NoNLOutput2.test
    trunk/test/04-diff/01-Diff.test
    trunk/test/04-diff/02-MultiDiff.test
    trunk/test/04-diff/05-AbortDiff.test
    trunk/test/04-diff/05-DisableDiff.test
    trunk/test/04-diff/06-AbortDiff2.test
    trunk/test/04-diff/06-DisableDiff2.test
    trunk/test/04-diff/07-AbortDiff3.test
    trunk/test/04-diff/07-DisableDiff3.test
    trunk/test/04-diff/08-AbortDiff4.test
    trunk/test/04-diff/08-DisableDiff4.test
    trunk/test/04-diff/09-MultiLevelDiff.test
    trunk/test/04-diff/10-Patch.test
    trunk/test/04-diff/11-MultiPatch.test
    trunk/test/04-diff/12-MultiLevelPatch.test
    trunk/test/04-diff/13-MultiLevelPatch.test
    trunk/test/04-diff/17-ConfigError.test
    trunk/test/README

Added Paths:
-----------
    trunk/test/02-running/05-Abort.test
    trunk/test/02-running/05-Disable.test
    trunk/test/02-running/06-Abort2.test
    trunk/test/02-running/06-Disable2.test
    trunk/test/02-running/07-Abort3.test
    trunk/test/02-running/07-Disable3.test
    trunk/test/02-running/08-Abort4.test
    trunk/test/02-running/08-Disable4.test

Removed Paths:
-------------
    trunk/examples/docs/Modify1.test
    trunk/examples/docs/Modify2.test
    trunk/examples/docs/Modify3.test
    trunk/test/03-results/05-Abort.test
    trunk/test/03-results/05-Disable.test
    trunk/test/03-results/06-Abort2.test
    trunk/test/03-results/06-Disable2.test
    trunk/test/03-results/07-Abort3.test
    trunk/test/03-results/07-Disable3.test
    trunk/test/03-results/08-Abort4.test
    trunk/test/03-results/08-Disable4.test
    trunk/test/03-results/09-NoNLMod.test
    trunk/test/03-results/20-Modify.test
    trunk/test/03-results/21-Modify.test
    trunk/test/03-results/22-Modify2.test
    trunk/test/03-results/23-Modify2.test
    trunk/test/03-results/24-Modify2.test
    trunk/test/03-results/25-Modify3.test
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/CHANGES	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,3 +1,5 @@
+- Got rid of MODIFY clauses.  Use INDENT, REPLACE, or sed instead.
+
 Released 0.94 on 2 Mar 2006
 - NOTE: Bash3 has made it so that the regex can not appear on the same line as
   the MODIFY keyword.  I updated all tests and accelerated MODIFY deprecation.

Deleted: trunk/examples/docs/Modify1.test
===================================================================
--- trunk/examples/docs/Modify1.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/examples/docs/Modify1.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,5 +0,0 @@
-echo RESULT
-MODIFY:
-   s/^(.)/   $1/
-STDOUT:
-   RESULT

Deleted: trunk/examples/docs/Modify2.test
===================================================================
--- trunk/examples/docs/Modify2.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/examples/docs/Modify2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,7 +0,0 @@
-# This is from http://tmtest.berlios.de/wiki/index.php/MODIFY
-
-echo RESULT
-MODIFY:
-   s/^RESULT/xRESULT/
-STDOUT:
-xRESULT

Deleted: trunk/examples/docs/Modify3.test
===================================================================
--- trunk/examples/docs/Modify3.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/examples/docs/Modify3.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,7 +0,0 @@
-# This is from http://tmtest.berlios.de/wiki/index.php/MODIFY
-
-date
-MODIFY:
-  s/... +... +[0-9]?[0-9] +[0-9]?[0-9]:[0-9][0-9]:[0-9][0-9] +... +20[0-9][0-9]/date date date/
-STDOUT:
-date date date

Copied: trunk/test/02-running/05-Abort.test (from rev 88, trunk/test/03-results/05-Abort.test)
===================================================================
--- trunk/test/03-results/05-Abort.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/02-running/05-Abort.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -0,0 +1,19 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is aborted.
+
+
+
+tmtest -q - <<-EOL
+	ABORT
+	echo "right output"
+	STDOUT:
+	right output
+EOL
+
+
+STDOUT:
+ABRT (STDIN)                   
+
+1 test run, 0 successes, 1 failure.

Copied: trunk/test/02-running/05-Disable.test (from rev 88, trunk/test/03-results/05-Disable.test)
===================================================================
--- trunk/test/03-results/05-Disable.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/02-running/05-Disable.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -0,0 +1,19 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is disabled.
+
+
+
+tmtest -q - <<-EOL
+	DISABLED
+	echo "right output"
+	STDOUT:
+	right output
+EOL
+
+
+STDOUT:
+dis  (STDIN)                   
+
+1 test run, 0 successes, 0 failures.

Copied: trunk/test/02-running/06-Abort2.test (from rev 88, trunk/test/03-results/06-Abort2.test)
===================================================================
--- trunk/test/03-results/06-Abort2.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/02-running/06-Abort2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -0,0 +1,19 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is aborted and gives a reason.
+
+
+tmtest -q - <<-EOL
+	ABORT: This is the reason
+	echo "right output"
+	STDOUT:
+	wrong output
+EOL
+
+
+STDERR:
+STDOUT:
+ABRT (STDIN)                   This is the reason
+
+1 test run, 0 successes, 1 failure.

Copied: trunk/test/02-running/06-Disable2.test (from rev 88, trunk/test/03-results/06-Disable2.test)
===================================================================
--- trunk/test/03-results/06-Disable2.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/02-running/06-Disable2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -0,0 +1,19 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is disabled and gives a reason.
+
+
+tmtest -q - <<-EOL
+	DISABLED: This is the reason
+	echo "right output"
+	STDOUT:
+	wrong output
+EOL
+
+
+STDERR:
+STDOUT:
+dis  (STDIN)                   This is the reason
+
+1 test run, 0 successes, 0 failures.

Copied: trunk/test/02-running/07-Abort3.test (from rev 88, trunk/test/03-results/07-Abort3.test)
===================================================================
--- trunk/test/03-results/07-Abort3.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/02-running/07-Abort3.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -0,0 +1,19 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is aborted but output is selected.
+
+
+tmtest -q -o - <<-EOL
+	ABORT This is the reason
+	echo "right output"
+	STDOUT:
+	wrong output
+EOL
+
+
+STDOUT:
+ABORT This is the reason
+echo "right output"
+STDERR:
+ERROR Test was aborted: This is the reason

Copied: trunk/test/02-running/07-Disable3.test (from rev 88, trunk/test/03-results/07-Disable3.test)
===================================================================
--- trunk/test/03-results/07-Disable3.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/02-running/07-Disable3.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -0,0 +1,19 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is disabled but output is selected.
+
+
+tmtest -q -o - <<-EOL
+	DISABLED This is the reason
+	echo "right output"
+	STDOUT:
+	wrong output
+EOL
+
+
+STDOUT:
+DISABLED This is the reason
+echo "right output"
+STDERR:
+ERROR Test is disabled: This is the reason

Copied: trunk/test/02-running/08-Abort4.test (from rev 88, trunk/test/03-results/08-Abort4.test)
===================================================================
--- trunk/test/03-results/08-Abort4.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/02-running/08-Abort4.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -0,0 +1,24 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is aborted and gives 
+# only whitespace as a reason.
+
+# this is really weird...  I would expect the colon to be printed
+# because we DO have a disabled reason -- it's just empty.  But
+# for some reason it's not.  I'd like to know why.  TODO
+# dis  (STDIN)                   :    
+
+
+tmtest -q - <<-EOL
+	ABORT: "   "
+	echo "right output"
+	STDOUT:
+	wrong output
+EOL
+
+
+STDOUT:
+ABRT (STDIN)                   
+
+1 test run, 0 successes, 1 failure.

Copied: trunk/test/02-running/08-Disable4.test (from rev 88, trunk/test/03-results/08-Disable4.test)
===================================================================
--- trunk/test/03-results/08-Disable4.test	2006-02-28 00:50:58 UTC (rev 88)
+++ trunk/test/02-running/08-Disable4.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -0,0 +1,24 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is disabled and gives 
+# only whitespace as a reason.
+
+# this is really weird...  I would expect the colon to be printed
+# because we DO have a disabled reason -- it's just empty.  But
+# for some reason it's not.  I'd like to know why.  TODO
+# dis  (STDIN)                   :    
+
+
+tmtest -q - <<-EOL
+	DISABLED: "   "
+	echo "right output"
+	STDOUT:
+	wrong output
+EOL
+
+
+STDOUT:
+dis  (STDIN)                   
+
+1 test run, 0 successes, 0 failures.

Modified: trunk/test/02-running/11-Assert.test
===================================================================
--- trunk/test/02-running/11-Assert.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/02-running/11-Assert.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,20 +1,22 @@
+# Ensure ABORT works.
+#
+# The wrong line number is displayed when the test is fed on stdin
+# as it is here.  It's a bash3ism, see BUGS.
+# Furthermore, the filename and line are never even displayed
+# on bash2.  Therefore, just wipe the filename and line nuber out
+# completely and this test should pass everywhere.
+
+
 cd "$TESTDIR"
-tmtest $CFG -q - <<-EOL
+tmtest $CFG -q - <<-EOL | sed -re "s/ on.*line [0-9]+/ on line LL/"
 	ASSERT -1 -eq 1
 	echo it ran
 	STDOUT:
 	it ran
 EOL
 
-# The wrong line number is displayed when the test is fed on stdin
-# as it is here.  It's a bash3ism, see BUGS.
-# Furthermore, the filename and line are never even displayed
-# on bash2.  Therefore, just wipe the filename and line nuber out
-# completely and this test should pass everywhere.
-MODIFY:
-  s/ on.*line \d+//
 
 STDOUT:
-ABRT (STDIN)                   assertion failed: "-1 -eq 1"
+ABRT (STDIN)                   assertion failed on line LL: "-1 -eq 1"
 
 1 test run, 0 successes, 1 failure.

Modified: trunk/test/02-running/13-DisabledDir.test
===================================================================
--- trunk/test/02-running/13-DisabledDir.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/02-running/13-DisabledDir.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -19,16 +19,14 @@
 	he
 EOs
 
-tmtest $CFG -q
+tmtest $CFG -q | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY:
-  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
 STDOUT:
 
 Processing .
-dis  t1.test                   by TMTEST.CONF
-dis  t2.test                   by TMTEST.CONF
+dis  t1.test                   by /tmp/DIR/tmtest.conf
+dis  t2.test                   by /tmp/DIR/tmtest.conf
 
 2 tests run, 0 successes, 0 failures.

Modified: trunk/test/02-running/14-AbortConf.test
===================================================================
--- trunk/test/02-running/14-AbortConf.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/02-running/14-AbortConf.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -22,15 +22,13 @@
 	he
 EOs
 
-tmtest $CFG -q
+tmtest $CFG -q | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY:
-  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
 STDOUT:
 
 Processing .
-ABRT t1.test                   by TMTEST.CONF: bail from config
+ABRT t1.test                   by /tmp/DIR/tmtest.conf: bail from config
 
 1 test run, 0 successes, 1 failure.

Modified: trunk/test/02-running/15-DisabledDir.test
===================================================================
--- trunk/test/02-running/15-DisabledDir.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/02-running/15-DisabledDir.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -20,16 +20,14 @@
 	he
 EOs
 
-tmtest $CFG -q
+tmtest $CFG -q | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY:
-  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
 STDOUT:
 
 Processing .
-dis  t1.test                   by TMTEST.CONF: this is the reason
-dis  t2.test                   by TMTEST.CONF: this is the reason
+dis  t1.test                   by /tmp/DIR/tmtest.conf: this is the reason
+dis  t2.test                   by /tmp/DIR/tmtest.conf: this is the reason
 
 2 tests run, 0 successes, 0 failures.

Modified: trunk/test/02-running/16-ConfigError.test
===================================================================
--- trunk/test/02-running/16-ConfigError.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/02-running/16-ConfigError.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,6 +1,10 @@
 # Ensures that even if config files generate errors, tests will
 # still try to run.  Config file errors go to stderr.
 
+# TODO: figure out how to rewrite stderr.  That may require some
+# assistance from tmtest...  After 0.98's streaming changes though.
+# 	tmtest $CFG -q 2> >( REPLACE "$dir" /tmp/DIR >&2 )
+
 MKDIR dir
 cd "$dir"
 
@@ -21,13 +25,13 @@
 	he
 EOs
 
-tmtest $CFG -q
+tmtest $CFG -q 2>&1 | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY:
-  s/^\/.*\/tmtest.conf/TMTEST.CONF/
 STDOUT:
+/tmp/DIR/tmtest.conf: line 2: dotheyspeakbocceonwhat: command not found
+/tmp/DIR/tmtest.conf: line 2: dotheyspeakbocceonwhat: command not found
 
 Processing .
 ok   t1.test 
@@ -35,5 +39,3 @@
 
 2 tests run, 2 successes, 0 failures.
 STDERR:
-TMTEST.CONF: line 2: dotheyspeakbocceonwhat: command not found
-TMTEST.CONF: line 2: dotheyspeakbocceonwhat: command not found

Modified: trunk/test/02-running/17-ConfigError.test
===================================================================
--- trunk/test/02-running/17-ConfigError.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/02-running/17-ConfigError.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -2,6 +2,10 @@
 # config files which mark us pedantic.  This should preven the
 # tests from being run if there are config errors.
 
+# TODO: this pipes stderr to stdout so it can be rewritten.
+# That's bad news and needs to be fixed.
+
+
 MKDIR dir
 cd "$dir"
 
@@ -23,20 +27,17 @@
 	he
 EOs
 
-tmtest $CFG -q
+tmtest $CFG -q 2>&1 | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY:
-	s/^\/.*\/tmtest.conf/TMTEST.CONF/
-	s/ in \/.*\/tmtest.conf/ in TMTEST.CONF/
 STDOUT:
+/tmp/DIR/tmtest.conf: line 3: dotheyspeakbocceonwhat: command not found
+/tmp/DIR/tmtest.conf: line 3: dotheyspeakbocceonwhat: command not found
 
 Processing .
-ERR  t1.test                   error in TMTEST.CONF
-ERR  t2.test                   error in TMTEST.CONF
+ERR  t1.test                   error in /tmp/DIR/tmtest.conf
+ERR  t2.test                   error in /tmp/DIR/tmtest.conf
 
 2 tests run, 0 successes, 2 failures.
 STDERR:
-TMTEST.CONF: line 3: dotheyspeakbocceonwhat: command not found
-TMTEST.CONF: line 3: dotheyspeakbocceonwhat: command not found

Modified: trunk/test/02-running/18-TestError.test
===================================================================
--- trunk/test/02-running/18-TestError.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/02-running/18-TestError.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,7 +1,7 @@
 # Sees what happens when we're in pedantic mode and there's an error
 # in the test file.
 
-tmtest $args -o - <<-EOL
+tmtest $args -o - <<-EOL | sed -re "s/: line [0-9]+:/: line BLAH:/" | INDENT "  "
 	set -e
 	iusedtobullseyewompratsinmypants
 	echo it ran
@@ -9,10 +9,6 @@
 	it ran
 EOL
 
-# stupid bash3 won't allow LINENO=0 to set the proper lineno.
-MODIFY:
-  s/: line \d+:/: line BLAH:/
-  s/^(\S)/  $1/
 
 STDOUT:
   set -e

Modified: trunk/test/02-running/21-QuoteFile.test
===================================================================
--- trunk/test/02-running/21-QuoteFile.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/02-running/21-QuoteFile.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -16,12 +16,10 @@
 	hi
 EOs
 
-tmtest $CFG -q
+tmtest $CFG -q | REPLACE "$dir" /tmp/DIR
 rm "vl'hurg.test" '12".test'
 
 
-MODIFY:
-  s/ by \/.*\/tmtest.conf/ by TMTEST.CONF/
 STDOUT:
 
 Processing .

Deleted: trunk/test/03-results/05-Abort.test
===================================================================
--- trunk/test/03-results/05-Abort.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/05-Abort.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,24 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a test is aborted.
-
-
-
-tmtest -q - <<-EOL
-	ABORT
-	echo "right output"
-	STDOUT:
-	right output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
-ABRT (STDIN)                   
-
-1 test run, 0 successes, 1 failure.

Deleted: trunk/test/03-results/05-Disable.test
===================================================================
--- trunk/test/03-results/05-Disable.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/05-Disable.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,24 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a test is disabled.
-
-
-
-tmtest -q - <<-EOL
-	DISABLED
-	echo "right output"
-	STDOUT:
-	right output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
-dis  (STDIN)                   
-
-1 test run, 0 successes, 0 failures.

Deleted: trunk/test/03-results/06-Abort2.test
===================================================================
--- trunk/test/03-results/06-Abort2.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/06-Abort2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,24 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a test is aborted and gives a reason.
-
-
-tmtest -q - <<-EOL
-	ABORT: This is the reason
-	echo "right output"
-	STDOUT:
-	wrong output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDERR:
-STDOUT:
-ABRT (STDIN)                   This is the reason
-
-1 test run, 0 successes, 1 failure.

Deleted: trunk/test/03-results/06-Disable2.test
===================================================================
--- trunk/test/03-results/06-Disable2.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/06-Disable2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,24 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a test is disabled and gives a reason.
-
-
-tmtest -q - <<-EOL
-	DISABLED: This is the reason
-	echo "right output"
-	STDOUT:
-	wrong output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDERR:
-STDOUT:
-dis  (STDIN)                   This is the reason
-
-1 test run, 0 successes, 0 failures.

Deleted: trunk/test/03-results/07-Abort3.test
===================================================================
--- trunk/test/03-results/07-Abort3.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/07-Abort3.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,24 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a test is aborted but output is selected.
-
-
-tmtest -q -o - <<-EOL
-	ABORT This is the reason
-	echo "right output"
-	STDOUT:
-	wrong output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
-ABORT This is the reason
-echo "right output"
-STDERR:
-ERROR Test was aborted: This is the reason

Deleted: trunk/test/03-results/07-Disable3.test
===================================================================
--- trunk/test/03-results/07-Disable3.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/07-Disable3.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,24 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a test is disabled but output is selected.
-
-
-tmtest -q -o - <<-EOL
-	DISABLED This is the reason
-	echo "right output"
-	STDOUT:
-	wrong output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
-DISABLED This is the reason
-echo "right output"
-STDERR:
-ERROR Test is disabled: This is the reason

Deleted: trunk/test/03-results/08-Abort4.test
===================================================================
--- trunk/test/03-results/08-Abort4.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/08-Abort4.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,29 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a test is aborted and gives 
-# only whitespace as a reason.
-
-# this is really weird...  I would expect the colon to be printed
-# because we DO have a disabled reason -- it's just empty.  But
-# for some reason it's not.  I'd like to know why.  TODO
-# dis  (STDIN)                   :    
-
-
-tmtest -q - <<-EOL
-	ABORT: "   "
-	echo "right output"
-	STDOUT:
-	wrong output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
-ABRT (STDIN)                   
-
-1 test run, 0 successes, 1 failure.

Deleted: trunk/test/03-results/08-Disable4.test
===================================================================
--- trunk/test/03-results/08-Disable4.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/08-Disable4.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,29 +0,0 @@
-# author: Scott Bronson
-# date:   14 Nov 2004
-
-# Verifies what happens when a test is disabled and gives 
-# only whitespace as a reason.
-
-# this is really weird...  I would expect the colon to be printed
-# because we DO have a disabled reason -- it's just empty.  But
-# for some reason it's not.  I'd like to know why.  TODO
-# dis  (STDIN)                   :    
-
-
-tmtest -q - <<-EOL
-	DISABLED: "   "
-	echo "right output"
-	STDOUT:
-	wrong output
-EOL
-
-
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
-STDOUT:
-dis  (STDIN)                   
-
-1 test run, 0 successes, 0 failures.

Deleted: trunk/test/03-results/09-NoNLMod.test
===================================================================
--- trunk/test/03-results/09-NoNLMod.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/09-NoNLMod.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,27 +0,0 @@
-# Scott Bronson
-# 26 Feb 2006
-#
-# Ensures that a test's stdout need not end in "\n" for the test
-# to pass (see --no-trailing-newline in testfile(5).  This adds a
-# modify clause because, alas, using a modify clause changes the
-# code path for the comparison.  This is one reason why modify
-# clauses are evil...
-#
-# Also see: 09-NoNL.test
-#
-# (back when we were parsing tests using re2c, lines needed to be
-# less than BUFSIZ and the results always had to end in a newline).
-
-DISABLED "MODIFY won't work here."
-
-tmtest -q - <<-EOL
-    echo -n Howdy
-    MODIFY:
-      s/How/Wen/
-    STDOUT: -n
-    Wendy
-EOL
-STDOUT: 
-ok   (STDIN)
-
-1 test run, 1 success, 0 failures.

Modified: trunk/test/03-results/11-NoNLOutput.test
===================================================================
--- trunk/test/03-results/11-NoNLOutput.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/11-NoNLOutput.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -9,15 +9,12 @@
 # (back when we were parsing tests using re2c, lines needed to be
 # less than BUFSIZ and the results always had to end in a newline).
 
-tmtest -o -q - <<-EOL
+tmtest -o -q - <<-EOL | INDENT "   "
 	echo -n Howdy
 	STDOUT: -n
 	Howdy
 EOL
 
-MODIFY:
-   s/^(.)/   $1/
-
 STDOUT:
    echo -n Howdy
    STDOUT: -n

Modified: trunk/test/03-results/11-NoNLOutput2.test
===================================================================
--- trunk/test/03-results/11-NoNLOutput2.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/11-NoNLOutput2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -9,14 +9,12 @@
 # (back when we were parsing tests using re2c, lines needed to be
 # less than BUFSIZ and the results always had to end in a newline).
 
-tmtest -o -q - <<-EOL
+tmtest -o -q - <<-EOL | INDENT "   "
 	echo -n Howdy
 	STDOUT: --no-trailing-newline
 	Howdy
 EOL
 
-MODIFY:
-   s/^(.)/   $1/
 
 STDOUT:
    echo -n Howdy

Deleted: trunk/test/03-results/20-Modify.test
===================================================================
--- trunk/test/03-results/20-Modify.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/20-Modify.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,14 +0,0 @@
-# Ensures a simple substitution works.
-
-
-tmtest -q - <<-EOL
-	echo Howdy
-	MODIFY:
-      s/Howdy/HOWDY/
-	STDOUT :
-	HOWDY
-EOL
-STDOUT:
-ok   (STDIN) 
-
-1 test run, 1 success, 0 failures.

Deleted: trunk/test/03-results/21-Modify.test
===================================================================
--- trunk/test/03-results/21-Modify.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/21-Modify.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,14 +0,0 @@
-# Ensures a simple substitution works, even when it's not
-# on the same line as the section name.
-
-tmtest -q - <<-EOL
-	echo Howdy
-	MODIFY:
-		s/Howdy/HOWDY/
-	STDOUT:
-	HOWDY
-EOL
-STDOUT:
-ok   (STDIN) 
-
-1 test run, 1 success, 0 failures.

Deleted: trunk/test/03-results/22-Modify2.test
===================================================================
--- trunk/test/03-results/22-Modify2.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/22-Modify2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,15 +0,0 @@
-# Ensures all 3 substitutions work.
-
-tmtest -q - <<-EOL
-	echo Howdy Hi Hody
-	MODIFY :
-		s/Howdy/HOWDY/
-		s/Hody/HODY/
-		s/Hi/HI/
-	STDOUT :
-	HOWDY HI HODY
-EOL
-STDOUT:
-ok   (STDIN) 
-
-1 test run, 1 success, 0 failures.

Deleted: trunk/test/03-results/23-Modify2.test
===================================================================
--- trunk/test/03-results/23-Modify2.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/23-Modify2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,15 +0,0 @@
-# Ensures multiple substitutions work with multiple options.
-
-tmtest -q - <<-EOL
-	echo hoWdY Hody Hi Hody
-	MODIFY :
-		s/Howdy/HOWDY/i
-		s/Hody/HODY/g
-		s/hi/HI/
-	STDOUT :
-	HOWDY HODY Hi HODY
-EOL
-STDOUT:
-ok   (STDIN) 
-
-1 test run, 1 success, 0 failures.

Deleted: trunk/test/03-results/24-Modify2.test
===================================================================
--- trunk/test/03-results/24-Modify2.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/24-Modify2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,13 +0,0 @@
-tmtest -q - <<-EOL
-	echo hoWdY Hody Hi Hody
-	MODIFY :
-		s/Howdy/HOWDY/i
-		s/Hody/HODY/g
-		s/hi/HI/
-	STDOUT :
-	HOWDY HODY Hi HODY
-EOL
-STDOUT:
-ok   (STDIN) 
-
-1 test run, 1 success, 0 failures.

Deleted: trunk/test/03-results/25-Modify3.test
===================================================================
--- trunk/test/03-results/25-Modify3.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/03-results/25-Modify3.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,25 +0,0 @@
-# Ensures substitutions work on multiple lines.
-
-tmtest -q - <<-EOL1
-	cat <<-EOL2
-		Cat fud. Fud.  FUD.  fUd.
-		Look at me!  I'm a cowboy.
-		Howdy howdy howdy.
-		And more cat Fud.  high.
-	EOL2
-
-	MODIFY :
-		s/Howdy/HOWDY/i
-		s/fud/FUD/gi
-		s/hi/HI/
-	STDOUT :
-	Cat FUD. FUD.  FUD.  FUD.
-	Look at me!  I'm a cowboy.
-	HOWDY howdy howdy.
-	And more cat FUD.  HIgh.
-EOL1
-
-STDOUT:
-ok   (STDIN) 
-
-1 test run, 1 success, 0 failures.

Modified: trunk/test/04-diff/01-Diff.test
===================================================================
--- trunk/test/04-diff/01-Diff.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/01-Diff.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -7,20 +7,15 @@
 # updated for 2.0 on 27 Jan 2005
 
 
-tmtest --diff - <<-EOL
+tmtest --diff - <<-EOL | FIX_DIFF
     echo "right output"
     STDOUT:
     wrong output
 EOL
 
 
-MODIFY:
-    s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-    s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
 STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1,5 @@
      echo "right output"

Modified: trunk/test/04-diff/02-MultiDiff.test
===================================================================
--- trunk/test/04-diff/02-MultiDiff.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/02-MultiDiff.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -18,22 +18,18 @@
 	test 2 wrong output
 EOF
 
-tmtest --all-files -d "$t1" "$t2"
+tmtest --all-files -d "$t1" "$t2" | FIX_DIFF
 
 
-MODIFY:
-  s/^\-\-\-.*\/tmp\/tmtest.*/--- \/tmp\/testfile DATE TIME TZ/,
-  s/^\+\+\+.*/+++ - DATE TIME TZ/
-
 STDOUT:
---- /tmp/testfile DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1,3 @@
  echo "test 1 right output"
  STDOUT:
 -test 1 wrong output
 +test 1 right output
---- /tmp/testfile DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1,3 @@
  echo "test 2 right output"

Modified: trunk/test/04-diff/05-AbortDiff.test
===================================================================
--- trunk/test/04-diff/05-AbortDiff.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/05-AbortDiff.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -5,7 +5,7 @@
 
 
 
-tmtest --diff - <<-EOL
+tmtest --diff - <<-EOL | FIX_DIFF
 	ABORT
 	echo "right output"
 	STDOUT:
@@ -13,13 +13,8 @@
 EOL
 
 
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
 STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,4 +1,2 @@
  ABORT

Modified: trunk/test/04-diff/05-DisableDiff.test
===================================================================
--- trunk/test/04-diff/05-DisableDiff.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/05-DisableDiff.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -5,7 +5,7 @@
 
 
 
-tmtest -d - <<-EOL
+tmtest -d - <<-EOL | FIX_DIFF
 	DISABLED
 	echo "right output"
 	STDOUT:
@@ -13,13 +13,9 @@
 EOL
 
 
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
 
-
 STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,4 +1,2 @@
  DISABLED

Modified: trunk/test/04-diff/06-AbortDiff2.test
===================================================================
--- trunk/test/04-diff/06-AbortDiff2.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/06-AbortDiff2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -4,7 +4,7 @@
 # Verifies what happens when a diff is aborted and gives a reason.
 
 
-tmtest -d - <<-EOL
+tmtest -d - <<-EOL | FIX_DIFF
 	ABORT: This is the reason
 	echo "right output"
 	STDOUT:
@@ -12,15 +12,10 @@
 EOL
 
 
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
 STDERR:
 ERROR Test was aborted: This is the reason
 STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,4 +1,2 @@
  ABORT: This is the reason

Modified: trunk/test/04-diff/06-DisableDiff2.test
===================================================================
--- trunk/test/04-diff/06-DisableDiff2.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/06-DisableDiff2.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -4,7 +4,7 @@
 # Verifies what happens when a diff is disabled and gives a reason.
 
 
-tmtest -d - <<-EOL
+tmtest -d - <<-EOL | FIX_DIFF
 	DISABLED: This is the reason
 	echo "right output"
 	STDOUT:
@@ -12,15 +12,11 @@
 EOL
 
 
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
 
-
 STDERR:
 ERROR Test is disabled: This is the reason
 STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,4 +1,2 @@
  DISABLED: This is the reason

Modified: trunk/test/04-diff/07-AbortDiff3.test
===================================================================
--- trunk/test/04-diff/07-AbortDiff3.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/07-AbortDiff3.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -6,7 +6,7 @@
 
 
 
-tmtest -d - <<-EOL
+tmtest -d - <<-EOL | FIX_DIFF
 	ABORT This is the reason
 	echo "right output"
 	STDOUT:
@@ -14,13 +14,8 @@
 EOL
 
 
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
 STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,4 +1,2 @@
  ABORT This is the reason

Modified: trunk/test/04-diff/07-DisableDiff3.test
===================================================================
--- trunk/test/04-diff/07-DisableDiff3.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/07-DisableDiff3.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -6,7 +6,7 @@
 
 
 
-tmtest -d - <<-EOL
+tmtest -d - <<-EOL | FIX_DIFF
 	DISABLED This is the reason
 	echo "right output"
 	STDOUT:
@@ -14,13 +14,8 @@
 EOL
 
 
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
 STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,4 +1,2 @@
  DISABLED This is the reason

Modified: trunk/test/04-diff/08-AbortDiff4.test
===================================================================
--- trunk/test/04-diff/08-AbortDiff4.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/08-AbortDiff4.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -8,7 +8,7 @@
 # printed after the "ERROR Test was aborted".  TODO.
 
 
-tmtest -d - <<-EOL
+tmtest -d - <<-EOL | FIX_DIFF
 	ABORT: "   "
 	echo "right output"
 	STDOUT:
@@ -16,13 +16,8 @@
 EOL
 
 
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
 STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,4 +1,2 @@
  ABORT: "   "

Modified: trunk/test/04-diff/08-DisableDiff4.test
===================================================================
--- trunk/test/04-diff/08-DisableDiff4.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/08-DisableDiff4.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -8,7 +8,7 @@
 # printed after the "ERROR Test is disabled".  TODO.
 
 
-tmtest -d - <<-EOL
+tmtest -d - <<-EOL | FIX_DIFF
 	DISABLED: "   "
 	echo "right output"
 	STDOUT:
@@ -16,13 +16,8 @@
 EOL
 
 
-MODIFY:
-	s/^\-\-\-.*/--- \/tmp\/STDIN-pid.unique DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-
-
 STDOUT:
---- /tmp/STDIN-pid.unique DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,4 +1,2 @@
  DISABLED: "   "

Modified: trunk/test/04-diff/09-MultiLevelDiff.test
===================================================================
--- trunk/test/04-diff/09-MultiLevelDiff.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/09-MultiLevelDiff.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -51,45 +51,41 @@
 EOL
 
 
-tmtest --all-files -d
+tmtest --all-files -d | FIX_DIFF
 
 rm -rf t.test one two
 
 
-MODIFY:
-  s/^\-\-\- .*/--- TESTFILE DATE TIME TZ/,
-  s/^\+\+\+.*/+++ - DATE TIME TZ/
-
 STDOUT:
---- TESTFILE DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1,3 @@
  echo "right output1"
  STDOUT:
 -wrong output
 +right output1
---- TESTFILE DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1,3 @@
  echo "right output2"
  STDOUT:
 -wrong output
 +right output2
---- TESTFILE DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1,3 @@
  echo "right output3"
  STDOUT:
 -wrong output
 +right output3
---- TESTFILE DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1,3 @@
  echo "right output4"
  STDOUT:
 -wrong output
 +right output4
---- TESTFILE DATE TIME TZ
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1,3 @@
  echo "right output5"

Modified: trunk/test/04-diff/10-Patch.test
===================================================================
--- trunk/test/04-diff/10-Patch.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/10-Patch.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -15,14 +15,11 @@
 # This is a little exotic...  Patch needs the CWD to be the directory
 # containing the file to patch.  "dirname $(tt.test)" gives that dir.
 
-tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch)
+tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 echo
 INDENT "\t" < "$tt"
 
-MODIFY:
-  s/^patching .*/patching FILE/
-
 STDOUT:
 patching FILE
 And the patched file:

Modified: trunk/test/04-diff/11-MultiPatch.test
===================================================================
--- trunk/test/04-diff/11-MultiPatch.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/11-MultiPatch.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -26,7 +26,7 @@
 
 # All tt* files must be in the same directory.
 
-tmtest --all-files -d "$tt1" "$tt2" "$tt3" | (cd `dirname "$tt1"` && patch)
+tmtest --all-files -d "$tt1" "$tt2" "$tt3" | (cd `dirname "$tt1"` && patch | FIX_PATCH)
 echo
 INDENT "\t" < "$tt1"
 echo
@@ -34,8 +34,6 @@
 echo
 INDENT "\t" < "$tt3"
 
-MODIFY:
-  s/^patching .*/patching FILE/
 
 STDOUT:
 patching FILE

Modified: trunk/test/04-diff/12-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/12-MultiLevelPatch.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/12-MultiLevelPatch.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -51,7 +51,7 @@
 EOL
 
 
-tmtest --all-files -d | patch -p0
+tmtest --all-files -d | patch -p0 | FIX_PATCH
 echo
 INDENT "\t" < t.test
 echo
@@ -66,9 +66,6 @@
 rm -rf t.test one two
 
 
-MODIFY:
-  s/^patching .*/patching FILE/
-
 STDOUT:
 patching FILE
 patching FILE

Modified: trunk/test/04-diff/13-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/13-MultiLevelPatch.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/13-MultiLevelPatch.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -52,7 +52,7 @@
 
 cd two
 
-tmtest --all-files -d .. | patch -p0
+tmtest --all-files -d .. | patch -p0 | FIX_PATCH
 echo
 INDENT "\t" < ../t.test
 echo
@@ -67,9 +67,6 @@
 rm -rf ../t.test ../one ../two
 
 
-MODIFY:
-  s/^patching .*/patching FILE/
-
 STDOUT:
 patching FILE
 patching FILE

Modified: trunk/test/04-diff/17-ConfigError.test
===================================================================
--- trunk/test/04-diff/17-ConfigError.test	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/04-diff/17-ConfigError.test	2006-03-05 15:30:53 UTC (rev 105)
@@ -1,6 +1,9 @@
 # This is like 17-ConfigError in the running directory except
 # that it performs a diff.
 
+# TODO: We pipe stderr to stdout so it can be rewritten.
+# This needs to be changed!!
+
 # BUG: notice that the diff IS STILL PRODUCED!  It just erases
 # all the sections.  This is bad, of course.  Unfortunately,
 # until we have dynamic status and can terminate the test
@@ -30,34 +33,25 @@
 	he
 EOs
 
-tmtest -d
+tmtest -d 2>&1 | REPLACE "$dir" /tmp/DIR | FIX_DIFF
 rm tmtest.conf t1.test t2.test
 
 
-MODIFY:
-	# blow away changing data in the erroneous diff
-	s/^\-\-\- t1.test.*/--- T1.TEST DATE TIME TZ/
-	s/^\-\-\- t2.test.*/--- T2.TEST DATE TIME TZ/
-	s/^\+\+\+.*/+++ - DATE TIME TZ/
-	# blow away filenames in the STDERR
-	s/^\/.*\/tmtest.conf/TMTEST.CONF/
-	s/ in \/.*\/tmtest.conf/ in TMTEST.CONF/
-
 STDOUT:
---- T1.TEST DATE TIME TZ
+/tmp/DIR/tmtest.conf: line 3: dotheyspeakbocceonwhat: command not found
+Error: t1.test was not started due to errors in /tmp/DIR/tmtest.conf.
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1 @@
  echo hi
 -STDOUT:
 -hi
---- T2.TEST DATE TIME TZ
+/tmp/DIR/tmtest.conf: line 3: dotheyspeakbocceonwhat: command not found
+Error: t2.test was not started due to errors in /tmp/DIR/tmtest.conf.
+--- /tmp/FILE DATE TIME TZ
 +++ - DATE TIME TZ
 @@ -1,3 +1 @@
  echo he
 -STDOUT:
 -he
 STDERR:
-TMTEST.CONF: line 3: dotheyspeakbocceonwhat: command not found
-Error: t1.test was not started due to errors in TMTEST.CONF.
-TMTEST.CONF: line 3: dotheyspeakbocceonwhat: command not found
-Error: t2.test was not started due to errors in TMTEST.CONF.

Modified: trunk/test/README
===================================================================
--- trunk/test/README	2006-03-05 05:07:12 UTC (rev 104)
+++ trunk/test/README	2006-03-05 15:30:53 UTC (rev 105)
@@ -21,10 +21,12 @@
 03-results: tests the results
     Ensures that we compare the test results properly.
     For instance, verifies that we handle results that don't
-    end in newlines, binary characters, etc. properly.
+    end in newlines, binary characters, etc. properly.  If it doesn't
+	exercise the comparison code, a test doesn't belong in here.
 
 04-diff: ensures diffing and patching works
 
 09-docs: tests that appear in our documentation.
     This ensures that tmtest behaves exactly like our docs say it will.
 
+





From tmtest-commits at berlios.de  Sun Mar  5 23:52:03 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Sun, 5 Mar 2006 23:52:03 +0100
Subject: [Tmtest-commits] [106] trunk: Eradicate MODIFY.
Message-ID: <200603052252.k25Mq3lT003785@sheep.berlios.de>

Revision: 106
Author:   bronson
Date:     2006-03-05 23:52:02 +0100 (Sun, 05 Mar 2006)

Log Message:
-----------
Eradicate MODIFY.  And there was much rejoicing.
NOTE: the two test failures are due to broken newline checking.
A comprehensive fix for this will be in the very next checkin.

Modified Paths:
--------------
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/compare.h
    trunk/main.c
    trunk/test.c
    trunk/test.h

Removed Paths:
-------------
    trunk/matchval.h
    trunk/pcrs.c
    trunk/pcrs.h
Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/Makefile	2006-03-05 22:52:02 UTC (rev 106)
@@ -29,14 +29,14 @@
 COPTS=-g -Wall -Werror
 
 # utilities:
-CSRC+=curdir.c qscandir.c pcrs.c pathconv.c
-CHDR+=curdir.h qscandir.h pcrs.h pathconv.h
+CSRC+=curdir.c qscandir.c pathconv.c
+CHDR+=curdir.h qscandir.h pathconv.h
 # scanner files
 CSRC+=re2c/read.c re2c/read-fd.c re2c/scan.c
 CHDR+=re2c/read.h re2c/read-fd.h re2c/scan.h
 # program files:
 CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c
-CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h matchval.h
+CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h
 
 # It makes it rather hard to debug when Make deletes the intermediate files.
 INTERMED=stscan.c

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/TODO	2006-03-05 22:52:02 UTC (rev 106)
@@ -11,8 +11,6 @@
   We will not read either config or test files from a world-writable directory.
   Ever.
 - Put $args into EVERY test we run.
-- There's some sort of a bug with 10-DumpScript.test.  When running with
-  -o or -d, sometimes it complains about a missing newline.  Odd.
 - Write a test to ensure we can run tests named "-.test"
 - Write tests to verify what FDs are still open when we run
   config files, test files, and diff.

Modified: trunk/compare.c
===================================================================
--- trunk/compare.c	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/compare.c	2006-03-05 22:52:02 UTC (rev 106)
@@ -9,38 +9,30 @@
  * File comparison.
  *
  * This uses all re2c's mechanisms for creating buffers and loading
- * them with data, but it's not an re2c scanner.
+ * them with data, but it's not actually an re2c scanner.
  *
  * Here's what you do:
- * - Create a scanstate that reads from one of the files (or
- *   whatever) that you want to compare and pass it to compare_start.
- * - Call compare_continue with any size data block from the other
- *   file you want to compare.  Keep calling until you're out of
- *   data.  Check compare_in_progress to see if it failed prematurely.
- * - Finally, when you're out of data in the other file, call
- *   compare_end.  It will verify that it's at eof on the first
- *   file.
- * - Read the final result from the matchval.
- *
- * Well, the line buffering for the pcrs library has utterly destroyed
- * the simplicity of this file.
- *
+ * - Create a scanstate attached to one stream and pass it to compare_start.
+ * - Read some data from the other stream and pass it to compare_continue.
+ * - Keep reading until you're out of data.  You can check compare_in_progress
+ *   to see if the match already failed and you can bail out early.
+ * - When you're out of data, call compare_end to obtain the result.
  */
 
-#include <string.h>
-#include "compare.h"
-
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <assert.h>
 
+#include "compare.h"
 
+
+// TODO: these are all 1-bit flags.  No need for malloc and free!
+// get rid of the output field.
+
 typedef struct {
 	matchval *output;
-	pcrs_job *jobs;
 	const char *pbuf;
-	int pcursor;
-	int plimit;
     int no_trailing_newline;    ///< true if this section isn't supposed to end with a newline
     int nl_suppressed;          ///< if no_trailing_newline is true, we need to suppress the newline in the execpted output when matching against the actual (because of the way heredocs work, the expected always ends in a newline).
     int warn_no_newline;             ///< true if the section expected a trailing newline (no_trailing_newline == false), but the last buffer seen (presumably the end of the file) didn't end with a newline.
@@ -65,7 +57,7 @@
 }
 
 
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *jobs, int nonl)
+void compare_attach(scanstate *ss, matchval *mv, int nonl)
 {
 	compare_state *cmp = malloc(sizeof(compare_state));
 	if(cmp == NULL) {
@@ -77,7 +69,6 @@
     *mv = match_inprogress;
 
 	cmp->output = mv;
-	cmp->jobs = jobs;
     cmp->no_trailing_newline = nonl;
     cmp->nl_suppressed = 0;
     cmp->warn_no_newline = 0;
@@ -86,11 +77,44 @@
 
 
 
-static void compare_continue_bytes(scanstate *ss, const char *ptr, int len)
+void compare_continue(scanstate *ss, const char *ptr, int len)
 {
 	compare_state *cmp = (compare_state*)ss->scanref;
     int n;
 
+    if(*cmp->output != match_inprogress) {
+        // we already decided an answer
+        // so don't waste time comparing more.
+        return;
+    }
+
+    assert(len >= 0);
+
+    if(cmp->no_trailing_newline) {
+        // If the incoming buffer ends in a nl, we need to suppress it
+        // for the comparison.  Note that this won't work well for
+        // MODIFY clauses but I don't care because MODIFY will never
+        // work with -n and, anyway, MODIFY is about to disappear.
+
+        if(cmp->nl_suppressed) {
+            cmp->nl_suppressed = 0;
+			if(ss->cursor < ss->limit) {
+				if(ss->cursor[0] != '\n') {
+					compare_halt(ss, match_no);
+					return;
+				}
+				ss->cursor += 1;
+			} else {
+				compare_continue(ss, "\n", 1);
+			}
+        }
+
+        if(ptr[len-1] == '\n') {
+            cmp->nl_suppressed = 1;
+            len -= 1;
+        }
+    }
+
     while(len > 0) {
         n = ss->limit - ss->cursor;
         if(!n) {
@@ -130,155 +154,6 @@
 }
 
 
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize)
-{
-	char *old, *new;
-	int nsubs;
-	int cnt;
-
-	cnt = 0;
-	old = (char*)cp;
-	*newsize = ce - cp;
-
-	while(job) {
-		// Now, run the line through the substitutions.
-		nsubs = pcrs_execute(job, old, *newsize, &new, newsize);
-		if(nsubs < 0) {
-			fprintf(stderr, "error while substituting expr %d: %s (%d).\n",
-					cnt, pcrs_strerror(nsubs), nsubs);
-            if(new) {
-                free(new);
-                new = NULL;
-            }
-			break;
-		}
-
-		assert(strlen(new) == *newsize);
-
-		if(old != cp) {
-			// free the intermediate result.
-			free(old);
-		}
-		old = new;
-		job = job->next;
-		cnt += 1;
-	}
-
-    return new;
-}
-
-
-// This routine is hellish because neither stream is line buffered.
-// Therefore, we line buffer the file and compare in chunks against
-// the input.  "pbuf" is the substitution-modified buffer allocated
-// by the pcre library.
-
-static void compare_continue_lines(scanstate *ss, compare_state *cmp,
-		const char *ptr, size_t len)
-{
-	int n;
-	const char *p;
-    char *new;
-    size_t newsize;
-
-	while(len > 0) {
-		n = cmp->plimit - cmp->pcursor;
-		assert(n >= 0);
-		if(n) {
-			// there's more data in the pbuf.  use it for comparison.
-			if(len < n) n = len;
-			if(memcmp(ptr, cmp->pbuf+cmp->pcursor, n) != 0) {
-				compare_halt(ss, match_no);
-				return;
-			}
-			cmp->pcursor += n;
-			ptr += n;
-			len -= n;
-			assert(len >= 0);
-			if(!len) break;
-		}
-
-		// we've emptied the pbuf so we need to regenerate it.
-		// first see if there's anther line in the line buffer.
-		p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-		if(!p) {
-			// there's no newline in the buffer.  try to refill.
-			n = compare_fill(ss);
-			if(n < 0) {
-				// there was an error while trying to fill the buffer
-				// TODO: this should be propagated to the client somehow.
-				perror("compare_continue_lines");
-				exit(10);
-			}
-			if(n == 0) {
-                compare_halt(ss, match_no);
-                return;
-			}
-
-			p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-			if(!p) {
-				// we'll just have to treat the entire buffer as a full
-				// line and hope for the best.  Subtract one because
-				// the very next line will add one.
-				p = ss->limit - 1;
-			}
-		}
-
-		// move p past the newline so it's at the end of the current line.
-		p += 1;
-		new = substitute_string(cmp->jobs, ss->cursor, p, &newsize);
-        if(!new) {
-            // there must have been an error
-            compare_halt(ss, match_no);
-            return;
-        }
-
-        if(cmp->pbuf) free((char*)cmp->pbuf);
-        cmp->pbuf = new;
-        cmp->pcursor = 0;
-        cmp->plimit = newsize;
-		ss->cursor = p;
-	}
-}
-
-
-void compare_continue(scanstate *ss, const char *ptr, int len)
-{
-	compare_state *cmp = (compare_state*)ss->scanref;
-
-    if(*cmp->output != match_inprogress) {
-        // we already decided an answer
-        // so don't waste time comparing more.
-        return;
-    }
-
-    assert(len >= 0);
-
-    if(cmp->no_trailing_newline) {
-        // If the incoming buffer ends in a nl, we need to suppress it
-        // for the comparison.  Note that this won't work well for
-        // MODIFY clauses but I don't care because MODIFY will never
-        // work with -n and, anyway, MODIFY is about to disappear.
-
-        if(cmp->nl_suppressed) {
-            compare_continue_bytes(ss, "\n", 1);
-            cmp->nl_suppressed = 0;
-        }
-
-        if(ptr[len-1] == '\n') {
-            cmp->nl_suppressed = 1;
-            len -= 1;
-        }
-    }
-
-	if(cmp->jobs) {
-		compare_continue_lines(ss, cmp, ptr, len);
-	} else {
-		compare_continue_bytes(ss, ptr, len);
-	}
-}
-
-
 void compare_end(scanstate *ss, int *warn_nl)
 {
 	compare_state *cmp = (compare_state*)ss->scanref;
@@ -290,24 +165,16 @@
     }
 
     if(*cmp->output == match_inprogress) {
-        assert(cmp->pcursor <= cmp->plimit);
         assert(ss->cursor <= ss->limit);
 
         *cmp->output = match_no;
-        if(cmp->jobs && cmp->plimit - cmp->pcursor != 0) {
-            // get rid of this asap.
-            *cmp->output = match_no;
-        } else if(scan_finished(ss)) {
+        if(scan_finished(ss)) {
             // if we're totally out of data and we still don't know
             // if they match, then they do match.
             *cmp->output = match_yes;
         }
     }
 
-	if(cmp->pbuf) {
-        free((char*)cmp->pbuf);
-    }
-
 	free(cmp);
     ss->scanref = NULL;
 }

Modified: trunk/compare.h
===================================================================
--- trunk/compare.h	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/compare.h	2006-03-05 22:52:02 UTC (rev 106)
@@ -7,21 +7,35 @@
  * See compare.c for license.
  */
 
-#include "pcrs.h"
-#include "matchval.h"
 #include "re2c/scan.h"
 
 
-/** Returns zero if the compare has stopped (i.e. the files differed).
+
+/**
+ * a tristate that tells whether something
+ *    - matches
+ *    - doesn't match
+ *    - hasn't been checked yet.
  */
 
+typedef enum {
+    match_inprogress = -2,
+    match_unknown = -1,
+    match_no = 0,
+    match_yes = 1,
+} matchval;
+
+
+
+
+/** Returns zero if the compare has stopped (i.e. the files differed),
+ *  one if we're still unsure.
+ */
+
 #define compare_in_progress(ss) ((ss)->scanref)
 
 
-void compare_attach(scanstate *ss, matchval *mv, pcrs_job *joblist, int nonl);
+void compare_attach(scanstate *ss, matchval *mv, int nonl);
 void compare_continue(scanstate *ss, const char *ptr, int len);
 void compare_end(scanstate *cmp, int *warn_nl);
 
-// no better place to put this for now...
-char* substitute_string(pcrs_job *job, const char *cp, const char *ce, size_t *newsize);
-

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/main.c	2006-03-05 22:52:02 UTC (rev 106)
@@ -282,7 +282,7 @@
 	test->diffname = buf;
 	fd = open_file(buf, DIFFNAME, 0);
 	assert(strlen(buf) == sizeof(TESTDIR)+sizeof(DIFFNAME)-1);
-	write_raw_file(fd, 0);
+	write_file(fd, 0);
 	close(fd);
 
 	return fd;

Deleted: trunk/matchval.h
===================================================================
--- trunk/matchval.h	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/matchval.h	2006-03-05 22:52:02 UTC (rev 106)
@@ -1,27 +0,0 @@
-/* matchval.h
- * Scott Bronson
- * 31 Dec 2004
- *
- */
-
-#ifndef MATCHVAL_H
-#define MATCHVAL_H
-
-
-/**
- * a tristate that tells whether something
- *    - matches
- *    - doesn't match
- *    - hasn't been checked yet.
- */
-
-typedef enum {
-    match_inprogress = -2,
-    match_unknown = -1,
-    match_no = 0,
-    match_yes = 1,
-} matchval;
-
-
-#endif
-

Deleted: trunk/pcrs.c
===================================================================
--- trunk/pcrs.c	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/pcrs.c	2006-03-05 22:52:02 UTC (rev 106)
@@ -1,966 +0,0 @@
-const char pcrs_rcs[] = "$Id: pcrs.c,v 1.19.2.3 2003/12/04 12:32:45 oes Exp $";
- 
-/*********************************************************************
- *
- * File        :  $Source: /cvsroot/ijbswa/current/Attic/pcrs.c,v $
- *
- * Purpose     :  pcrs is a supplement to the pcre library by Philip Hazel
- *                <ph10 at cam.ac.uk> and adds Perl-style substitution. That
- *                is, it mimics Perl's 's' operator. See pcrs(3) for details.
- *
- *
- * Copyright   :  Written and Copyright (C) 2000, 2001 by Andreas S. Oesterhelt
- *                <andreas at oesterhelt.org>
- *
- *                This program is free software; you can redistribute it
- *                and/or modify it under the terms of the GNU Lesser
- *                General Public License (LGPL), version 2.1, which  should
- *                be included in this distribution (see LICENSE.txt), with
- *                the exception that the permission to replace that license
- *                with the GNU General Public License (GPL) given in section
- *                3 is restricted to version 2 of the GPL.
- *
- *                This program is distributed in the hope that it will
- *                be useful, but WITHOUT ANY WARRANTY; without even the
- *                implied warranty of MERCHANTABILITY or FITNESS FOR A
- *                PARTICULAR PURPOSE.  See the license for more details.
- *
- *                The GNU Lesser General Public License should be included
- *                with this file.  If not, you can view it at
- *                http://www.gnu.org/licenses/lgpl.html
- *                or write to the Free Software Foundation, Inc., 59
- *                Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- * Revisions   :
- *    $Log: pcrs.c,v $
- *    Revision 1.19.2.3  2003/12/04 12:32:45  oes
- *    Append a trailing nullbyte to result to facilitate string processing
- *
- *    Revision 1.19.2.2  2002/10/08 16:22:28  oes
- *    Bugfix: Need to check validity of backreferences explicitly,
- *    because when max_matches are reached and matches is expanded,
- *    realloc() does not zero the memory. Fixes Bug # 606227
- *
- *    Revision 1.19.2.1  2002/08/10 11:23:40  oes
- *    [Irrelevant for stand-alone pcrs]
- *
- *    Revision 1.19  2002/03/08 14:47:48  oes
- *    Cosmetics
- *
- *    Revision 1.18  2002/03/08 14:17:14  oes
- *    Fixing -Wconversion warnings
- *
- *    Revision 1.17  2002/03/08 13:45:48  oes
- *    Hiding internal functions
- *
- *    Revision 1.16  2001/11/30 21:32:14  jongfoster
- *    Fixing signed/unsigned comparison (Andreas please check this!)
- *    One tab->space
- *
- *    Revision 1.15  2001/09/20 16:11:06  steudten
- *
- *    Add casting for some string functions.
- *
- *    Revision 1.14  2001/09/09 21:41:57  oes
- *    Fixing yet another silly bug
- *
- *    Revision 1.13  2001/09/06 14:05:59  oes
- *    Fixed silly bug
- *
- *    Revision 1.12  2001/08/18 11:35:00  oes
- *    - Introduced pcrs_strerror()
- *    - made some NULL arguments non-fatal
- *    - added support for \n \r \e \b \t \f \a \0 in substitute
- *    - made quoting adhere to standard rules
- *    - added warning for bad backrefs
- *    - added pcrs_execute_list()
- *    - fixed comments
- *    - bugfix & cosmetics
- *
- *    Revision 1.11  2001/08/15 15:32:03  oes
- *     - Added support for Perl's special variables $+, $' and $`
- *     - Improved the substitute parser
- *     - Replaced the hard limit for the maximum number of matches
- *       by dynamic reallocation
- *
- *    Revision 1.10  2001/08/05 13:13:11  jongfoster
- *    Making parameters "const" where possible.
- *
- *    Revision 1.9  2001/07/18 17:27:00  oes
- *    Changed interface; Cosmetics
- *
- *    Revision 1.8  2001/06/29 21:45:41  oes
- *    Indentation, CRLF->LF, Tab-> Space
- *
- *    Revision 1.7  2001/06/29 13:33:04  oes
- *    - Cleaned up, renamed and reordered functions,
- *      improved comments
- *    - Removed my_strsep
- *    - Replaced globalflag with a general flags int
- *      that holds PCRS_GLOBAL, PCRS_SUCCESS, and PCRS_TRIVIAL
- *    - Introduced trivial option that will prevent pcrs
- *      from honouring backreferences in the substitute,
- *      which is useful for large substitutes that are
- *      red in from somewhere and saves the pain of escaping
- *      the backrefs
- *    - Introduced convenience function pcrs_free_joblist()
- *    - Split pcrs_make_job() into pcrs_compile(), which still
- *      takes a complete s/// comand as argument and parses it,
- *      and a new function pcrs_make_job, which takes the
- *      three separate components. This should make for a
- *      much friendlier frontend.
- *    - Removed create_pcrs_job() which was useless
- *    - Fixed a bug in pcrs_execute
- *    - Success flag is now handled by pcrs instead of user
- *
- *    Revision 1.6  2001/06/03 19:12:45  oes
- *    added FIXME
- *
- *    Revision 1.5  2001/05/29 09:50:24  jongfoster
- *    (Fixed one int -> size_t)
- *
- *    Revision 1.4  2001/05/25 14:12:40  oes
- *    Fixed bug: Empty substitutes now detected
- *
- *    Revision 1.3  2001/05/25 11:03:55  oes
- *    Added sanity check for NULL jobs to pcrs_exec_substitution
- *
- *    Revision 1.2  2001/05/22 18:46:04  oes
- *
- *      Added support for PCRE_UNGREEDY behaviour to pcrs,
- *      which is selected by the (nonstandard and therefore
- *      capital) letter 'U' in the option string.
- *      It causes the quantifiers to be ungreedy by default.
- *      Appending a ? turns back to greedy (!).
- *
- *    Revision 1.1.1.1  2001/05/15 13:59:02  oes
- *    Initial import of version 2.9.3 source tree
- *
- *
- *********************************************************************/
-
-
-#include <string.h>
-#include <ctype.h>
-
-#include "pcrs.h"
-
-const char pcrs_h_rcs[] = PCRS_H_VERSION;
-
-/*
- * Internal prototypes
- */
-
-static int              pcrs_parse_perl_options(const char *optstring, int *flags);
-static pcrs_substitute *pcrs_compile_replacement(const char *replacement, int trivialflag,
-                        int capturecount, int *errptr);
-
-/*********************************************************************
- *
- * Function    :  pcrs_strerror
- *
- * Description :  Return a string describing a given error code.
- *             
- * Parameters  :
- *          1  :  error = the error code
- *
- * Returns     :  char * to the descriptive string
- *
- *********************************************************************/
-const char *pcrs_strerror(const int error)
-{
-   if (error < 0)
-   {
-      switch (error)
-      {
-         /* Passed-through PCRE error: */
-         case PCRE_ERROR_NOMEMORY:     return "(pcre:) No memory";
-
-         /* Shouldn't happen unless PCRE or PCRS bug, or user messed with compiled job: */
-         case PCRE_ERROR_NULL:         return "(pcre:) NULL code or subject or ovector";
-         case PCRE_ERROR_BADOPTION:    return "(pcre:) Unrecognized option bit";
-         case PCRE_ERROR_BADMAGIC:     return "(pcre:) Bad magic number in code";
-         case PCRE_ERROR_UNKNOWN_NODE: return "(pcre:) Bad node in pattern";
-
-         /* Can't happen / not passed: */
-         case PCRE_ERROR_NOSUBSTRING:  return "(pcre:) Fire in power supply"; 
-         case PCRE_ERROR_NOMATCH:      return "(pcre:) Water in power supply";
-
-         /* PCRS errors: */
-         case PCRS_ERR_NOMEM:          return "(pcrs:) No memory";
-         case PCRS_ERR_CMDSYNTAX:      return "(pcrs:) Syntax error while parsing command";
-         case PCRS_ERR_STUDY:          return "(pcrs:) PCRE error while studying the pattern";
-         case PCRS_ERR_BADJOB:         return "(pcrs:) Bad job - NULL job, pattern or substitute";
-         case PCRS_WARN_BADREF:        return "(pcrs:) Backreference out of range";
-
-         /* What's that? */
-         default:  return "Unknown error";
-      }
-   }
-   /* error >= 0: No error */
-   return "(pcrs:) Everything's just fine. Thanks for asking.";
-
-}
-
-
-/*********************************************************************
- *
- * Function    :  pcrs_parse_perl_options
- *
- * Description :  This function parses a string containing the options to
- *                Perl's s/// operator. It returns an integer that is the
- *                pcre equivalent of the symbolic optstring.
- *                Since pcre doesn't know about Perl's 'g' (global) or pcrs',
- *                'T' (trivial) options but pcrs needs them, the corresponding
- *                flags are set if 'g'or 'T' is encountered.
- *                Note: The 'T' and 'U' options do not conform to Perl.
- *             
- * Parameters  :
- *          1  :  optstring = string with options in perl syntax
- *          2  :  flags = see description
- *
- * Returns     :  option integer suitable for pcre 
- *
- *********************************************************************/
-static int pcrs_parse_perl_options(const char *optstring, int *flags)
-{
-   size_t i;
-   int rc = 0;
-   *flags = 0;
-
-   if (NULL == optstring) return 0;
-
-   for (i = 0; i < strlen(optstring); i++)
-   {
-      switch(optstring[i])
-      {
-         case 'e': break; /* ToDo ;-) */
-         case 'g': *flags |= PCRS_GLOBAL; break;
-         case 'i': rc |= PCRE_CASELESS; break;
-         case 'm': rc |= PCRE_MULTILINE; break;
-         case 'o': break;
-         case 's': rc |= PCRE_DOTALL; break;
-         case 'x': rc |= PCRE_EXTENDED; break;
-         case 'U': rc |= PCRE_UNGREEDY; break;
-         case 'T': *flags |= PCRS_TRIVIAL; break;
-         default: break;
-      }
-   }
-   return rc;
-
-}
-
-
-/*********************************************************************
- *
- * Function    :  pcrs_compile_replacement
- *
- * Description :  This function takes a Perl-style replacement (2nd argument
- *                to the s/// operator and returns a compiled pcrs_substitute,
- *                or NULL if memory allocation for the substitute structure
- *                fails.
- *
- * Parameters  :
- *          1  :  replacement = replacement part of s/// operator
- *                              in perl syntax
- *          2  :  trivialflag = Flag that causes backreferences to be
- *                              ignored.
- *          3  :  capturecount = Number of capturing subpatterns in
- *                               the pattern. Needed for $+ handling.
- *          4  :  errptr = pointer to an integer in which error
- *                         conditions can be returned.
- *
- * Returns     :  pcrs_substitute data structure, or NULL if an
- *                error is encountered. In that case, *errptr has
- *                the reason.
- *
- *********************************************************************/
-static pcrs_substitute *pcrs_compile_replacement(const char *replacement, int trivialflag, int capturecount, int *errptr)
-{
-   int i, k, l, quoted;
-   size_t length;
-   char *text;
-   pcrs_substitute *r;
-
-   i = k = l = quoted = 0;
-
-   /*
-    * Sanity check
-    */
-   if (NULL == replacement)
-   {
-      replacement = "";
-   }
-
-   /*
-    * Get memory or fail
-    */
-   if (NULL == (r = (pcrs_substitute *)malloc(sizeof(pcrs_substitute))))
-   {
-      *errptr = PCRS_ERR_NOMEM;
-      return NULL;
-   }
-   memset(r, '\0', sizeof(pcrs_substitute));
-
-   length = strlen(replacement);
-
-   if (NULL == (text = (char *)malloc(length + 1)))
-   {
-      free(r);
-      *errptr = PCRS_ERR_NOMEM;
-      return NULL;
-   }
-   memset(text, '\0', length + 1);
-   
-
-   /*
-    * In trivial mode, just copy the substitute text
-    */
-   if (trivialflag)
-   {
-      text = strncpy(text, replacement, length + 1);
-      k = length;
-   }
-
-   /*
-    * Else, parse, cut out and record all backreferences
-    */
-   else
-   {
-      while (i < (int)length)
-      {
-         /* Quoting */
-         if (replacement[i] == '\\')
-         {
-            if (quoted)
-            {
-               text[k++] = replacement[i++];
-               quoted = 0;
-            }
-            else
-            {
-               if (replacement[i+1] && strchr("tnrfae0", replacement[i+1]))
-               {
-                  switch (replacement[++i])
-                  {
-                  case 't':
-                     text[k++] = '\t';
-                     break;
-                  case 'n':
-                     text[k++] = '\n';
-                     break;
-                  case 'r':
-                     text[k++] = '\r';
-                     break;
-                  case 'f':
-                     text[k++] = '\f';
-                     break;
-                  case 'a':
-                     text[k++] = 7;
-                     break;
-                  case 'e':
-                     text[k++] = 27;
-                     break;
-                  case '0':
-                     text[k++] = '\0';
-                     break;
-                  }
-                  i++;
-               }
-               else
-               {
-                  quoted = 1;
-                  i++;
-               }
-            }
-            continue;
-         }
-
-         /* Backreferences */
-         if (replacement[i] == '$' && !quoted && i < (int)(length - 1))
-         {
-            char *symbol, symbols[] = "'`+&";
-            r->block_length[l] = k - r->block_offset[l];
-
-            /* Numerical backreferences */
-            if (isdigit((int)replacement[i + 1]))
-            {
-               while (i < (int)length && isdigit((int)replacement[++i]))
-               {
-                  r->backref[l] = r->backref[l] * 10 + replacement[i] - 48;
-               }
-               if (r->backref[l] > capturecount)
-               {
-                  *errptr = PCRS_WARN_BADREF;
-               }
-            }
-
-            /* Symbolic backreferences: */
-            else if (NULL != (symbol = strchr(symbols, replacement[i + 1])))
-            {
-               
-               if (symbol - symbols == 2) /* $+ */
-               {
-                  r->backref[l] = capturecount;
-               }
-               else if (symbol - symbols == 3) /* $& */
-               {
-                  r->backref[l] = 0;
-               }
-               else /* $' or $` */
-               {
-                  r->backref[l] = PCRS_MAX_SUBMATCHES + 1 - (symbol - symbols);
-               }
-               i += 2;
-            }
-
-            /* Invalid backref -> plain '$' */
-            else
-            {
-               goto plainchar;
-            }
-
-            /* Valid and in range? -> record */
-            if (r->backref[l] < PCRS_MAX_SUBMATCHES + 2)
-            {
-               r->backref_count[r->backref[l]] += 1;
-               r->block_offset[++l] = k;
-            }
-            else
-            {
-               *errptr = PCRS_WARN_BADREF;
-            }   
-            continue;
-         }
-         
-plainchar:
-         /* Plain chars are copied */
-         text[k++] = replacement[i++];
-         quoted = 0;
-      }
-   } /* -END- if (!trivialflag) */
-
-   /*
-    * Finish & return
-    */
-   r->text = text;
-   r->backrefs = l;
-   r->block_length[l] = k - r->block_offset[l];
-
-   return r;
-
-}
-
-
-/*********************************************************************
- *
- * Function    :  pcrs_free_job
- *
- * Description :  Frees the memory used by a pcrs_job struct and its
- *                dependant structures.
- *
- * Parameters  :
- *          1  :  job = pointer to the pcrs_job structure to be freed
- *
- * Returns     :  a pointer to the next job, if there was any, or
- *                NULL otherwise. 
- *
- *********************************************************************/
-pcrs_job *pcrs_free_job(pcrs_job *job)
-{
-   pcrs_job *next;
-
-   if (job == NULL)
-   {
-      return NULL;
-   }
-   else
-   {
-      next = job->next;
-      if (job->pattern != NULL) free(job->pattern);
-      if (job->hints != NULL) free(job->hints);
-      if (job->substitute != NULL)
-      {
-         if (job->substitute->text != NULL) free(job->substitute->text);
-         free(job->substitute);
-      }
-      free(job);
-   }
-   return next;
-
-}
-
-
-/*********************************************************************
- *
- * Function    :  pcrs_free_joblist
- *
- * Description :  Iterates through a chained list of pcrs_job's and
- *                frees them using pcrs_free_job.
- *
- * Parameters  :
- *          1  :  joblist = pointer to the first pcrs_job structure to
- *                be freed
- *
- * Returns     :  N/A
- *
- *********************************************************************/
-void pcrs_free_joblist(pcrs_job *joblist)
-{
-   while ( NULL != (joblist = pcrs_free_job(joblist)) ) {};
-
-   return;
-
-}
-
-
-/*********************************************************************
- *
- * Function    :  pcrs_compile_command
- *
- * Description :  Parses a string with a Perl-style s/// command, 
- *                calls pcrs_compile, and returns a corresponding
- *                pcrs_job, or NULL if parsing or compiling the job
- *                fails.
- *
- * Parameters  :
- *          1  :  command = string with perl-style s/// command
- *          2  :  errptr = pointer to an integer in which error
- *                         conditions can be returned.
- *
- * Returns     :  a corresponding pcrs_job data structure, or NULL
- *                if an error was encountered. In that case, *errptr
- *                has the reason.
- *
- *********************************************************************/
-pcrs_job *pcrs_compile_command(const char *command, int *errptr)
-{
-   int i, k, l, quoted = FALSE;
-   size_t limit;
-   char delimiter;
-   char *tokens[4];   
-   pcrs_job *newjob;
-   
-   i = k = l = 0;
-   
-   /*
-    * Tokenize the perl command
-    */
-   limit = strlen(command);
-   if (limit < 4)
-   {
-      *errptr = PCRS_ERR_CMDSYNTAX;
-      return NULL;
-   }
-   else
-   {
-      delimiter = command[1];
-   }
-
-   tokens[l] = (char *) malloc(limit + 1);
-
-   for (i = 0; i <= (int)limit; i++)
-   {
-      
-      if (command[i] == delimiter && !quoted)
-      {
-         if (l == 3)
-         {
-            l = -1;
-            break;
-         }
-         tokens[0][k++] = '\0';
-         tokens[++l] = tokens[0] + k;
-         continue;
-      }
-      
-      else if (command[i] == '\\' && !quoted)
-      {
-         quoted = TRUE;
-         if (command[i+1] == delimiter) continue;
-      }
-      else
-      {
-         quoted = FALSE;
-      }
-      tokens[0][k++] = command[i];
-   }
-
-   /*
-    * Syntax error ?
-    */
-   if (l != 3)
-   {
-      *errptr = PCRS_ERR_CMDSYNTAX;
-      free(tokens[0]);
-      return NULL;
-   }
-   
-   newjob = pcrs_compile(tokens[1], tokens[2], tokens[3], errptr);
-   free(tokens[0]);
-   return newjob;
-   
-}
-
-
-/*********************************************************************
- *
- * Function    :  pcrs_compile
- *
- * Description :  Takes the three arguments to a perl s/// command
- *                and compiles a pcrs_job structure from them.
- *
- * Parameters  :
- *          1  :  pattern = string with perl-style pattern
- *          2  :  substitute = string with perl-style substitute
- *          3  :  options = string with perl-style options
- *          4  :  errptr = pointer to an integer in which error
- *                         conditions can be returned.
- *
- * Returns     :  a corresponding pcrs_job data structure, or NULL
- *                if an error was encountered. In that case, *errptr
- *                has the reason.
- *
- *********************************************************************/
-pcrs_job *pcrs_compile(const char *pattern, const char *substitute, const char *options, int *errptr)
-{
-   pcrs_job *newjob;
-   int flags;
-   int capturecount;
-   const char *error;
-
-   *errptr = 0;
-
-   /* 
-    * Handle NULL arguments
-    */
-   if (pattern == NULL) pattern = "";
-   if (substitute == NULL) substitute = "";
-
-
-   /* 
-    * Get and init memory
-    */
-   if (NULL == (newjob = (pcrs_job *)malloc(sizeof(pcrs_job))))
-   {
-      *errptr = PCRS_ERR_NOMEM;
-      return NULL;
-   }
-   memset(newjob, '\0', sizeof(pcrs_job));
-
-
-   /*
-    * Evaluate the options
-    */
-   newjob->options = pcrs_parse_perl_options(options, &flags);
-   newjob->flags = flags;
-
-
-   /*
-    * Compile the pattern
-    */
-   newjob->pattern = pcre_compile(pattern, newjob->options, &error, errptr, NULL);
-   if (newjob->pattern == NULL)
-   {
-      pcrs_free_job(newjob);
-      return NULL;
-   }
-
-
-   /*
-    * Generate hints. This has little overhead, since the
-    * hints will be NULL for a boring pattern anyway.
-    */
-   newjob->hints = pcre_study(newjob->pattern, 0, &error);
-   if (error != NULL)
-   {
-      *errptr = PCRS_ERR_STUDY;
-      pcrs_free_job(newjob);
-      return NULL;
-   }
- 
-
-   /* 
-    * Determine the number of capturing subpatterns. 
-    * This is needed for handling $+ in the substitute.
-    */
-   if (0 > (*errptr = pcre_fullinfo(newjob->pattern, newjob->hints, PCRE_INFO_CAPTURECOUNT, &capturecount)))
-   {
-      pcrs_free_job(newjob);
-      return NULL;
-   }
- 
-
-   /*
-    * Compile the substitute
-    */
-   if (NULL == (newjob->substitute = pcrs_compile_replacement(substitute, newjob->flags & PCRS_TRIVIAL, capturecount, errptr)))
-   {
-      pcrs_free_job(newjob);
-      return NULL;
-   }
- 
-   return newjob;
-
-}
-
-
-/*********************************************************************
- *
- * Function    :  pcrs_execute_list
- *
- * Description :  This is a multiple job wrapper for pcrs_execute().
- *                Apply the regular substitutions defined by the jobs in
- *                the joblist to the subject.
- *                The subject itself is left untouched, memory for the result
- *                is malloc()ed and it is the caller's responsibility to free
- *                the result when it's no longer needed. 
- *
- *                Note: For convenient string handling, a null byte is
- *                      appended to the result. It does not count towards the
- *                      result_length, though.
- *
- *
- * Parameters  :
- *          1  :  joblist = the chained list of pcrs_jobs to be executed
- *          2  :  subject = the subject string
- *          3  :  subject_length = the subject's length 
- *          4  :  result = char** for returning  the result 
- *          5  :  result_length = size_t* for returning the result's length
- *
- * Returns     :  On success, the number of substitutions that were made.
- *                 May be > 1 if job->flags contained PCRS_GLOBAL
- *                On failiure, the (negative) pcre error code describing the
- *                 failiure, which may be translated to text using pcrs_strerror().
- *
- *********************************************************************/
-int pcrs_execute_list(pcrs_job *joblist, char *subject, size_t subject_length, char **result, size_t *result_length)
-{
-   pcrs_job *job;
-   char *old, *new;
-   int hits, total_hits;
- 
-   old = subject;
-   *result_length = subject_length;
-   hits = total_hits = 0;
-
-   for (job = joblist; job != NULL; job = job->next)
-   {
-      hits = pcrs_execute(job, old, *result_length, &new, result_length);
-
-      if (old != subject) free(old);
-
-      if (hits < 0)
-      {
-         return(hits);
-      }
-      else
-      {
-         total_hits += hits;
-         old = new;
-      }
-   }
-
-   *result = new;
-   return(total_hits);
-
-}
-
-
-/*********************************************************************
- *
- * Function    :  pcrs_execute
- *
- * Description :  Apply the regular substitution defined by the job to the
- *                subject.
- *                The subject itself is left untouched, memory for the result
- *                is malloc()ed and it is the caller's responsibility to free
- *                the result when it's no longer needed.
- *
- *                Note: For convenient string handling, a null byte is
- *                      appended to the result. It does not count towards the
- *                      result_length, though.
- *
- * Parameters  :
- *          1  :  job = the pcrs_job to be executed
- *          2  :  subject = the subject (== original) string
- *          3  :  subject_length = the subject's length 
- *          4  :  result = char** for returning  the result 
- *          5  :  result_length = size_t* for returning the result's length
- *
- * Returns     :  On success, the number of substitutions that were made.
- *                 May be > 1 if job->flags contained PCRS_GLOBAL
- *                On failiure, the (negative) pcre error code describing the
- *                 failiure, which may be translated to text using pcrs_strerror().
- *
- *********************************************************************/
-int pcrs_execute(pcrs_job *job, char *subject, size_t subject_length, char **result, size_t *result_length)
-{
-   int offsets[3 * PCRS_MAX_SUBMATCHES],
-       offset,
-       i, k,
-       matches_found,
-       submatches,
-       max_matches = PCRS_MAX_MATCH_INIT;
-   size_t newsize;
-   pcrs_match *matches, *dummy;
-   char *result_offset;
-
-   offset = i = k = 0;
-
-   /* 
-    * Sanity check & memory allocation
-    */
-   if (job == NULL || job->pattern == NULL || job->substitute == NULL)
-   {
-      *result = NULL;
-      return(PCRS_ERR_BADJOB);
-   }
-
-   if (NULL == (matches = (pcrs_match *)malloc(max_matches * sizeof(pcrs_match))))
-   {
-      *result = NULL;
-      return(PCRS_ERR_NOMEM);
-   }
-   memset(matches, '\0', max_matches * sizeof(pcrs_match));
-
-
-   /*
-    * Find the pattern and calculate the space
-    * requirements for the result
-    */
-   newsize = subject_length;
-
-   while ((submatches = pcre_exec(job->pattern, job->hints, subject, (int)subject_length, offset, 0, offsets, 3 * PCRS_MAX_SUBMATCHES)) > 0)
-   {
-      job->flags |= PCRS_SUCCESS;
-      matches[i].submatches = submatches;
-
-      for (k = 0; k < submatches; k++)
-      {
-         matches[i].submatch_offset[k] = offsets[2 * k];
-
-         /* Note: Non-found optional submatches have length -1-(-1)==0 */
-         matches[i].submatch_length[k] = offsets[2 * k + 1] - offsets[2 * k]; 
-
-         /* reserve mem for each submatch as often as it is ref'd */
-         newsize += matches[i].submatch_length[k] * job->substitute->backref_count[k];
-      }
-      /* plus replacement text size minus match text size */
-      newsize += strlen(job->substitute->text) - matches[i].submatch_length[0]; 
-
-      /* chunk before match */
-      matches[i].submatch_offset[PCRS_MAX_SUBMATCHES] = 0;
-      matches[i].submatch_length[PCRS_MAX_SUBMATCHES] = offsets[0];
-      newsize += offsets[0] * job->substitute->backref_count[PCRS_MAX_SUBMATCHES];
-
-      /* chunk after match */
-      matches[i].submatch_offset[PCRS_MAX_SUBMATCHES + 1] = offsets[1];
-      matches[i].submatch_length[PCRS_MAX_SUBMATCHES + 1] = subject_length - offsets[1] - 1;
-      newsize += (subject_length - offsets[1]) * job->substitute->backref_count[PCRS_MAX_SUBMATCHES + 1];
-
-      /* Storage for matches exhausted? -> Extend! */
-      if (++i >= max_matches)
-      {
-         max_matches = (int)(max_matches * PCRS_MAX_MATCH_GROW);
-         if (NULL == (dummy = (pcrs_match *)realloc(matches, max_matches * sizeof(pcrs_match))))
-         {
-            free(matches);
-            *result = NULL;
-            return(PCRS_ERR_NOMEM);
-         }
-         matches = dummy;
-      }
-
-      /* Non-global search or limit reached? */
-      if (!(job->flags & PCRS_GLOBAL)) break;
-
-      /* Don't loop on empty matches */
-      if (offsets[1] == offset)
-         if ((size_t)offset < subject_length)
-            offset++;
-         else
-            break;
-      /* Go find the next one */
-      else
-         offset = offsets[1];
-   }
-   /* Pass pcre error through if (bad) failiure */
-   if (submatches < PCRE_ERROR_NOMATCH)
-   {
-      free(matches);
-      return submatches;   
-   }
-   matches_found = i;
-
-
-   /* 
-    * Get memory for the result (must be freed by caller!)
-    * and append terminating null byte.
-    */
-   if ((*result = (char *)malloc(newsize + 1)) == NULL)
-   {
-      free(matches);
-      return PCRS_ERR_NOMEM;
-   }
-   else
-   {
-      (*result)[newsize] = '\0';
-   }
-
-
-   /* 
-    * Replace
-    */
-   offset = 0;
-   result_offset = *result;
-
-   for (i = 0; i < matches_found; i++)
-   {
-      /* copy the chunk preceding the match */
-      memcpy(result_offset, subject + offset, (size_t)matches[i].submatch_offset[0] - offset); 
-      result_offset += matches[i].submatch_offset[0] - offset;
-
-      /* For every segment of the substitute.. */
-      for (k = 0; k <= job->substitute->backrefs; k++)
-      {
-         /* ...copy its text.. */
-         memcpy(result_offset, job->substitute->text + job->substitute->block_offset[k], job->substitute->block_length[k]);
-         result_offset += job->substitute->block_length[k];
-
-         /* ..plus, if it's not the last chunk, i.e.: There *is* a backref.. */
-         if (k != job->substitute->backrefs
-             /* ..in legal range.. */
-             && job->substitute->backref[k] < PCRS_MAX_SUBMATCHES + 2
-             /* ..and referencing a real submatch.. */
-             && job->substitute->backref[k] < matches[i].submatches
-             /* ..that is nonempty.. */
-             && matches[i].submatch_length[job->substitute->backref[k]] > 0)
-         {
-            /* ..copy the submatch that is ref'd. */
-            memcpy(
-               result_offset,
-               subject + matches[i].submatch_offset[job->substitute->backref[k]],
-               matches[i].submatch_length[job->substitute->backref[k]]
-            );
-            result_offset += matches[i].submatch_length[job->substitute->backref[k]];
-         }
-      }
-      offset =  matches[i].submatch_offset[0] + matches[i].submatch_length[0];
-   }
-
-   /* Copy the rest. */
-   memcpy(result_offset, subject + offset, subject_length - offset);
-
-   *result_length = newsize;
-   free(matches);
-   return matches_found;
-
-}
-
-
-/*
-  Local Variables:
-  tab-width: 3
-  end:
-*/

Deleted: trunk/pcrs.h
===================================================================
--- trunk/pcrs.h	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/pcrs.h	2006-03-05 22:52:02 UTC (rev 106)
@@ -1,171 +0,0 @@
-#ifndef PCRS_H_INCLUDED
-#define PCRS_H_INCLUDED
-
-/*********************************************************************
- *
- * File        :  $Source: /cvsroot/ijbswa/current/pcrs.h,v $
- *
- * Purpose     :  Header file for pcrs.c
- *
- * Copyright   :  see pcrs.c
- *
- * Revisions   :
- *    $Log: pcrs.h,v $
- *    Revision 1.11  2002/03/08 14:18:23  oes
- *    Fixing -Wconversion warnings
- *
- *    Revision 1.10  2002/03/08 13:44:48  oes
- *    Hiding internal functions, preventing double inclusion of pcre.h
- *
- *    Revision 1.9  2001/08/18 11:35:29  oes
- *    - Introduced pcrs_strerror()
- *    - added pcrs_execute_list()
- *
- *    Revision 1.8  2001/08/15 15:32:50  oes
- *    Replaced the hard limit for the maximum number of matches
- *    by dynamic reallocation
- *
- *    Revision 1.7  2001/08/05 13:13:11  jongfoster
- *    Making parameters "const" where possible.
- *
- *    Revision 1.6  2001/07/29 18:52:06  jongfoster
- *    Renaming _PCRS_H, and adding "extern C {}"
- *
- *    Revision 1.5  2001/07/18 17:27:00  oes
- *    Changed interface; Cosmetics
- *
- *    Revision 1.4  2001/06/29 13:33:19  oes
- *    - Cleaned up, commented and adapted to reflect the
- *      changes in pcrs.c
- *    - Introduced the PCRS_* flags
- *
- *    Revision 1.3  2001/06/09 10:58:57  jongfoster
- *    Removing a single unused #define which referenced BUFSIZ
- *
- *    Revision 1.2  2001/05/25 11:03:55  oes
- *    Added sanity check for NULL jobs to pcrs_exec_substitution
- *
- *    Revision 1.1.1.1  2001/05/15 13:59:02  oes
- *    Initial import of version 2.9.3 source tree
- *
- *    Revision 1.4  2001/05/11 01:57:02  rodney
- *    Added new file header standard w/RCS control tags.
- *
- *    revision 1.3  2001/05/08 02:38:13  rodney
- *    Changed C++ "//" style comment to C style comments.
- *
- *    revision 1.2  2001/04/30 02:39:24  rodney
- *    Made this pcrs.h file conditionally included.
- *
- *    revision 1.1  2001/04/16 21:10:38  rodney
- *    Initial checkin
- *
- *********************************************************************/
-
-#define PCRS_H_VERSION "$Id: pcrs.h,v 1.11 2002/03/08 14:18:23 oes Exp $"
-
-
-#ifndef _PCRE_H
-#include <pcre.h>
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Constants:
- */
-
-#define FALSE 0
-#define TRUE 1
-
-/* Capacity */
-#define PCRS_MAX_SUBMATCHES  33     /* Maximum number of capturing subpatterns allowed. MUST be <= 99! FIXME: Should be dynamic */
-#define PCRS_MAX_MATCH_INIT  40     /* Initial amount of matches that can be stored in global searches */
-#define PCRS_MAX_MATCH_GROW  1.6    /* Factor by which storage for matches is extended if exhausted */
-
-/* Error codes */
-#define PCRS_ERR_NOMEM     -10      /* Failed to acquire memory. */
-#define PCRS_ERR_CMDSYNTAX -11      /* Syntax of s///-command */
-#define PCRS_ERR_STUDY     -12      /* pcre error while studying the pattern */
-#define PCRS_ERR_BADJOB    -13      /* NULL job pointer, pattern or substitute */
-#define PCRS_WARN_BADREF   -14      /* Backreference out of range */
-
-/* Flags */
-#define PCRS_GLOBAL          1      /* Job should be applied globally, as with perl's g option */
-#define PCRS_TRIVIAL         2      /* Backreferences in the substitute are ignored */
-#define PCRS_SUCCESS         4      /* Job did previously match */
-
-
-/*
- * Data types:
- */
-
-/* A compiled substitute */
-
-typedef struct {
-  char  *text;                                   /* The plaintext part of the substitute, with all backreferences stripped */
-  int    backrefs;                               /* The number of backreferences */
-  int    block_offset[PCRS_MAX_SUBMATCHES];      /* Array with the offsets of all plaintext blocks in text */
-  size_t block_length[PCRS_MAX_SUBMATCHES];      /* Array with the lengths of all plaintext blocks in text */
-  int    backref[PCRS_MAX_SUBMATCHES];           /* Array with the backref number for all plaintext block borders */
-  int    backref_count[PCRS_MAX_SUBMATCHES + 2]; /* Array with the number of references to each backref index */
-} pcrs_substitute;
-
-
-/*
- * A match, including all captured subpatterns (submatches)
- * Note: The zeroth is the whole match, the PCRS_MAX_SUBMATCHES + 0th
- * is the range before the match, the PCRS_MAX_SUBMATCHES + 1th is the
- * range after the match.
- */
-
-typedef struct {
-  int    submatches;                               /* Number of captured subpatterns */
-  int    submatch_offset[PCRS_MAX_SUBMATCHES + 2]; /* Offset for each submatch in the subject */
-  size_t submatch_length[PCRS_MAX_SUBMATCHES + 2]; /* Length of each submatch in the subject */
-} pcrs_match;
-
-
-/* A PCRS job */
-
-typedef struct PCRS_JOB {
-  pcre *pattern;                            /* The compiled pcre pattern */
-  pcre_extra *hints;                        /* The pcre hints for the pattern */
-  int options;                              /* The pcre options (numeric) */
-  int flags;                                /* The pcrs and user flags (see "Flags" above) */
-  pcrs_substitute *substitute;              /* The compiled pcrs substitute */
-  struct PCRS_JOB *next;                    /* Pointer for chaining jobs to joblists */
-} pcrs_job;
-
-
-/*
- * Prototypes:
- */
-
-/* Main usage */
-extern pcrs_job        *pcrs_compile_command(const char *command, int *errptr);
-extern pcrs_job        *pcrs_compile(const char *pattern, const char *substitute, const char *options, int *errptr);
-extern int              pcrs_execute(pcrs_job *job, char *subject, size_t subject_length, char **result, size_t *result_length);
-extern int              pcrs_execute_list(pcrs_job *joblist, char *subject, size_t subject_length, char **result, size_t *result_length);
-
-/* Freeing jobs */
-extern pcrs_job        *pcrs_free_job(pcrs_job *job);
-extern void             pcrs_free_joblist(pcrs_job *joblist);
-
-/* Info on errors: */
-extern const char *pcrs_strerror(const int error);
-
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
-
-#endif /* ndef PCRS_H_INCLUDED */
-
-/*
-  Local Variables:
-  tab-width: 3
-  end:
-*/

Modified: trunk/test.c
===================================================================
--- trunk/test.c	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/test.c	2006-03-05 22:52:02 UTC (rev 106)
@@ -15,8 +15,6 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <errno.h>
-
-// to get PATH_MAX:
 #include <dirent.h>
 
 #include "re2c/read-fd.h"
@@ -24,14 +22,9 @@
 #include "test.h"
 #include "stscan.h"
 #include "tfscan.h"
-#include "compare.h"
 #include "rusage.h"
 
 
-// This is the maximum line length for the eachline substitution.
-// Lines longer than this will be parsed as 2 separate lines.
-#define MAX_LINE_LENGTH BUFSIZ
-
 // utility function so you can say i.e. write_strconst(fd, "/");
 #define write_strconst(fd, str) write((fd), (str), sizeof(str)-1)
 
@@ -342,8 +335,8 @@
  * it up.
  */
 
-void compare_section_start(scanstate *cmpscan, int fd, pcrs_job *joblist,
-		matchval *mv, const char *filename, const char *sectionname, int nonl)
+void compare_section_start(scanstate *cmpscan, int fd, matchval *mv,
+		const char *filename, const char *sectionname, int nonl)
 {
     assert(!compare_in_progress(cmpscan));
 
@@ -355,7 +348,7 @@
 
     scanstate_reset(cmpscan);
     readfd_attach(cmpscan, fd);
-	compare_attach(cmpscan, mv, joblist, nonl);
+	compare_attach(cmpscan, mv, nonl);
 
     // we may want to check the token to see if there are any
     // special requests (like detabbing).
@@ -426,70 +419,7 @@
 }
 
 
-void parse_modify_clause(struct test *test, const char *cp, const char *ce)
-{
-	pcrs_job *job, **p;
-	char *string;
-	int err;
 
-	char buf[128];	// holds the pcrs command.  We will dynamically
-		// allocate a buffer if the entire substitution doesn't fit
-		// into this buffer.  The vast majority of substitutions will
-		// be less than 40 chars.
-
-	// skip any leading whitespace
-	while(isspace(*cp) && cp < ce) cp++;
-
-	// ensure there's still data worth parsing
-	if(*cp == '\n' || cp >= ce) {
-		return;
-	}
-
-	// don't parse it if it's a comment
-	if(*cp == '#') {
-		return;
-	}
-
-	// It's retarded that I can't pass a buf/len combo to pcrs_compile_command.
-	// It's also retarded that pcrs won't tell me where it stopped parsing
-	// so that we can have multiple substitution clauses on line line.
-
-	if(ce-cp-1 < sizeof(buf)) {
-		string = buf;
-	} else {
-		string = malloc(ce-cp+1);
-		if(!string) {
-			perror("malloc in parse_modify_clause");
-			exit(10);
-		}
-	}
-
-	memcpy(string, cp, ce-cp);
-	string[ce-cp] = '\0';
-	job = pcrs_compile_command(string, &err);
-	if(job == NULL) {
-        fprintf(stderr, "%s line %d compile error: %s (%d).\n",
-                get_testfile_name(test), test->testfile.line,
-                pcrs_strerror(err), err);
-	}
-
-	if(ce-cp-1 < sizeof(buf)) {
-		// nothing to do; we used the static buffer
-	} else {
-		free(string);
-	}
-
-	if(job == NULL) {
-		return;
-	}
-
-	// link this job onto the end of the list.
-	p = &test->eachline;
-	while(*p) p = &(**p).next;
-	*p = job;
-}
-
-
 /**
  * Calls the given callback routine for each argument found.
  *
@@ -597,7 +527,7 @@
         return 0;
     }
 
-    compare_section_start(cmpscan, fd, test->eachline, val,
+    compare_section_start(cmpscan, fd, val,
         get_testfile_name(test), secname, suppress_trailing_newline);
 
     return 1;
@@ -699,10 +629,6 @@
             case exRESULT:
 				parse_exit_clause(test, datap, len);
                 break;
-            case exMODIFY:
-				parse_modify_clause(test, skip_section_name(datap,len),
-                        datap+len);
-                break;
         }
     } else {
         // we're continuing an already started section.
@@ -724,9 +650,6 @@
                     // Harmless to continue.  The testfile needs to be fixed.
 				}
                 break;
-            case exMODIFY:
-				parse_modify_clause(test, datap, datap+len);
-                break;
             case exCOMMAND:
                 break;
         }
@@ -798,7 +721,7 @@
 void test_results(struct test *test, const char *dispname)
 {
     scanstate scanner;
-    char scanbuf[MAX_LINE_LENGTH];
+    char scanbuf[BUFSIZ];
 	int stdo, stde, exno;	// true if there are differences.
 	
 	if(was_aborted(test->status)) {
@@ -886,7 +809,7 @@
 }
 
 
-int write_raw_file(int outfd, int infd)
+int write_file(int outfd, int infd)
 {
     char buf[BUFSIZ];
     int rcnt, wcnt;
@@ -924,81 +847,6 @@
 }
 
 
-static void write_modified_file(int outfd, int infd, pcrs_job *job)
-{
-    // this routine is fairly similar to compare_continue_lines.
-    // it would be nice to unify them.  that would take some fairly
-    // major surgery though.
-
-    scanstate scanner, *ss = &scanner;
-    char scanbuf[MAX_LINE_LENGTH];
-    const char *p;
-    char *new;
-    size_t newsize;
-    int rcnt, wcnt;
-
-    // first rewind the input file
-    if(lseek(infd, 0, SEEK_SET) < 0) {
-        fprintf(stderr, "write_file lseek on %d: %s\n", infd, strerror(errno));
-        exit(10);   // todo: consolidate with error codes in main
-    }
-
-    // create the scanner we'll use to buffer the lines
-    scanstate_init(ss, scanbuf, sizeof(scanbuf));
-    readfd_attach(ss, infd);
-
-    do {
-        p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-        if(!p) {
-            rcnt = (*ss->read)(ss);
-            if(rcnt < 0) {
-                // read error.  do something!
-                perror("reading in write_modified_file");
-                break;
-            }
-            p = memchr(ss->cursor, '\n', ss->limit - ss->cursor);
-            if(!p) {
-                p = ss->limit - 1;
-            }
-        }
-
-        p += 1;
-        new = substitute_string(job, ss->cursor, p, &newsize);
-        if(!new) {
-            // substitution error!  message already printed.
-            break;
-        }
-
-        do {
-            wcnt = write(outfd, new, newsize);
-        } while(wcnt < 0 && errno == EINTR);
-        free(new);
-        if(wcnt < 0) {
-            // write error.  do something!
-            perror("writing in write_modified_file");
-            break;
-        }
-        ss->cursor = p;
-    } while(rcnt);
-}
-
-
-static int write_file(int outfd, int infd, pcrs_job *job)
-{
-	if(!job) {
-		// use the simple, fast routine
-		return write_raw_file(outfd, infd);
-	}
-
-	// use the line buffered routine
-	// (don't bother with the return value because we
-	// know that MODIFY sections are going away in the
-	// next release anyway)
-	write_modified_file(outfd, infd, job);
-	return 1;
-}
-
-
 static void write_section(struct test *test, const char *datap, int len,
 		int fd, const char *name)
 {
@@ -1010,7 +858,7 @@
 			start_output_section_argproc, &marked_no_nl);
 
 	write(test->rewritefd, datap, len);
-	has_nl = write_file(test->rewritefd, fd, test->eachline);
+	has_nl = write_file(test->rewritefd, fd);
 
 	if(marked_no_nl) {
 		// if a section is marked with --no-trailing-newline, we need
@@ -1070,16 +918,6 @@
             write(test->rewritefd, datap, len);
             break;
 
-        case exMODIFY|exNEW:
-            parse_modify_clause(test, skip_section_name(datap,len), datap+len);
-            write(test->rewritefd, datap, len);
-            break;
-        case exMODIFY:
-            // parse modify sections and still print them.
-            parse_modify_clause(test, datap, datap+len);
-            write(test->rewritefd, datap, len);
-            break;
-            
         default:
             write(test->rewritefd, datap, len);
     }
@@ -1138,9 +976,6 @@
     test->stdout_match = match_unknown;
     test->stderr_match = match_unknown;
 
-    // ensure that we haven't yet parsed any modify sections.
-    assert(!test->eachline);
-
     scan_sections(test, &test->testfile, parse_section_output, &tempref);
 
     // if any sections haven't been output, but they differ from
@@ -1151,11 +986,11 @@
     }
     if(test->stderr_match == match_unknown && fd_has_data(test->errfd)) {
 		write_strconst(test->rewritefd, "STDERR:\n");
-        write_file(test->rewritefd, test->errfd, test->eachline);
+        write_file(test->rewritefd, test->errfd);
     }
     if(test->stdout_match == match_unknown && fd_has_data(test->outfd)) {
 		write_strconst(test->rewritefd, "STDOUT:\n");
-        write_file(test->rewritefd, test->outfd, test->eachline);
+        write_file(test->rewritefd, test->outfd);
     }
 }
 
@@ -1188,11 +1023,6 @@
 {
 	int err;
 
-	// the buffer for the testfile scanner is allocated on the stack.
-	if(test->eachline) {
-		pcrs_free_joblist(test->eachline);
-	}
-
 	if(test->diffname) {
 		err = close(test->diff_fd);
 		if(err < 0) {

Modified: trunk/test.h
===================================================================
--- trunk/test.h	2006-03-05 15:30:53 UTC (rev 105)
+++ trunk/test.h	2006-03-05 22:52:02 UTC (rev 106)
@@ -6,9 +6,7 @@
  * This file is covered by the MIT License.
  */
 
-#include "pcrs.h"
-#include "matchval.h"
-#include "re2c/scan.h"
+#include "compare.h"
 
 
 typedef enum {
@@ -51,8 +49,6 @@
     int exitsignal;         ///< the value returned for the test by waitpid(2)
     int exitcored;          ///< if exitsignal is true, true if child core dumped.
 
-	pcrs_job *eachline;		///< a linked list of pcrs jobs to be applied to each line.
-
 	char *diffname;			///< if we're diffing against stdin, this contains the name of the required tempfile.
 	int diff_fd;			///< if diffname is set, then this is the fd of the tempfile we're using to store stdin.
 
@@ -84,5 +80,5 @@
 
 // random utility function for start_diff.  Return value is true if the
 // file ends in a newline, false if not.
-int write_raw_file(int outfd, int infd);
+int write_file(int outfd, int infd);
 





From tmtest-commits at berlios.de  Mon Mar  6 22:56:21 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Mon, 6 Mar 2006 22:56:21 +0100
Subject: [Tmtest-commits] [107] trunk: Add unit testing, update re2c lib, refactor compare.c.
Message-ID: <200603062156.k26LuLNn004492@sheep.berlios.de>

Revision: 107
Author:   bronson
Date:     2006-03-06 22:56:19 +0100 (Mon, 06 Mar 2006)

Log Message:
-----------
Add unit testing, update re2c lib, refactor compare.c.

Modified Paths:
--------------
    trunk/CHANGES
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/compare.h
    trunk/examples/docs/testfile/Idiom-Indent1.test
    trunk/main.c
    trunk/re2c/read-fd.c
    trunk/re2c/read-fd.h
    trunk/re2c/read.c
    trunk/re2c/read.h
    trunk/re2c/scan.c
    trunk/re2c/scan.h
    trunk/test/03-results/02-Nstdout.test
    trunk/test/03-results/03-Nstdout.test
    trunk/test/03-results/04-Nstderr.test
    trunk/test/03-results/04-Nstdout.test
    trunk/test/03-results/10-NoNLFFail.test
    trunk/test/03-results/13-MultiNL.test
    trunk/test/03-results/13-MultiNLErr.test
    trunk/test.c
    trunk/test.h

Added Paths:
-----------
    trunk/cutest.c
    trunk/cutest.h
    trunk/re2c/read-fp.c
    trunk/re2c/read-fp.h
    trunk/re2c/read-mem.c
    trunk/re2c/read-mem.h
    trunk/re2c/read-rand.c
    trunk/re2c/read-rand.h
    trunk/re2c/scan-dyn.c
    trunk/re2c/scan-dyn.h
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/CHANGES	2006-03-06 21:56:19 UTC (rev 107)
@@ -1,4 +1,7 @@
-- Got rid of MODIFY clauses.  Use INDENT, REPLACE, or sed instead.
+- If an output section is marked -n but ends with multiple newlines, we print
+  a warning and fail it automatically.  We used to let this nonsense pass.
+- Added the Cutest unit test framework.  Refactored compare.c.
+- Got rid of MODIFY and all its code.  Use INDENT, REPLACE, or sed instead.
 
 Released 0.94 on 2 Mar 2006
 - NOTE: Bash3 has made it so that the regex can not appear on the same line as

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/Makefile	2006-03-06 21:56:19 UTC (rev 107)
@@ -32,20 +32,25 @@
 CSRC+=curdir.c qscandir.c pathconv.c
 CHDR+=curdir.h qscandir.h pathconv.h
 # scanner files
-CSRC+=re2c/read.c re2c/read-fd.c re2c/scan.c
-CHDR+=re2c/read.h re2c/read-fd.h re2c/scan.h
+CSRC+=re2c/read.c re2c/read-fd.c re2c/read-mem.c re2c/read-rand.c \
+	re2c/scan.c re2c/scan-dyn.c
+CHDR+=re2c/read.h re2c/read-fd.h re2c/read-mem.h re2c/read-rand.h \
+	re2c/scan.h re2c/scan-dyn.h
 # program files:
-CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c
+CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c template.c
 CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h
+# unit test files
+CSRC+=cutest.c
+CHDR+=cutest.h
 
 # It makes it rather hard to debug when Make deletes the intermediate files.
 INTERMED=stscan.c
 
 
-tmtest: $(CSRC) $(CHDR) template.c Makefile $(INTERMED)
-	$(CC) $(COPTS) $(CSRC) -lpcre template.c -o tmtest "-DVERSION=$(VERSION)"
+tmtest: $(CSRC) $(CHDR) $(INTERMED)
+	$(CC) $(COPTS) $(CSRC) -o tmtest -DVERSION="$(VERSION)"
 
-template.c: template.sh cstrfy Makefile
+template.c: template.sh cstrfy
 	./cstrfy -n exec_template < template.sh > template.c
 
 %.c: %.re
@@ -57,11 +62,8 @@
 
 .PHONY: test
 test: tmtest
-	./tmtest test
+	./tmtest --run-tests
 
-run: tmtest
-	./tmtest
-
 install: tmtest
 	install -d -m755 $(bindir)
 	install tmtest $(bindir)
@@ -72,7 +74,7 @@
 ifeq ($(wildcard $(conf_dst)),$(conf_dst))
 	# configuration already exists, don't overwrite it.
 	@echo "---> Not installing new config file over '$(conf_dst).'"
-	@echo "---> Please merge changes in 'sample.conf' by hand or run 'make uninstall' first."
+	@echo "---> Please merge changes in 'sample.conf' by hand."
 else
 	# global configuration file doesn't exist so install it
 	install sample.conf $(conf_dst)
@@ -93,7 +95,6 @@
 clean:
 	rm -f tmtest template.c tags
 
-# Ensure re2c is installed to regenerate the scanners before making distclean
 distclean: clean
 	rm -f stscan.[co]
 

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/TODO	2006-03-06 21:56:19 UTC (rev 107)
@@ -1,4 +1,5 @@
 0.96:
+- Get rid of all scan_is_finished() calls?
 - Make tmtest only execute config files owned by either the user or root.
   Print a big fat warning when the config file is skipped.  This prevents
   a malicious user from putting a config file in /tmp and having it
@@ -41,6 +42,7 @@
 - Add some unit tests.  http://kooditakomo.cs.tut.fi/projects/gunit/
   http://pvanhoof.be/blog/index.php/2006/03/03/tinymail-unit-testing-and-creating-messages     Actually, this looks better: http://cutest.sourceforge.net/
   Potential units: curdir, path normalization
+- Get rid of -g, add -O2.  Make it easy to set these for compilation.
 
 0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.
@@ -75,6 +77,8 @@
   can find.  It prints nothing if a test succeeds, or the fail notice
   if it fails.  Runs until cancelled with ^C.  Let it run overnight and
   see if any of your tests have intermittent failures.
+- Reomve as many TODOs as possible.
+- Make zutest take the names of tests to run on stdin?
 
 1.0!
 

Modified: trunk/compare.c
===================================================================
--- trunk/compare.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/compare.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -11,131 +11,107 @@
  * This uses all re2c's mechanisms for creating buffers and loading
  * them with data, but it's not actually an re2c scanner.
  *
- * Here's what you do:
- * - Create a scanstate attached to one stream and pass it to compare_start.
- * - Read some data from the other stream and pass it to compare_continue.
- * - Keep reading until you're out of data.  You can check compare_in_progress
- *   to see if the match already failed and you can bail out early.
- * - When you're out of data, call compare_end to obtain the result.
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
-
 #include "compare.h"
 
 
-// TODO: these are all 1-bit flags.  No need for malloc and free!
-// get rid of the output field.
+#define STATE (*(int*)&(ss)->scanref)
 
-typedef struct {
-	matchval *output;
-	const char *pbuf;
-    int no_trailing_newline;    ///< true if this section isn't supposed to end with a newline
-    int nl_suppressed;          ///< if no_trailing_newline is true, we need to suppress the newline in the execpted output when matching against the actual (because of the way heredocs work, the expected always ends in a newline).
-    int warn_no_newline;             ///< true if the section expected a trailing newline (no_trailing_newline == false), but the last buffer seen (presumably the end of the file) didn't end with a newline.
-} compare_state;
+/**
+ * Sets up the scanstate for a new comparison.
+ *
+ * Here's how you use the comparison code:
+ * - Create a scanstate attached to one stream and pass it to compare_start().
+ * - Read some data from the other stream and pass it to compare_continue().
+ * - Keep reading until you're out of data or compare_continue() returns 1.
+ *     (no harm to keep passing data except that you're just wasting time)
+ * - When you're out of data, call compare_end to obtain the result.
+ */
 
-
-static int compare_fill(scanstate *ss)
+void compare_attach(scanstate *ss)
 {
-    // need to pretend like we're updating the token,
-    // otherwise the readproc will think we need to keep
-    // the token and we quickly run out of buffer room.
-    ss->token = ss->cursor;
-
-    return (*ss->read)(ss);
+	// STATE is -1 while ss still has data.  If not -1, then it tells
+	// us how many bytes ago it ran out of data.
+	STATE = cmp_in_progress;
 }
 
 
-static void compare_halt(scanstate *ss, matchval newval)
-{
-	compare_state *cmp = (compare_state*)ss->scanref;
-    *cmp->output = newval;
-}
+// Returns true if and only if the stream has exactly one character
+// in it, a newline.
 
-
-void compare_attach(scanstate *ss, matchval *mv, int nonl)
+static int has_extra_nl(const char *ptr, size_t len)
 {
-	compare_state *cmp = malloc(sizeof(compare_state));
-	if(cmp == NULL) {
-		perror("compare_attach");
-		exit(10);
+	if(len == 1 && ptr[0] == '\n') {
+		return 1;
 	}
-	memset(cmp, 0, sizeof(compare_state));
 
-    *mv = match_inprogress;
-
-	cmp->output = mv;
-    cmp->no_trailing_newline = nonl;
-    cmp->nl_suppressed = 0;
-    cmp->warn_no_newline = 0;
-    ss->scanref = cmp;
+	return 0;
 }
 
 
 
-void compare_continue(scanstate *ss, const char *ptr, int len)
+/**
+ * Feeds more bytes to the comparison engine.
+ * 
+ * @param ss The scanstate from compare_attach.
+ * @param ptr The start of the data to compare.
+ * @param len The number of bytes to compare, from 0 to MAXINT.
+ *
+ * @returns 0 if we still don't have an answer, 1 if the match
+ * failed.
+ */
+
+int compare_continue(scanstate *ss, const char *ptr, size_t len)
 {
-	compare_state *cmp = (compare_state*)ss->scanref;
+	int prev_had_nl = 0;
     int n;
 
-    if(*cmp->output != match_inprogress) {
-        // we already decided an answer
-        // so don't waste time comparing more.
-        return;
+    if(STATE != cmp_in_progress) {
+		if(len > 0) {
+			// if the only difference to this point was a \n, state
+			// is has_extra_nl.  If there's more data, though, then no match.
+			STATE = cmp_no_match;
+		}
+        return 1;
     }
 
-    assert(len >= 0);
+    while(len > 0) {
+        n = ss->limit - ss->cursor;
+        if(!n) {
 
-    if(cmp->no_trailing_newline) {
-        // If the incoming buffer ends in a nl, we need to suppress it
-        // for the comparison.  Note that this won't work well for
-        // MODIFY clauses but I don't care because MODIFY will never
-        // work with -n and, anyway, MODIFY is about to disappear.
-
-        if(cmp->nl_suppressed) {
-            cmp->nl_suppressed = 0;
-			if(ss->cursor < ss->limit) {
-				if(ss->cursor[0] != '\n') {
-					compare_halt(ss, match_no);
-					return;
-				}
-				ss->cursor += 1;
-			} else {
-				compare_continue(ss, "\n", 1);
+			// need to remember if the previous (and possibly the last)
+			// buffer ended in a newline so we can set the proper flag.
+			if(ss->cursor > ss->bufptr && ss->cursor[-1] == '\n') {
+				prev_had_nl = 1;
 			}
-        }
 
-        if(ptr[len-1] == '\n') {
-            cmp->nl_suppressed = 1;
-            len -= 1;
-        }
-    }
-
-    while(len > 0) {
-        n = ss->limit - ss->cursor;
-        if(!n) {
-            n = compare_fill(ss);
+			ss->token = ss->cursor;
+            n = (*ss->read)(ss);
             ss->line += n;
             if(n < 0) {
                 // there was an error while trying to fill the buffer
-                // TODO: this should be propagated to the client somehow.
+                // TODO: this should be propagated to the client somehow?
                 perror("compare_continue_bytes");
                 exit(10);
             }
             if(n == 0) {
-                compare_halt(ss, match_no);
-                return;
+				// banged into the EOF
+				if(has_extra_nl(ptr,len)) {
+					if(prev_had_nl) {
+						STATE = cmp_ptr_has_more_nls;
+					} else {
+						STATE = cmp_ptr_has_extra_nl;
+					}
+				} else {
+					STATE = cmp_no_match;
+				}
+                return 1;
             }
-           
-            if(n > 0) {
-                // shouldn't force user to put a -n on empty sections!
-                // therefore, we'll only issue the warning if we've seen data.
-                cmp->warn_no_newline = (ss->limit[-1] != '\n' && ss->limit[-1] != '\r');
-            }
         }
 
         if(len < n) {
@@ -144,38 +120,264 @@
 
         // compare
         if(memcmp(ptr, ss->cursor, n) != 0) {
-            compare_halt(ss, match_no);
-            return;
+			STATE = cmp_no_match;
+			return 1;
         }
+
         ptr += n;
         ss->cursor += n;
         len -= n;
     }
+
+	return 0;
 }
 
 
-void compare_end(scanstate *ss, int *warn_nl)
+/**
+ * Returns true if the streams are both out of data and have matched
+ * byte-for-byte up to this point, otherwise returns false.
+ */
+
+compare_result compare_check(scanstate *ss, const char *ptr, size_t len)
 {
-	compare_state *cmp = (compare_state*)ss->scanref;
+	int ptr_empty = (ptr == NULL || len == 0);
+	int ss_empty = scan_is_finished(ss);
 
-    // Tell the caller to emit a warning if the expected section was marked
-    // as having a trailing newline but the actual section didn't have it.
-    if(warn_nl && !cmp->no_trailing_newline) {
-        *warn_nl = cmp->warn_no_newline;
-    }
 
-    if(*cmp->output == match_inprogress) {
-        assert(ss->cursor <= ss->limit);
+	if(STATE != cmp_in_progress) {
+		return STATE;
+	}
 
-        *cmp->output = match_no;
-        if(scan_finished(ss)) {
-            // if we're totally out of data and we still don't know
-            // if they match, then they do match.
-            *cmp->output = match_yes;
-        }
-    }
+	if(ptr_empty && ss_empty) {
+		// both streams are out of data
+		return cmp_full_match;
+	}
 
-	free(cmp);
-    ss->scanref = NULL;
+	if(ptr_empty && !ss_empty) {
+		return cmp_ss_has_more_data;
+	}
+
+	return cmp_no_match;
 }
 
+
+/**
+ * This is a little complex...  It checks the newline status of the
+ * streams.  If one stream had exactly one more newline at this point
+ * than the other, it returns a custom value.  Otherwise, if the streams
+ * are byte-for-byte identical, it returns cmp_full_match,
+ * otherwise compare_no_match.
+ *
+ * If you call this routine when neither stream is at EOF then it
+ * always returns compare_no_match because it can't be sure that
+ * either stream will match.  The lesson?  Only call this function
+ * when one of the streams is out of data.
+ *
+ * @param ss the comparison scanner set up by compare_attach().
+ * @param ptr The final data from the stream.  If NULL, treated as EOF
+ * 	(though typically a 0 len indicates EOF).
+ * @param len the amount of data in ptr.  0 indicates EOF.
+ *
+ * @returns the appropriate value from compare_result.
+ */
+
+compare_result compare_check_newlines(scanstate *ss, const char *ptr, size_t len)
+{
+	int ptr_empty = (ptr == NULL || len == 0);
+	int ss_empty = scan_is_finished(ss);
+
+	if(STATE != cmp_in_progress) {
+		return STATE;
+	}
+
+	if(ptr_empty && ss_empty) {
+		// both streams are out of data
+		return cmp_full_match;
+	}
+
+	if(!ptr_empty && ss_empty && has_extra_nl(ptr, len)) {
+		return cmp_ptr_has_extra_nl;
+	}
+
+	if(!ss_empty&&ptr_empty&&has_extra_nl(ss->cursor,ss->limit-ss->cursor)) {
+		return cmp_ss_has_extra_nl;
+	}
+
+	if(ptr_empty && !ss_empty) {
+		return cmp_ss_has_more_data;
+	}
+
+	return cmp_no_match;
+}
+
+
+#include "cutest.h"
+#include "re2c/read-mem.h"
+#include "re2c/read-rand.h"
+#include <stdlib.h>
+
+static void test_empty(cutest *ct)
+{
+	scanstate ssrec, *ss=&ssrec;
+
+	readmem_init_str(ss, "");
+	compare_attach(ss);
+	AssertEq(compare_check(ss,0,0), cmp_full_match);
+
+	readmem_init_str(ss, "");
+	compare_attach(ss);
+	compare_continue(ss, "", 0);
+	AssertEq(compare_check(ss,0,0), cmp_full_match);
+}
+
+
+static void test_standard(cutest *ct)
+{
+	scanstate ssrec, *ss=&ssrec;
+
+	readmem_init_str(ss, "123");
+	compare_attach(ss);
+	compare_continue(ss, "12", 2);
+	compare_continue(ss, "3", 1);
+	AssertEq(compare_check(ss,0,0), cmp_full_match);
+}
+
+
+static void test_large(cutest *ct)
+{
+	char buf[BUFSIZ];
+	scanstate ssrec, *ss=&ssrec;
+	unsigned int seed = 47;
+	int num, i;
+
+	scanstate_init(ss, buf, BUFSIZ);
+	readrand_attach(ss, seed);
+	compare_attach(ss);
+	for(i=0; i<10; i++) {
+		num = rand_r(&seed);
+		compare_continue(ss, (char*)&num, sizeof(num));
+	}
+
+	// compare_check will never return cmp_full_match because
+	// the random reader will never run out of data.
+	AssertEq(compare_check(ss,0,0), cmp_ss_has_more_data);
+}
+
+
+static void test_strings(scanstate *ss, const char *s1, const char *s2)
+{
+	readmem_init(ss, s1, strlen(s1));
+	compare_attach(ss);
+	compare_continue(ss, s2, strlen(s2));
+}
+
+
+static compare_result check_newlines(const char *s1, const char *s2)
+{
+	scanstate ssrec, *ss=&ssrec;
+	test_strings(ss, s1, s2);
+	return compare_check_newlines(ss, NULL, 0);
+}
+
+
+static void test_newlines(cutest *ct)
+{
+	AssertEq(check_newlines("Unix\n",   "Unix\n"  ), cmp_full_match);
+	AssertEq(check_newlines("Unix",     "Unix\n"  ), cmp_ptr_has_extra_nl);
+	AssertEq(check_newlines("Unix\n",   "Unix"    ), cmp_ss_has_extra_nl);
+	AssertEq(check_newlines("Unix",     "Unix"    ), cmp_full_match);
+
+	AssertEq(check_newlines("Unix\n\n", "Unix\n"  ), cmp_ss_has_extra_nl);
+	AssertEq(check_newlines("Unix\n",   "Unix\n\n"), cmp_ptr_has_extra_nl);
+
+	// empty buffers (except for newlines)
+	AssertEq(check_newlines("\n",   ""     ), cmp_ss_has_extra_nl);
+	AssertEq(check_newlines("",     "\n"   ), cmp_ptr_has_extra_nl);
+	AssertEq(check_newlines("\n\n", ""     ), cmp_ss_has_more_data);
+	AssertEq(check_newlines("",     "\n\n" ), cmp_no_match);
+}
+
+static void test_inc(cutest *ct)
+{
+	// Tries to ensure that packetization won't mess us up.
+
+	scanstate ssrec, *ss=&ssrec;
+
+	readmem_init_str(ss, "12");
+	compare_attach(ss);
+	compare_continue(ss, "1", 1);
+	compare_continue(ss, "2", 1);
+	compare_continue(ss, "\n", 1);
+	AssertEq(compare_check(ss,0,0), cmp_ptr_has_extra_nl);
+
+	readmem_init_str(ss, "123");
+	compare_attach(ss);
+	compare_continue(ss, "1", 1);
+	compare_continue(ss, "2", 1);
+	compare_continue(ss, "\n", 1);
+	AssertEq(compare_check(ss,0,0), cmp_no_match);
+
+	readmem_init_str(ss, "");
+	compare_attach(ss);
+	AssertEq(compare_check(ss,"\n",1), cmp_no_match);
+}
+
+
+static void test_inc_newlines(cutest *ct)
+{
+	// Tries to ensure packetization won't mess up the newline checking.
+
+	scanstate ssrec, *ss=&ssrec;
+
+	readmem_init_str(ss, "123");
+	compare_attach(ss);
+	compare_continue(ss, "1", 1);
+	compare_continue(ss, "2", 1);
+	compare_continue(ss, "3", 1);
+	compare_continue(ss, "\n", 1);
+	AssertEq(compare_check_newlines(ss,0,0), cmp_ptr_has_extra_nl);
+
+	readmem_init_str(ss, "123\n");
+	compare_attach(ss);
+	compare_continue(ss, "1", 1);
+	compare_continue(ss, "2", 1);
+	compare_continue(ss, "3", 1);
+	AssertEq(compare_check_newlines(ss,0,0), cmp_ss_has_extra_nl);
+
+	readmem_init_str(ss, "");
+	compare_attach(ss);
+	AssertEq(compare_check_newlines(ss,"\n",1), cmp_ptr_has_extra_nl);
+
+	readmem_init_str(ss, "");
+	compare_attach(ss);
+	compare_continue(ss, "\n", 1);
+	AssertEq(compare_check_newlines(ss,0,0), cmp_ptr_has_extra_nl);
+
+	readmem_init_str(ss, "\n");
+	compare_attach(ss);
+	AssertEq(compare_check_newlines(ss,0,0), cmp_ss_has_extra_nl);
+}
+
+
+/*
+static void test_tiny_buffer(cutest *ct)
+{
+	// need to ensure that we can pass a ptr bigger than buf.
+}
+*/
+
+
+cusuite* compare_suite()
+{
+	cusuite* suite = CuSuiteNew();
+
+	suite_add(suite, test_empty);
+	suite_add(suite, test_standard);
+	suite_add(suite, test_large);
+	suite_add(suite, test_newlines);
+	suite_add(suite, test_inc);
+	suite_add(suite, test_inc_newlines);
+
+	return suite;
+}
+

Modified: trunk/compare.h
===================================================================
--- trunk/compare.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/compare.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -2,40 +2,29 @@
  * Scott Bronson
  * 31 Dec 2004
  *
- * File comparison prototypes.
- *
  * See compare.c for license.
  */
 
 #include "re2c/scan.h"
 
 
-
 /**
- * a tristate that tells whether something
- *    - matches
- *    - doesn't match
- *    - hasn't been checked yet.
+ * Unless you get a return value of cmp_full_match, the streams
+ * were not exactly equal.
  */
 
 typedef enum {
-    match_inprogress = -2,
-    match_unknown = -1,
-    match_no = 0,
-    match_yes = 1,
-} matchval;
+	cmp_in_progress = -1,	///< internal state; will never be returned.
+	cmp_full_match = 0,		///< data doesn't match at all
+	cmp_no_match,			///< data matches exactly
+	cmp_ptr_has_extra_nl,	///< the scanner has an extra newline
+	cmp_ptr_has_more_nls,	///< ok, this is a problem...  the app needs to know if the ss ended in a newline so it can suppress the -n warning.  So, cmp_ss_has_extra_nl means that ss didn't end in a nl, ptr did, but other than that they were identical.  cm_ptr_has_more_nls means that ss did end in a nl, ptr did too, and ptr and ss were exactly the same except ptr has one more newline.  In summary: both of these mean that ptr has one more nl than ss.  It's just whether ss ended with a newline (cmp_ptr_has_more_nls) or not (cmp_ptr_has_extra_nl).
+	cmp_ss_has_extra_nl,	///< the data passed to continue has ex. CR
+	cmp_ss_has_more_data	///< ptr and ss matched up to now
+} compare_result;
 
 
-
-
-/** Returns zero if the compare has stopped (i.e. the files differed),
- *  one if we're still unsure.
- */
-
-#define compare_in_progress(ss) ((ss)->scanref)
-
-
-void compare_attach(scanstate *ss, matchval *mv, int nonl);
-void compare_continue(scanstate *ss, const char *ptr, int len);
-void compare_end(scanstate *cmp, int *warn_nl);
-
+void compare_attach(scanstate *ss);
+int compare_continue(scanstate *ss, const char *ptr, size_t len);
+compare_result compare_check(scanstate *ss, const char *ptr, size_t len);
+compare_result compare_check_newlines(scanstate *ss, const char *ptr, size_t len);

Added: trunk/cutest.c
===================================================================
--- trunk/cutest.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/cutest.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,353 @@
+/* 	http://cutest.sf.net
+
+NOTE
+
+The license is based on the zlib/libpng license. For more details see
+http://www.opensource.org/licenses/zlib-license.html. The intent of the
+license is to: 
+
+- keep the license as simple as possible
+- encourage the use of CuTest in both free and commercial applications
+  and libraries
+- keep the source code together 
+- give credit to the CuTest contributors for their work
+
+If you ship CuTest in source form with your source distribution, the
+following license document must be included with it in unaltered form.
+If you find CuTest useful we would like to hear about it. 
+
+LICENSE
+
+Copyright (c) 2003 Asim Jalis
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must not
+claim that you wrote the original software. If you use this software in
+a product, an acknowledgment in the product documentation would be
+appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and must not
+be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+
+*/
+
+
+#include <assert.h>
+#include <setjmp.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+#include "cutest.h"
+
+/*-------------------------------------------------------------------------*
+ * CuStr
+ *-------------------------------------------------------------------------*/
+
+char* CuStrAlloc(int size)
+{
+	char* newStr = (char*) malloc( sizeof(char) * (size) );
+	return newStr;
+}
+
+char* CuStrCopy(const char* old)
+{
+	int len = strlen(old);
+	char* newStr = CuStrAlloc(len + 1);
+	strcpy(newStr, old);
+	return newStr;
+}
+
+/*-------------------------------------------------------------------------*
+ * CuString
+ *-------------------------------------------------------------------------*/
+
+void CuStringInit(CuString* str)
+{
+	str->length = 0;
+	str->size = STRING_MAX;
+	str->buffer = (char*) malloc(sizeof(char) * str->size);
+	str->buffer[0] = '\0';
+}
+
+CuString* CuStringNew(void)
+{
+	CuString* str = (CuString*) malloc(sizeof(CuString));
+	str->length = 0;
+	str->size = STRING_MAX;
+	str->buffer = (char*) malloc(sizeof(char) * str->size);
+	str->buffer[0] = '\0';
+	return str;
+}
+
+void CuStringResize(CuString* str, int newSize)
+{
+	str->buffer = (char*) realloc(str->buffer, sizeof(char) * newSize);
+	str->size = newSize;
+}
+
+void CuStringAppend(CuString* str, const char* text)
+{
+	int length;
+
+	if (text == NULL) {
+		text = "NULL";
+	}
+
+	length = strlen(text);
+	if (str->length + length + 1 >= str->size)
+		CuStringResize(str, str->length + length + 1 + STRING_INC);
+	str->length += length;
+	strcat(str->buffer, text);
+}
+
+void CuStringAppendChar(CuString* str, char ch)
+{
+	char text[2];
+	text[0] = ch;
+	text[1] = '\0';
+	CuStringAppend(str, text);
+}
+
+void CuStringAppendFormat(CuString* str, const char* format, ...)
+{
+	va_list argp;
+	char buf[HUGE_STRING_LEN];
+	va_start(argp, format);
+	vsprintf(buf, format, argp);
+	va_end(argp);
+	CuStringAppend(str, buf);
+}
+
+void CuStringInsert(CuString* str, const char* text, int pos)
+{
+	int length = strlen(text);
+	if (pos > str->length)
+		pos = str->length;
+	if (str->length + length + 1 >= str->size)
+		CuStringResize(str, str->length + length + 1 + STRING_INC);
+	memmove(str->buffer + pos + length, str->buffer + pos, (str->length - pos) + 1);
+	str->length += length;
+	memcpy(str->buffer + pos, text, length);
+}
+
+/*-------------------------------------------------------------------------*
+ * CuTest
+ *-------------------------------------------------------------------------*/
+
+void CuTestInit(CuTest* t, const char* name, TestFunction function)
+{
+	t->name = CuStrCopy(name);
+	t->failed = 0;
+	t->ran = 0;
+	t->message = NULL;
+	t->function = function;
+	t->jumpBuf = NULL;
+}
+
+CuTest* CuTestNew(const char* name, TestFunction function)
+{
+	CuTest* tc = CU_ALLOC(CuTest);
+	CuTestInit(tc, name, function);
+	return tc;
+}
+
+void CuTestRun(CuTest* tc)
+{
+	jmp_buf buf;
+	tc->jumpBuf = &buf;
+	if (setjmp(buf) == 0)
+	{
+		tc->ran = 1;
+		(tc->function)(tc);
+	}
+	tc->jumpBuf = 0;
+}
+
+static void CuFailInternal(CuTest* tc, const char* file, int line, CuString* string)
+{
+	char buf[HUGE_STRING_LEN];
+
+	sprintf(buf, "%s:%d: ", file, line);
+	CuStringInsert(string, buf, 0);
+
+	tc->failed = 1;
+	tc->message = string->buffer;
+	if (tc->jumpBuf != 0) longjmp(*(tc->jumpBuf), 0);
+}
+
+void CuFail_Line(CuTest* tc, const char* file, int line, const char* message2, const char* message)
+{
+	CuString string;
+
+	CuStringInit(&string);
+	if (message2 != NULL) 
+	{
+		CuStringAppend(&string, message2);
+		CuStringAppend(&string, ": ");
+	}
+	CuStringAppend(&string, message);
+	CuFailInternal(tc, file, line, &string);
+}
+
+void CuAssert_Line(CuTest* tc, const char* file, int line, const char* message, int condition)
+{
+	if (condition) return;
+	CuFail_Line(tc, file, line, NULL, message);
+}
+
+void CuAssertStrEquals_LineMsg(CuTest* tc, const char* file, int line, const char* message, 
+	const char* expected, const char* actual)
+{
+	CuString string;
+	if ((expected == NULL && actual == NULL) ||
+	    (expected != NULL && actual != NULL &&
+	     strcmp(expected, actual) == 0))
+	{
+		return;
+	}
+
+	CuStringInit(&string);
+	if (message != NULL) 
+	{
+		CuStringAppend(&string, message);
+		CuStringAppend(&string, ": ");
+	}
+	CuStringAppend(&string, "expected <");
+	CuStringAppend(&string, expected);
+	CuStringAppend(&string, "> but was <");
+	CuStringAppend(&string, actual);
+	CuStringAppend(&string, ">");
+	CuFailInternal(tc, file, line, &string);
+}
+
+void CuAssertIntEquals_LineMsg(CuTest* tc, const char* file, int line, const char* message, 
+	int expected, int actual)
+{
+	char buf[STRING_MAX];
+	if (expected == actual) return;
+	sprintf(buf, "expected <%d> but was <%d>", expected, actual);
+	CuFail_Line(tc, file, line, message, buf);
+}
+
+void CuAssertDblEquals_LineMsg(CuTest* tc, const char* file, int line, const char* message, 
+	double expected, double actual, double delta)
+{
+	char buf[STRING_MAX];
+	if (fabs(expected - actual) <= delta) return;
+	sprintf(buf, "expected <%lf> but was <%lf>", expected, actual);
+	CuFail_Line(tc, file, line, message, buf);
+}
+
+void CuAssertPtrEquals_LineMsg(CuTest* tc, const char* file, int line, const char* message, 
+	void* expected, void* actual)
+{
+	char buf[STRING_MAX];
+	if (expected == actual) return;
+	sprintf(buf, "expected pointer <0x%p> but was <0x%p>", expected, actual);
+	CuFail_Line(tc, file, line, message, buf);
+}
+
+
+/*-------------------------------------------------------------------------*
+ * CuSuite
+ *-------------------------------------------------------------------------*/
+
+void CuSuiteInit(CuSuite* testSuite)
+{
+	testSuite->count = 0;
+	testSuite->failCount = 0;
+}
+
+CuSuite* CuSuiteNew(void)
+{
+	CuSuite* testSuite = CU_ALLOC(CuSuite);
+	CuSuiteInit(testSuite);
+	return testSuite;
+}
+
+void CuSuiteAdd(CuSuite* testSuite, CuTest *testCase)
+{
+	assert(testSuite->count < MAX_TEST_CASES);
+	testSuite->list[testSuite->count] = testCase;
+	testSuite->count++;
+}
+
+void CuSuiteAddSuite(CuSuite* testSuite, CuSuite* testSuite2)
+{
+	int i;
+	for (i = 0 ; i < testSuite2->count ; ++i)
+	{
+		CuTest* testCase = testSuite2->list[i];
+		CuSuiteAdd(testSuite, testCase);
+	}
+}
+
+void CuSuiteRun(CuSuite* testSuite)
+{
+	int i;
+	for (i = 0 ; i < testSuite->count ; ++i)
+	{
+		CuTest* testCase = testSuite->list[i];
+		CuTestRun(testCase);
+		if (testCase->failed) { testSuite->failCount += 1; }
+	}
+}
+
+void CuSuiteSummary(CuSuite* testSuite, CuString* summary)
+{
+	int i;
+	for (i = 0 ; i < testSuite->count ; ++i)
+	{
+		CuTest* testCase = testSuite->list[i];
+		CuStringAppend(summary, testCase->failed ? "F" : ".");
+	}
+	CuStringAppend(summary, "\n\n");
+}
+
+void CuSuiteDetails(CuSuite* testSuite, CuString* details)
+{
+	int i;
+	int failCount = 0;
+
+	if (testSuite->failCount == 0)
+	{
+		int passCount = testSuite->count - testSuite->failCount;
+		const char* testWord = passCount == 1 ? "test" : "tests";
+		CuStringAppendFormat(details, "OK (%d %s)\n", passCount, testWord);
+	}
+	else
+	{
+		if (testSuite->failCount == 1)
+			CuStringAppend(details, "There was 1 failure:\n");
+		else
+			CuStringAppendFormat(details, "There were %d failures:\n", testSuite->failCount);
+
+		for (i = 0 ; i < testSuite->count ; ++i)
+		{
+			CuTest* testCase = testSuite->list[i];
+			if (testCase->failed)
+			{
+				failCount++;
+				CuStringAppendFormat(details, "%d) %s: %s\n",
+					failCount, testCase->name, testCase->message);
+			}
+		}
+		CuStringAppend(details, "\n!!!FAILURES!!!\n");
+
+		CuStringAppendFormat(details, "Runs: %d ",   testSuite->count);
+		CuStringAppendFormat(details, "Passes: %d ", testSuite->count - testSuite->failCount);
+		CuStringAppendFormat(details, "Fails: %d\n",  testSuite->failCount);
+	}
+}

Added: trunk/cutest.h
===================================================================
--- trunk/cutest.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/cutest.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,124 @@
+#ifndef CU_TEST_H
+#define CU_TEST_H
+
+#include <setjmp.h>
+#include <stdarg.h>
+
+/* CuString */
+
+char* CuStrAlloc(int size);
+char* CuStrCopy(const char* old);
+
+#define CU_ALLOC(TYPE)		((TYPE*) malloc(sizeof(TYPE)))
+
+#define HUGE_STRING_LEN	8192
+#define STRING_MAX		256
+#define STRING_INC		256
+
+typedef struct
+{
+	int length;
+	int size;
+	char* buffer;
+} CuString;
+
+void CuStringInit(CuString* str);
+CuString* CuStringNew(void);
+void CuStringRead(CuString* str, const char* path);
+void CuStringAppend(CuString* str, const char* text);
+void CuStringAppendChar(CuString* str, char ch);
+void CuStringAppendFormat(CuString* str, const char* format, ...);
+void CuStringInsert(CuString* str, const char* text, int pos);
+void CuStringResize(CuString* str, int newSize);
+
+/* CuTest */
+
+typedef struct CuTest CuTest;
+
+typedef void (*TestFunction)(CuTest *);
+
+struct CuTest
+{
+	const char* name;
+	TestFunction function;
+	int failed;
+	int ran;
+	const char* message;
+	jmp_buf *jumpBuf;
+};
+
+void CuTestInit(CuTest* t, const char* name, TestFunction function);
+CuTest* CuTestNew(const char* name, TestFunction function);
+void CuTestRun(CuTest* tc);
+
+/* Internal versions of assert functions -- use the public versions */
+void CuFail_Line(CuTest* tc, const char* file, int line, const char* message2, const char* message);
+void CuAssert_Line(CuTest* tc, const char* file, int line, const char* message, int condition);
+void CuAssertStrEquals_LineMsg(CuTest* tc, 
+	const char* file, int line, const char* message, 
+	const char* expected, const char* actual);
+void CuAssertIntEquals_LineMsg(CuTest* tc, 
+	const char* file, int line, const char* message, 
+	int expected, int actual);
+void CuAssertDblEquals_LineMsg(CuTest* tc, 
+	const char* file, int line, const char* message, 
+	double expected, double actual, double delta);
+void CuAssertPtrEquals_LineMsg(CuTest* tc, 
+	const char* file, int line, const char* message, 
+	void* expected, void* actual);
+
+/* public assert functions */
+
+#define CuFail(tc, ms)                        CuFail_Line(  (tc), __FILE__, __LINE__, NULL, (ms))
+#define CuAssert(tc, ms, cond)                CuAssert_Line((tc), __FILE__, __LINE__, (ms), (cond))
+#define CuAssertTrue(tc, cond)                CuAssert_Line((tc), __FILE__, __LINE__, "assert failed", (cond))
+
+#define CuAssertStrEquals(tc,ex,ac)           CuAssertStrEquals_LineMsg((tc),__FILE__,__LINE__,NULL,(ex),(ac))
+#define CuAssertStrEquals_Msg(tc,ms,ex,ac)    CuAssertStrEquals_LineMsg((tc),__FILE__,__LINE__,(ms),(ex),(ac))
+#define CuAssertIntEquals(tc,ex,ac)           CuAssertIntEquals_LineMsg((tc),__FILE__,__LINE__,NULL,(ex),(ac))
+#define CuAssertIntEquals_Msg(tc,ms,ex,ac)    CuAssertIntEquals_LineMsg((tc),__FILE__,__LINE__,(ms),(ex),(ac))
+#define CuAssertDblEquals(tc,ex,ac,dl)        CuAssertDblEquals_LineMsg((tc),__FILE__,__LINE__,NULL,(ex),(ac),(dl))
+#define CuAssertDblEquals_Msg(tc,ms,ex,ac,dl) CuAssertDblEquals_LineMsg((tc),__FILE__,__LINE__,(ms),(ex),(ac),(dl))
+#define CuAssertPtrEquals(tc,ex,ac)           CuAssertPtrEquals_LineMsg((tc),__FILE__,__LINE__,NULL,(ex),(ac))
+#define CuAssertPtrEquals_Msg(tc,ms,ex,ac)    CuAssertPtrEquals_LineMsg((tc),__FILE__,__LINE__,(ms),(ex),(ac))
+
+#define CuAssertPtrNotNull(tc,p)        CuAssert_Line((tc),__FILE__,__LINE__,"null pointer unexpected",(p != NULL))
+#define CuAssertPtrNotNullMsg(tc,msg,p) CuAssert_Line((tc),__FILE__,__LINE__,(msg),(p != NULL))
+
+/* CuSuite */
+
+#define MAX_TEST_CASES	1024
+
+#define SUITE_ADD_TEST(SUITE,TEST)	CuSuiteAdd(SUITE, CuTestNew(#TEST, TEST))
+
+typedef struct
+{
+	int count;
+	CuTest* list[MAX_TEST_CASES];
+	int failCount;
+
+} CuSuite;
+
+
+void CuSuiteInit(CuSuite* testSuite);
+CuSuite* CuSuiteNew(void);
+void CuSuiteAdd(CuSuite* testSuite, CuTest *testCase);
+void CuSuiteAddSuite(CuSuite* testSuite, CuSuite* testSuite2);
+void CuSuiteRun(CuSuite* testSuite);
+void CuSuiteSummary(CuSuite* testSuite, CuString* summary);
+void CuSuiteDetails(CuSuite* testSuite, CuString* details);
+
+
+#define cusuite CuSuite
+#define cutest CuTest
+#define suite_add(s,t) SUITE_ADD_TEST(s,t)
+#define Assert(cond) CuAssert(ct, #cond, cond)
+
+#define AssertEq(c1,c2) Assert(c1 == c2)
+#define AssertNe(c1,c2) Assert(c1 != c2)
+#define AssertGt(c1,c2) Assert(c1 > c2)
+#define AssertGe(c1,c2) Assert(c1 >= c2)
+#define AssertLt(c1,c2) Assert(c1 < c2)
+#define AssertLe(c1,c2) Assert(c1 <= c2)
+
+#endif /* CU_TEST_H */

Modified: trunk/examples/docs/testfile/Idiom-Indent1.test
===================================================================
--- trunk/examples/docs/testfile/Idiom-Indent1.test	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/examples/docs/testfile/Idiom-Indent1.test	2006-03-06 21:56:19 UTC (rev 107)
@@ -1,4 +1,4 @@
-DISABLED: neads streaming tmtest?
+DISABLED: needs streaming tmtest?
 
 echo test output > >(INDENT)
 

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/main.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -46,6 +46,7 @@
 int allfiles = 0;
 int dumpscript = 0;
 int quiet = 0;
+int run_unit_tests = 0;
 const char *orig_cwd;		// tmtest runs with the cwd pointed to /tmp
 char *config_file;	// absolute path to the user-specified config file
 					// null if user didn't specify a config file.
@@ -1010,6 +1011,7 @@
 		{"help", 0, 0, 'h'},
 		{"output", 0, 0, 'o'},
 		{"quiet", 0, 0, 'q'},
+		{"run-tests", 0, 0, 'U'},
 		{"version", 0, 0, 'V'},
 		{0, 0, 0, 0},
 	};
@@ -1051,6 +1053,10 @@
 				quiet++;
 				break;
 
+			case 'U':
+				run_unit_tests++;
+				break;
+
 			case 'V':
 				printf("tmtest version %s\n", stringify(VERSION));
 				exit(0);
@@ -1166,11 +1172,35 @@
 }
 
 
+#include "cutest.h"
+
+static int cumain(int argc, char **argv)
+{
+	extern cusuite* compare_suite();
+
+	CuString *output = CuStringNew();
+
+	CuSuite *suite = CuSuiteNew();
+	CuSuiteAddSuite(suite, compare_suite());
+
+	CuSuiteRun(suite);
+	CuSuiteSummary(suite, output);
+	CuSuiteDetails(suite, output);
+	printf("%s\n", output->buffer);
+
+	return 0;
+}
+
+
 int main(int argc, char **argv)
 {
 	orig_cwd = dup_cwd();
 	process_args(argc, argv);
 
+	if(run_unit_tests) {
+		return cumain(argc, argv);
+	}
+
     start_tests();
     if(optind < argc) {
 		process_argv(argv+optind);

Modified: trunk/re2c/read-fd.c
===================================================================
--- trunk/re2c/read-fd.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read-fd.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -3,14 +3,24 @@
  * 28 Dec 2004
  */
 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 #include <unistd.h>
 #include <errno.h>
 #include <assert.h>
 
 #include "read-fd.h"
+#include "scan-dyn.h"
 
 
-static int readfd_read(scanstate *ss)
+/**
+ * The internal function that performs the read.  You never call
+ * it directly.  Instead, it is called automatically by the scanner
+ * whenever it needs more data.
+ */
+
+static ssize_t readfd_read(scanstate *ss)
 {
     int n, avail;
 
@@ -53,3 +63,45 @@
     return ss;
 }
 
+
+/* Opens the file and creates a new scanner to scan it.
+ * This is just a convenience routine.  You can create a scanner
+ * yourself and attach to it using readfd_attach().
+ *
+ * If you do use this routine, you should call readfd_close() to close
+ * the file and deallocate the scanner.
+ *
+ * Bufsiz tells how big in bytes the scan buffer will be.  No single
+ * token may be larger than bufsiz.
+ */
+
+scanstate* readfd_open(const char *path, size_t bufsiz)
+{
+    scanstate *ss;
+    int fd;
+
+    fd = open(path, O_RDONLY);
+    if(fd < 0) {
+        return NULL;
+    }
+
+    ss = dynscan_create(bufsiz);
+    if(!ss) {
+        close(fd);
+        return NULL;
+    }
+
+    return readfd_attach(ss, fd);
+}
+
+
+/**
+ * Closes the file and deallocates the memory allocated by readfd_open().
+ */
+
+void readfd_close(scanstate *ss)
+{
+    close((int)ss->readref);
+    dynscan_free(ss);
+}
+

Modified: trunk/re2c/read-fd.h
===================================================================
--- trunk/re2c/read-fd.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read-fd.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -12,3 +12,8 @@
 
 scanstate* readfd_attach(scanstate *ss, int fd);
 
+
+// convenience functions:
+scanstate* readfd_open(const char *path, size_t bufsiz);
+void readfd_close(scanstate *ss);
+

Added: trunk/re2c/read-fp.c
===================================================================
--- trunk/re2c/read-fp.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read-fp.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,93 @@
+/* read-fp.c
+ * Scott Bronson
+ * 28 Dec 2004
+ */
+
+#include <stdio.h>
+
+#include "scan-dyn.h"
+#include "read-fp.h"
+
+
+static ssize_t readfp_read(scanstate *ss)
+{
+    ssize_t n, avail;
+
+    avail = read_shiftbuf(ss);
+    n = fread((void*)ss->limit, avail, 1, ss->readref);
+    ss->limit += n;
+
+    if(n <= 0) {
+        if(feof(ss->readref)) {
+            // too few bytes to complete the current token.
+            ss->at_eof = 1;
+            return 0;
+        }
+        if(ferror(ss->readref)) {
+            // error while reading stream.
+            // too bad stdlib doesn't allow us to
+            // determine what the error is.
+            ss->at_eof = 2;
+            return -1;
+        }
+       
+        assert(!"Not eof or error. I have no idea what happened!");
+        return -3;
+    }
+
+    return n;
+}
+
+
+scanstate* readfp_attach(scanstate *ss, FILE *fp)
+{
+    if(!ss || !fp) {
+        return 0;
+    }
+
+    ss->readref = fp;
+    ss->read = readfp_read;
+    return ss;
+}
+
+
+/** Creates a scanstate object that can read from the given file.
+ * Returns NULL and prints to STDERR if an error ocurrs.
+ * Ensure that you call readfp_close() when you're finished.
+ * Uses the given buffer size, or BUFSIZ if bufsiz is 0.
+ * Ensure that the buffer size will fit into a signed
+ * int on the current machine architecture.
+ */
+
+scanstate* readfp_open(const char *path, int bufsiz)
+{
+    scanstate *ss;
+    FILE *fp;
+
+    // open the file
+    fp = fopen(path, "r");
+    if(!fp) {
+        return NULL;
+    }
+
+    // create the dynamic scanstate
+    ss = dynscan_create(bufsiz);
+    if(!ss) {
+        fclose(fp);
+        return NULL;
+    }
+
+    return readfp_attach(ss, fp);
+}
+
+
+/** Releases the resources allocated by readfp_open()
+ */
+
+void readfp_close(scanstate *ss)
+{
+    fclose(ss->readref);
+    dynscan_free(ss);
+}
+
+

Added: trunk/re2c/read-fp.h
===================================================================
--- trunk/re2c/read-fp.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read-fp.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,17 @@
+/* read-fp.h
+ * Scott Bronson
+ * 28 Dec 2004
+ *
+ * This allows you to feed an re2c scanner directly from a
+ * std C fileptr.
+ */
+
+
+#include <stdio.h>
+#include "read.h"
+
+
+scanstate* readfp_attach(scanstate *ss, FILE *fp);
+scanstate* readfp_open(const char *filename, size_t bufsiz);
+void readfp_close(scanstate *ss);
+

Added: trunk/re2c/read-mem.c
===================================================================
--- trunk/re2c/read-mem.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read-mem.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,55 @@
+/* re2c.c
+ * Scott Bronson
+ * 28 Dec 2004
+ *
+ * Shows how to scan from an in-memory buffer.  We ignore the buffer
+ * and scan directly out of the string.  The read proc
+ * just returns eof when the scanner hits the end of the string.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include "read-mem.h"
+
+
+/** Returns EOF because we're out of data.
+ */
+
+static ssize_t readmem_read(scanstate *ss)
+{
+    return 0;
+}
+
+
+/** Initializes the given scanstate to read from the given string.
+ */
+
+scanstate* readmem_init(scanstate *ss, const char *data, size_t len)
+{
+    scanstate_init(ss, data, len);
+    ss->limit = ss->bufptr + ss->bufsiz;
+    ss->read = readmem_read;
+    return ss;
+}
+
+
+/** Attaches the scanner to the given string.  Use this
+ * if you've already malloc'd a scanstate.  It calls scanstate_init
+ * so it will blow everything already in the scanstate away.
+ *
+ * TODO: this is unlike all other attach routines, none of whom
+ * blow away the scanstate.  CHANGE THIS.
+ */
+
+scanstate* readmem_attach(scanstate *ss, const char *data, size_t len)
+{
+    // ensure we don't stomp on a pre-existing buffer
+    if(ss->bufsiz) {
+        return NULL;
+    }
+
+    return readmem_init(ss, data, len);
+}
+

Added: trunk/re2c/read-mem.h
===================================================================
--- trunk/re2c/read-mem.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read-mem.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,16 @@
+/* re2c-mem.c
+ * Scott Bronson
+ * 30 Dec 2004
+ *
+ * Allows you to feed an re2c scanner from a memory block.
+ */
+
+#include "read.h"
+
+scanstate* readmem_init(scanstate *ss, const char *data, size_t len);
+scanstate* readmem_attach(scanstate *ss, const char *data, size_t len);
+
+// convenience functions:
+#define readmem_init_str(ss,str) readmem_init(ss,str,strlen(str))
+#define readmem_init_strconst(ss,str) readmem_init(ss,str,sizeof(str)-1)
+

Added: trunk/re2c/read-rand.c
===================================================================
--- trunk/re2c/read-rand.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read-rand.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,51 @@
+/* read-rand.c
+ * Scott Bronson
+ * 6 Mar 2006
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "read-rand.h"
+
+
+/**
+ * The internal function that performs the read.  You never call
+ * it directly.  Instead, it is called automatically by the scanner
+ * whenever it needs more data.
+ *
+ * This reader will never hit EOF.  It just keeps supplying data
+ * from rand_r(3).
+ */
+
+static ssize_t readrand_read(scanstate *ss)
+{
+    int avail = read_shiftbuf(ss);
+	int orig = avail;
+	int num;
+
+	while(avail >= sizeof(int)) {
+		// There appears to be some sort of cast bug in GCC4...?
+		// Anyhow, the memcpy works, casting pointers didn't.
+		num = rand_r((unsigned int*)&ss->readref);
+		memcpy((char*)ss->limit, &num, sizeof(int));
+		ss->limit += sizeof(int);
+		avail -= sizeof(int);
+	}
+
+    return orig-avail;
+}
+
+
+/**
+ * Attaches the seed to the existing scanstate object.
+ * Cannot possibly fail.
+ */
+
+scanstate* readrand_attach(scanstate *ss, int seed)
+{
+    *(unsigned int*)&ss->readref = seed;
+    ss->read = readrand_read;
+    return ss;
+}
+

Added: trunk/re2c/read-rand.h
===================================================================
--- trunk/re2c/read-rand.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read-rand.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,13 @@
+/* read-rand.h
+ * Scott Bronson
+ * 6 Mar 2006
+ *
+ * This allows you to feed an re2c scanner with random numbers.
+ */
+
+
+#include "read.h"
+
+
+scanstate* readrand_attach(scanstate *ss, int seed);
+

Modified: trunk/re2c/read.c
===================================================================
--- trunk/re2c/read.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -38,10 +38,10 @@
 // The bytes that need to be shifted are those between the token
 // and the limit.
 
-int read_shiftbuf(scanstate *ss)
+ssize_t read_shiftbuf(scanstate *ss)
 {
     const char *min;
-    int cnt;
+    ssize_t cnt;
 
     min = ss->token;
     if(ss->marker && ss->marker < min) {
@@ -51,7 +51,7 @@
     // this tells how many bytes need to be shifted.
     cnt = ss->limit - min;
     if(cnt) {
-        int delta = min - ss->bufptr;
+        ssize_t delta = min - ss->bufptr;
         memmove((void*)ss->bufptr, min, cnt);
         ss->cursor -= delta;
         ss->token -= delta;

Modified: trunk/re2c/read.h
===================================================================
--- trunk/re2c/read.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/read.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -11,12 +11,9 @@
 #ifndef R2READ_H
 #define R2READ_H
 
-#include <assert.h>
-
 #include "scan.h"
 
+ssize_t read_shiftbuf(scanstate *ss);
 
-int read_shiftbuf(scanstate *ss);
-
 #endif
 

Added: trunk/re2c/scan-dyn.c
===================================================================
--- trunk/re2c/scan-dyn.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/scan-dyn.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,69 @@
+/* scan-dyn.c
+ * Scott Bronson
+ * 28 Dec 2004
+ *
+ * Routines to dynamically allocate and free scanners and their buffers.
+ * The scanner will be initialized, but you still need to attach
+ * it to a particular type of reader.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include "scan-dyn.h"
+
+/** Allocate a scanstate data structure and its associated buffer.
+ * Ensure the buffer is large enough to hold the longest token.
+ * Pass 0 for bufsiz if you don't want to allocate a buffer
+ * (i.e. you're scanning from a contiguous memory block).
+ * Ensure you call dynamicscan_free() when you're done with the scanner.
+ */
+
+/** Dynamically allocates a new scanstate data structure
+ *
+ * Allocates a buffer of the given size for the scanner using malloc.
+ * Note that the size is an int: the number of bytes in the buffer
+ * must fit into a signed integer on the current architecture.
+ * Returns the new scanstate or NULL if there was a memory allocation problem.
+ *
+ * Remember to call dynamicscan_free() when you're done scanning.
+ */
+
+scanstate* dynscan_create(size_t bufsiz)
+{
+    scanstate *ss;
+    char *bufptr;
+    
+    ss = malloc(sizeof(scanstate));
+    if(!ss) {
+        return NULL;
+    }
+
+    if(bufsiz) {
+        bufptr = malloc(bufsiz);
+        if(!bufptr) {
+            free(ss);
+            return NULL;
+        }
+    } else {
+        bufptr = 0;
+    }
+
+    scanstate_init(ss, bufptr, bufsiz);
+    return ss;
+}
+
+
+/** Frees a scanstate allocated by dynamicscan_create().
+ */
+
+void dynscan_free(scanstate *ss)
+{
+    if(ss->bufptr) {
+        free((void*)ss->bufptr);
+    }
+
+    free(ss);
+}
+

Added: trunk/re2c/scan-dyn.h
===================================================================
--- trunk/re2c/scan-dyn.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/scan-dyn.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -0,0 +1,15 @@
+/* scan-dyn.h
+ * Scott Bronson
+ * 30 Dec 2004
+ *
+ * Creates a scanner entirely located on the heap.  You must make
+ * sure to eventually call dynscan_free for every scanner created
+ * with dynscan_create.
+ */
+
+#include "scan.h"
+
+
+scanstate* dynscan_create(size_t bufsiz);
+void dynscan_free(scanstate *ss);
+

Modified: trunk/re2c/scan.c
===================================================================
--- trunk/re2c/scan.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/scan.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -12,7 +12,7 @@
  * Note that you must attach it to a reader after calling this routine.
  */
 
-void scanstate_init(scanstate *ss, const char *bufptr, int bufsiz)
+void scanstate_init(scanstate *ss, const char *bufptr, size_t bufsiz)
 {
     ss->cursor = bufptr;
     ss->limit = bufptr;
@@ -36,12 +36,13 @@
  * Doesn't modify:
  * - the reader or the readref.
  * - the scanner or the scanref.
+ * - the userproc or userref.
  * - the buffer or buffer size
  *
  * But sets everything else to the default values.
- * You may still need to reattach to the reader if it needs to
- * reset some part of its internal state.  This is true of the
- * scanner too.
+ *
+ * If you want to reset the reader and scanner, you probalby want
+ * to detach and reattach them.  The userproc is entirely up to you.
  */
 
 void scanstate_reset(scanstate *ss)

Modified: trunk/re2c/scan.h
===================================================================
--- trunk/re2c/scan.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/re2c/scan.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -4,6 +4,9 @@
  *
  * This part of support code to make writing re2c scanners much easier.
  *
+ * TODO: add dispose procs.  Normally these will just be null but
+ * if they're set, they will ensure that all resources are collected.
+ *
  * TODO: probably want to split the re2c-specific code from the general
  * code.  This file is overall very useful, but it's got a few limitations
  * imposed by re2c that should probably be placed in its own layer.
@@ -11,6 +14,10 @@
  * limitations.
  */
 
+// to pull in the definition for size_t
+#include <sys/types.h>
+
+
 /** @file scan.h
  *
  * This is the central file for the readers.  They provide data
@@ -82,7 +89,7 @@
  */
 
 #define YYFILL(n)   do { \
-		int r = (*ss->read)(ss); \
+		ssize_t r = (*ss->read)(ss); \
 		if(r < 0) return r; \
 		if((ss)->cursor >= (ss)->limit) return 0; \
 	} while(0);
@@ -135,7 +142,7 @@
  * up as much as it possibly can.
  */
 
-typedef int (*readproc)(struct scanstate *ss);
+typedef ssize_t (*readproc)(struct scanstate *ss);
 
 
 /** Prototype of scanner function
@@ -179,7 +186,7 @@
     int at_eof;         ///< You almost certainly don't want to be using this unless you're writing a readproc.  Use scan_finished() instead.  This field gets set when the readproc realizes it has hit eof.  by convention 1 means eof, 2 means yes, at_eof is true, but because of an unrecoverable read error (todo: this should be formalized?  TODO: audit code to see if this is indeed the case).
 
     const char *bufptr; ///< The buffer currently in use
-    int bufsiz;         ///< The maximum number of bytes that the buffer can hold
+    size_t bufsiz;         ///< The maximum number of bytes that the buffer can hold
 
     void *readref;      ///< Data specific to the reader (i.e. for readfp_attach() it's a FILE*).
     readproc read;      ///< The routine the scanner calls when the buffer needs to be reread.
@@ -193,7 +200,7 @@
 typedef struct scanstate scanstate;
 
 
-void scanstate_init(scanstate *ss, const char *bufptr, int bufsiz);
+void scanstate_init(scanstate *ss, const char *bufptr, size_t bufsiz);
 void scanstate_reset(scanstate *ss);
 
 
@@ -206,9 +213,17 @@
  * If there's no data in the buffer but we're not at eof, then we need
  * to execute a read to see if there's more data available.  If so, we're
  * not finished.  Otherwise, we're all done.
+ *
+ * Potential problem: this routine might call read, and if read returns
+ * an error token, you'll miss it.  So, only call this routine when
+ * you're sure you're at EOF anyway.  To find out if you're at EOF
+ * without missing the errors, just call scan_token() and see if it
+ * returns 0.
+ *
+ * TODO: should this routine be removed entirely?
  */
 
-#define scan_finished(ss) \
+#define scan_is_finished(ss) \
     (((ss)->cursor < (ss)->limit) ? 0 : \
 		 ((ss)->at_eof || ((*(ss)->read)(ss) <= 0)) \
     )
@@ -217,7 +232,6 @@
 /** Fetches the next token in the stream from the scanner.
  */
 
-#define scan_token(ss) ((*((ss)->state))(ss))
 #define scan_next_token(ss) ((*((ss)->state))(ss))
 
 
@@ -288,7 +302,10 @@
 #define scan_pushback(ss) ((ss)->cursor = (ss)->token)
 
 
-/** Sets the current line number in the scanner to the given value.
+/**
+ * Sets the current line number in the scanner to the given value.
+ * I think most people will just manipulate ss->line directly.
+ * TODO: get rid of this macro?
  */
 
 #define scan_set_line(ss,n) (ss->line=(n));
@@ -301,8 +318,9 @@
 
 
 /**
- * Prepares the scanner to scan a new token.
- * This should be called at the beginning of every scanproc.
+ * Scanners only!  Prepares the scanner to scan a new token.
+ * This should be called at the beginning of every scanproc
+ * and nowhere else.
  */
 
 #define scanner_enter(ss) ((ss)->token = (ss)->cursor)

Modified: trunk/test/03-results/02-Nstdout.test
===================================================================
--- trunk/test/03-results/02-Nstdout.test	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/test/03-results/02-Nstdout.test	2006-03-06 21:56:19 UTC (rev 107)
@@ -6,11 +6,11 @@
 
 tmtest -q - <<-EOL
 	echo Howdy
-	STDOUT :
+	STDOUT:
 	howdy
 EOL
-STDOUT : 
+STDOUT: 
 FAIL (STDIN)                   O..  stdout differed
 
 1 test run, 0 successes, 1 failure.
-RESULT : 0
+RESULT: 0

Modified: trunk/test/03-results/03-Nstdout.test
===================================================================
--- trunk/test/03-results/03-Nstdout.test	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/test/03-results/03-Nstdout.test	2006-03-06 21:56:19 UTC (rev 107)
@@ -7,11 +7,11 @@
 tmtest -q - <<-EOL
 	echo Howdy
 
-	STDOUT :
+	STDOUT:
 	Howdy 
 EOL
-STDOUT : 
+STDOUT: 
 FAIL (STDIN)                   O..  stdout differed
 
 1 test run, 0 successes, 1 failure.
-RESULT : 0
+RESULT: 0

Modified: trunk/test/03-results/04-Nstderr.test
===================================================================
--- trunk/test/03-results/04-Nstderr.test	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/test/03-results/04-Nstderr.test	2006-03-06 21:56:19 UTC (rev 107)
@@ -10,6 +10,8 @@
 	Howdy
 
 EOL
+
+
 STDOUT:
 FAIL (STDIN)                   .E.  stderr differed
 

Modified: trunk/test/03-results/04-Nstdout.test
===================================================================
--- trunk/test/03-results/04-Nstdout.test	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/test/03-results/04-Nstdout.test	2006-03-06 21:56:19 UTC (rev 107)
@@ -7,12 +7,12 @@
 tmtest -q - <<-EOL
 	echo Howdy
 
-	STDOUT :
+	STDOUT:
 	Howdy
 
 EOL
-STDOUT : 
+STDOUT: 
 FAIL (STDIN)                   O..  stdout differed
 
 1 test run, 0 successes, 1 failure.
-RESULT : 0
+RESULT: 0

Modified: trunk/test/03-results/10-NoNLFFail.test
===================================================================
--- trunk/test/03-results/10-NoNLFFail.test	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/test/03-results/10-NoNLFFail.test	2006-03-06 21:56:19 UTC (rev 107)
@@ -9,6 +9,9 @@
 
 EOL
 STDOUT : 
-ok   (STDIN) 
+FAIL (STDIN)                   O..  stdout differed
 
-1 test run, 1 success, 0 failures.
+1 test run, 0 successes, 1 failure.
+STDERR:
+WARNING: STDOUT is marked -n but it ends with multiple newlines!
+    Please remove all but one newline from (STDIN) around line 4.

Modified: trunk/test/03-results/13-MultiNL.test
===================================================================
--- trunk/test/03-results/13-MultiNL.test	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/test/03-results/13-MultiNL.test	2006-03-06 21:56:19 UTC (rev 107)
@@ -9,6 +9,9 @@
 
 EOL
 STDOUT: 
-ok   (STDIN) 
+FAIL (STDIN)                   O..  stdout differed
 
-1 test run, 1 success, 0 failures.
+1 test run, 0 successes, 1 failure.
+STDERR:
+WARNING: STDOUT is marked -n but it ends with multiple newlines!
+    Please remove all but one newline from (STDIN) around line 4.

Modified: trunk/test/03-results/13-MultiNLErr.test
===================================================================
--- trunk/test/03-results/13-MultiNLErr.test	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/test/03-results/13-MultiNLErr.test	2006-03-06 21:56:19 UTC (rev 107)
@@ -9,6 +9,9 @@
 
 EOL
 STDOUT: 
-ok   (STDIN) 
+FAIL (STDIN)                   .E.  stderr differed
 
-1 test run, 1 success, 0 failures.
+1 test run, 0 successes, 1 failure.
+STDERR:
+WARNING: STDERR is marked -n but it ends with multiple newlines!
+    Please remove all but one newline from (STDIN) around line 4.

Modified: trunk/test.c
===================================================================
--- trunk/test.c	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/test.c	2006-03-06 21:56:19 UTC (rev 107)
@@ -16,6 +16,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <dirent.h>
+#include <assert.h>
 
 #include "re2c/read-fd.h"
 
@@ -158,7 +159,7 @@
     // it means that we attempted to start the test.  If not,
     // then the test bailed early.
     do {
-        tok = scan_token(&ss);
+        tok = scan_next_token(&ss);
 
 		// look for errors...
         if(tok < 0) {
@@ -234,7 +235,7 @@
 				fprintf(stderr, "Unknown token (%d) on line %d of the status file: '%.*s'\n",
 						tok, ss.line, token_length(&ss)-1, token_start(&ss));
 		}
-    } while(!scan_finished(&ss));
+    } while(!scan_is_finished(&ss));
 
 	if(lastfile_good) {
 		test->last_file_processed = strdup(lastfile);
@@ -289,7 +290,7 @@
 
     do {
         oldline = test->testfile.line;
-        int tokno = scan_token(&test->testfile);
+        int tokno = scan_next_token(&test->testfile);
         if(tokno < 0) {
             fprintf(stderr, "Error %d pulling status tokens: %s\n", 
                     tokno, strerror(errno));
@@ -323,7 +324,7 @@
             // print the unmodified data to the command script.
             fwrite(token_start(&test->testfile), token_length(&test->testfile), 1, fp);
         }
-    } while(!scan_finished(&test->testfile));
+    } while(!scan_is_finished(&test->testfile));
 
     rewrite_command_section(test, 0, NULL, 0);
 }
@@ -335,11 +336,9 @@
  * it up.
  */
 
-void compare_section_start(scanstate *cmpscan, int fd, matchval *mv,
-		const char *filename, const char *sectionname, int nonl)
+void compare_section_start(scanstate *cmpscan, int fd,
+		const char *filename, const char *sectionname)
 {
-    assert(!compare_in_progress(cmpscan));
-
     // rewind the file
     if(lseek(fd, 0, SEEK_SET) < 0) {
         fprintf(stderr, "read_file lseek for status file: %s\n", strerror(errno));
@@ -348,7 +347,7 @@
 
     scanstate_reset(cmpscan);
     readfd_attach(cmpscan, fd);
-	compare_attach(cmpscan, mv, nonl);
+	compare_attach(cmpscan);
 
     // we may want to check the token to see if there are any
     // special requests (like detabbing).
@@ -502,6 +501,13 @@
 }
 
 
+// store the state we need directly in the cmpscan structure.
+#define cmpscan_state             (*(int*)&(cmpscan)->userref)
+#define cmpscan_suppress_newline  (*(int*)&(cmpscan)->userproc)
+	///< 0 for normal processing, 1 if a newline should be suppressed
+	///  from the expected output (so it can match actual).
+
+
 /**
  * Called when we're at the start of a STDOUT or STDERR section.
  * Sets the cmpscanner up to compare the section.
@@ -509,7 +515,7 @@
  */
 
 int start_output_section(struct test *test, const char *tok,
-        int toklen, scanstate *cmpscan, int fd, matchval *val,
+        int toklen, scanstate *cmpscan, int fd, enum matchval val,
         const char *secname)
 {
     int suppress_trailing_newline = 0;
@@ -519,7 +525,7 @@
             start_output_section_argproc, 
             (void*)&suppress_trailing_newline);
 
-    if(*val != match_unknown) {
+    if(val != match_unknown) {
         // we've already obtained a value for this section!
         fprintf(stderr, "%s line %d Error: duplicate %s "
                 "section.  Ignored.\n", get_testfile_name(test),
@@ -527,9 +533,13 @@
         return 0;
     }
 
-    compare_section_start(cmpscan, fd, val,
-        get_testfile_name(test), secname, suppress_trailing_newline);
+	scanstate_reset(cmpscan);
+    compare_section_start(cmpscan, fd,
+        get_testfile_name(test), secname);
 
+	// store the newline flag in the cmpscan structure
+	cmpscan_suppress_newline = suppress_trailing_newline;
+
     return 1;
 }
 
@@ -551,17 +561,60 @@
 /**
  * Finishes comparing a section.
  * see start_output_section().
+ *
+ * When should we warn?
+ * - If the actual stdout didn't end with a \n but the exptected stdout
+ *   said it would.  Actual is ss, expected is ptr.  So that means
+ *   compare_ptr_has_extra_nl is true AND suppress_trailing_newline
+ *   is false.
+ *
+ * Holy cats.  The -n option has made this routine really complex!
  */
 
-void end_output_section(struct test *test, scanstate *cmpscan,
+enum matchval end_output_section(struct test *test, scanstate *cmpscan,
         const char *name)
 {
-    int warn_nl = 0;
+	compare_result cmp = compare_check_newlines(cmpscan,0,0);
+	int suppress_trailing_newline = cmpscan_suppress_newline;
 
-    compare_end(cmpscan, &warn_nl);
-    if(warn_nl) {
-		warn_section_newline(test, name);
-    }
+	if(cmp == cmp_ptr_has_extra_nl) {
+		// actual is missing a single newline as compared to expected.
+
+		if(!suppress_trailing_newline) {
+			// user hasn't marked section needing suppression so warn.
+			warn_section_newline(test, name);
+			return match_no;
+		}
+
+		// it's met all the requirements.  We have a match.
+		return match_yes;
+	}
+
+	if(cmp == cmp_ptr_has_more_nls && suppress_trailing_newline) {
+		fprintf(stderr,
+			"WARNING: %s is marked -n but it ends with multiple newlines!\n"
+			"    Please remove all but one newline from %s around line %d.\n",
+			name, get_testfile_name(test), test->testfile.line);
+		return match_no;
+	}
+
+	if(cmp == cmp_full_match) {
+		if(suppress_trailing_newline) {
+			if(cmpscan->line == 0) {
+				// don't want to print the warning if it's an empty section
+				// because, while it's weird, it's technically correct.
+				return match_yes;
+			}
+
+			// section was marked -n but a newline was present.  No match.
+			return match_no;
+		}
+
+		// full match in a normal section (not marked -n)
+		return match_yes;
+	}
+
+	return match_no;
 }
 
 
@@ -572,15 +625,11 @@
  * The refcon needs to be an allocated scanner.  It need not be
  * attached to anything -- this routine will take care of attaching
  * and detaching it as needed.
- *
  */
 
 void parse_section_compare(struct test *test, int sec,
         const char *datap, int len, void *refcon)
 {
-    #define get_cur_state(ss)    ((int)(ss)->userref)
-    #define set_cur_state(ss,x)  ((ss)->userref=(void*)(x))
-
     // cmpscan is the scanner used to perform the diff.
     scanstate *cmpscan = refcon;
 
@@ -589,41 +638,41 @@
 
     // make sure we're not fed an illegal token.
     assert(is_section_token(newsec) || sec == 0);
+
     // make sure we're not starting from an illegal state.
-    assert(is_section_token(get_cur_state(cmpscan)) ||
-            get_cur_state(cmpscan) == 0);
+    assert(is_section_token(cmpscan_state) || cmpscan_state == 0);
 
     if(EX_ISNEW(sec) || sec == 0) {
         // ensure previoius section is finished
-        switch(get_cur_state(cmpscan)) {
+        switch(cmpscan_state) {
             case exSTDOUT:
-                end_output_section(test, cmpscan, "STDOUT");
-                break;
+			  test->stdout_match = end_output_section(test, cmpscan, "STDOUT");
+              break;
             case exSTDERR:
-                end_output_section(test, cmpscan, "STDERR");
-                break;
+			  test->stderr_match = end_output_section(test, cmpscan, "STDERR");
+              break;
             default:
                 ;
         }
 
         // then fire up the new section
-        set_cur_state(cmpscan, newsec);
+        cmpscan_state = newsec;
         switch(newsec) {
             case 0:
                 // don't start a new section if eof.
                 break;
             case exSTDOUT:
                 if(!start_output_section(test, datap, len, cmpscan,
-                        test->outfd, &test->stdout_match, "STDOUT"))
-                {
-                    set_cur_state(cmpscan, 0);
+                        test->outfd, test->stdout_match, "STDOUT")) {
+					// ignore the rest of this section
+                    cmpscan_state = 0;
                 }
                 break;
             case exSTDERR:
                 if(!start_output_section(test, datap, len, cmpscan,
-                        test->errfd, &test->stderr_match, "STDERR"))
-                {
-                    set_cur_state(cmpscan, 0);
+                        test->errfd, test->stderr_match, "STDERR")) {
+					// ignore the rest of this section
+                    cmpscan_state = 0;
                 }
                 break;
             case exRESULT:
@@ -632,15 +681,15 @@
         }
     } else {
         // we're continuing an already started section.
-        assert(get_cur_state(cmpscan) == newsec || get_cur_state(cmpscan) == 0);
+        assert(cmpscan_state == newsec || cmpscan_state == 0);
 
-        switch(get_cur_state(cmpscan)) {
+        switch(cmpscan_state) {
             case 0:
                 // do nothing
                 break;
             case exSTDOUT:
             case exSTDERR:
-                compare_continue(cmpscan, datap, len);
+				compare_continue(cmpscan, datap, len);
                 break;
             case exRESULT:
 				if(contains_nws(datap, len)) {
@@ -674,12 +723,12 @@
     // if the testfile is already at its eof, it means that
     // it didn't have any sections.  therefore, we'll assume
     // defaults for all values.  we're done.
-    if(scan_finished(scanner)) {
+    if(scan_is_finished(scanner)) {
         return;
     }
     
     do {
-        int tokno = scan_token(scanner);
+        int tokno = scan_next_token(scanner);
         if(tokno < 0) {
             fprintf(stderr, "Error %d pulling status tokens: %s\n", 
                     tokno, strerror(errno));
@@ -691,7 +740,7 @@
         (*parseproc)(test, tokno, token_start(scanner),
                 token_length(scanner), refcon);
 
-    } while(!scan_finished(scanner));
+    } while(!scan_is_finished(scanner));
 
     // give the parser an eof token so it can finalize things.
     (*parseproc)(test, 0, NULL, 0, refcon);

Modified: trunk/test.h
===================================================================
--- trunk/test.h	2006-03-05 22:52:02 UTC (rev 106)
+++ trunk/test.h	2006-03-06 21:56:19 UTC (rev 107)
@@ -9,6 +9,21 @@
 #include "compare.h"
 
 
+/**
+ * a tristate that tells whether something
+ *    - matches
+ *    - doesn't match
+ *    - hasn't been checked yet.
+ */
+
+enum matchval {
+    match_inprogress = -2,
+    match_unknown = -1,
+    match_no = 0,
+    match_yes = 1,
+};
+
+
 typedef enum {
 	test_pending=0,			///< still processing config files
 	config_was_aborted,		///< some config file called ABORT
@@ -61,9 +76,9 @@
 
 	int expected_exitno;	///< the test's expected exit value.  this is only valid when stderr_match != match_unknown.
 
-    matchval exitno_match;	///< tells whether the expected and actual exit values match.
-    matchval stdout_match;	///< tells whether the expected and actual stdout matches.
-    matchval stderr_match;	///< tells whether the expected and actual stderr matches.
+    enum matchval exitno_match;	///< tells whether the expected and actual exit values match.
+    enum matchval stdout_match;	///< tells whether the expected and actual stdout matches.
+    enum matchval stderr_match;	///< tells whether the expected and actual stderr matches.
 };
 
 





From tmtest-commits at berlios.de  Tue Mar  7 02:27:15 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 7 Mar 2006 02:27:15 +0100
Subject: [Tmtest-commits] [108] trunk: Simplify the compare API by getting rid of a misfeature.
Message-ID: <200603070127.k271RFgL000764@sheep.berlios.de>

Revision: 108
Author:   bronson
Date:     2006-03-07 02:26:53 +0100 (Tue, 07 Mar 2006)

Log Message:
-----------
Simplify the compare API by getting rid of a misfeature.

Modified Paths:
--------------
    trunk/TODO
    trunk/compare.c
    trunk/compare.h
    trunk/test.c
Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-06 21:56:19 UTC (rev 107)
+++ trunk/TODO	2006-03-07 01:26:53 UTC (rev 108)
@@ -1,5 +1,5 @@
 0.96:
-- Get rid of all scan_is_finished() calls?
+- Rewrite the goddamn unit testing.
 - Make tmtest only execute config files owned by either the user or root.
   Print a big fat warning when the config file is skipped.  This prevents
   a malicious user from putting a config file in /tmp and having it
@@ -43,6 +43,7 @@
   http://pvanhoof.be/blog/index.php/2006/03/03/tinymail-unit-testing-and-creating-messages     Actually, this looks better: http://cutest.sourceforge.net/
   Potential units: curdir, path normalization
 - Get rid of -g, add -O2.  Make it easy to set these for compilation.
+- Get rid of all scan_is_finished() calls?  Deprecate scan_is_finished.
 
 0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.

Modified: trunk/compare.c
===================================================================
--- trunk/compare.c	2006-03-06 21:56:19 UTC (rev 107)
+++ trunk/compare.c	2006-03-07 01:26:53 UTC (rev 108)
@@ -134,30 +134,21 @@
 
 
 /**
- * Returns true if the streams are both out of data and have matched
- * byte-for-byte up to this point, otherwise returns false.
+ * Returns an appropriate code for how well matched the two streams
+ * are.  Assumes that you're at EOF on the ptr stream.
  */
 
-compare_result compare_check(scanstate *ss, const char *ptr, size_t len)
+compare_result compare_check(scanstate *ss)
 {
-	int ptr_empty = (ptr == NULL || len == 0);
-	int ss_empty = scan_is_finished(ss);
-
-
 	if(STATE != cmp_in_progress) {
 		return STATE;
 	}
 
-	if(ptr_empty && ss_empty) {
-		// both streams are out of data
+	if(scan_is_finished(ss)) {
 		return cmp_full_match;
-	}
-
-	if(ptr_empty && !ss_empty) {
+	} else {
 		return cmp_ss_has_more_data;
 	}
-
-	return cmp_no_match;
 }
 
 
@@ -181,33 +172,19 @@
  * @returns the appropriate value from compare_result.
  */
 
-compare_result compare_check_newlines(scanstate *ss, const char *ptr, size_t len)
+compare_result compare_check_newlines(scanstate *ss)
 {
-	int ptr_empty = (ptr == NULL || len == 0);
-	int ss_empty = scan_is_finished(ss);
-
 	if(STATE != cmp_in_progress) {
 		return STATE;
 	}
 
-	if(ptr_empty && ss_empty) {
-		// both streams are out of data
+	if(scan_is_finished(ss)) {
 		return cmp_full_match;
-	}
-
-	if(!ptr_empty && ss_empty && has_extra_nl(ptr, len)) {
-		return cmp_ptr_has_extra_nl;
-	}
-
-	if(!ss_empty&&ptr_empty&&has_extra_nl(ss->cursor,ss->limit-ss->cursor)) {
+	} else if(has_extra_nl(ss->cursor,ss->limit-ss->cursor)) {
 		return cmp_ss_has_extra_nl;
-	}
-
-	if(ptr_empty && !ss_empty) {
+	} else {
 		return cmp_ss_has_more_data;
 	}
-
-	return cmp_no_match;
 }
 
 
@@ -222,12 +199,12 @@
 
 	readmem_init_str(ss, "");
 	compare_attach(ss);
-	AssertEq(compare_check(ss,0,0), cmp_full_match);
+	AssertEq(compare_check(ss), cmp_full_match);
 
 	readmem_init_str(ss, "");
 	compare_attach(ss);
 	compare_continue(ss, "", 0);
-	AssertEq(compare_check(ss,0,0), cmp_full_match);
+	AssertEq(compare_check(ss), cmp_full_match);
 }
 
 
@@ -239,7 +216,7 @@
 	compare_attach(ss);
 	compare_continue(ss, "12", 2);
 	compare_continue(ss, "3", 1);
-	AssertEq(compare_check(ss,0,0), cmp_full_match);
+	AssertEq(compare_check(ss), cmp_full_match);
 }
 
 
@@ -260,7 +237,7 @@
 
 	// compare_check will never return cmp_full_match because
 	// the random reader will never run out of data.
-	AssertEq(compare_check(ss,0,0), cmp_ss_has_more_data);
+	AssertEq(compare_check(ss), cmp_ss_has_more_data);
 }
 
 
@@ -276,7 +253,7 @@
 {
 	scanstate ssrec, *ss=&ssrec;
 	test_strings(ss, s1, s2);
-	return compare_check_newlines(ss, NULL, 0);
+	return compare_check_newlines(ss);
 }
 
 
@@ -288,7 +265,7 @@
 	AssertEq(check_newlines("Unix",     "Unix"    ), cmp_full_match);
 
 	AssertEq(check_newlines("Unix\n\n", "Unix\n"  ), cmp_ss_has_extra_nl);
-	AssertEq(check_newlines("Unix\n",   "Unix\n\n"), cmp_ptr_has_extra_nl);
+	AssertEq(check_newlines("Unix\n",   "Unix\n\n"), cmp_ptr_has_more_nls);
 
 	// empty buffers (except for newlines)
 	AssertEq(check_newlines("\n",   ""     ), cmp_ss_has_extra_nl);
@@ -308,18 +285,14 @@
 	compare_continue(ss, "1", 1);
 	compare_continue(ss, "2", 1);
 	compare_continue(ss, "\n", 1);
-	AssertEq(compare_check(ss,0,0), cmp_ptr_has_extra_nl);
+	AssertEq(compare_check(ss), cmp_ptr_has_extra_nl);
 
 	readmem_init_str(ss, "123");
 	compare_attach(ss);
 	compare_continue(ss, "1", 1);
 	compare_continue(ss, "2", 1);
 	compare_continue(ss, "\n", 1);
-	AssertEq(compare_check(ss,0,0), cmp_no_match);
-
-	readmem_init_str(ss, "");
-	compare_attach(ss);
-	AssertEq(compare_check(ss,"\n",1), cmp_no_match);
+	AssertEq(compare_check(ss), cmp_no_match);
 }
 
 
@@ -335,27 +308,23 @@
 	compare_continue(ss, "2", 1);
 	compare_continue(ss, "3", 1);
 	compare_continue(ss, "\n", 1);
-	AssertEq(compare_check_newlines(ss,0,0), cmp_ptr_has_extra_nl);
+	AssertEq(compare_check_newlines(ss), cmp_ptr_has_extra_nl);
 
 	readmem_init_str(ss, "123\n");
 	compare_attach(ss);
 	compare_continue(ss, "1", 1);
 	compare_continue(ss, "2", 1);
 	compare_continue(ss, "3", 1);
-	AssertEq(compare_check_newlines(ss,0,0), cmp_ss_has_extra_nl);
+	AssertEq(compare_check_newlines(ss), cmp_ss_has_extra_nl);
 
 	readmem_init_str(ss, "");
 	compare_attach(ss);
-	AssertEq(compare_check_newlines(ss,"\n",1), cmp_ptr_has_extra_nl);
-
-	readmem_init_str(ss, "");
-	compare_attach(ss);
 	compare_continue(ss, "\n", 1);
-	AssertEq(compare_check_newlines(ss,0,0), cmp_ptr_has_extra_nl);
+	AssertEq(compare_check_newlines(ss), cmp_ptr_has_extra_nl);
 
 	readmem_init_str(ss, "\n");
 	compare_attach(ss);
-	AssertEq(compare_check_newlines(ss,0,0), cmp_ss_has_extra_nl);
+	AssertEq(compare_check_newlines(ss), cmp_ss_has_extra_nl);
 }
 
 

Modified: trunk/compare.h
===================================================================
--- trunk/compare.h	2006-03-06 21:56:19 UTC (rev 107)
+++ trunk/compare.h	2006-03-07 01:26:53 UTC (rev 108)
@@ -26,5 +26,5 @@
 
 void compare_attach(scanstate *ss);
 int compare_continue(scanstate *ss, const char *ptr, size_t len);
-compare_result compare_check(scanstate *ss, const char *ptr, size_t len);
-compare_result compare_check_newlines(scanstate *ss, const char *ptr, size_t len);
+compare_result compare_check(scanstate *ss);
+compare_result compare_check_newlines(scanstate *ss);

Modified: trunk/test.c
===================================================================
--- trunk/test.c	2006-03-06 21:56:19 UTC (rev 107)
+++ trunk/test.c	2006-03-07 01:26:53 UTC (rev 108)
@@ -574,7 +574,7 @@
 enum matchval end_output_section(struct test *test, scanstate *cmpscan,
         const char *name)
 {
-	compare_result cmp = compare_check_newlines(cmpscan,0,0);
+	compare_result cmp = compare_check_newlines(cmpscan);
 	int suppress_trailing_newline = cmpscan_suppress_newline;
 
 	if(cmp == cmp_ptr_has_extra_nl) {





From tmtest-commits at berlios.de  Tue Mar  7 22:36:45 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 7 Mar 2006 22:36:45 +0100
Subject: [Tmtest-commits] [109] trunk: Used to report user+sys time.
Message-ID: <200603072136.k27LajB3006284@sheep.berlios.de>

Revision: 109
Author:   bronson
Date:     2006-03-07 22:36:44 +0100 (Tue, 07 Mar 2006)

Log Message:
-----------
Used to report user+sys time.  When tests are I/O bound, this number
gets ridiculous.  Now we show wallclock time with user and sys as
percentages.

Modified Paths:
--------------
    trunk/TODO
    trunk/main.c
    trunk/rusage.c
    trunk/rusage.h
    trunk/test.c
    trunk/test.h
Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-07 01:26:53 UTC (rev 108)
+++ trunk/TODO	2006-03-07 21:36:44 UTC (rev 109)
@@ -43,7 +43,11 @@
   http://pvanhoof.be/blog/index.php/2006/03/03/tinymail-unit-testing-and-creating-messages     Actually, this looks better: http://cutest.sourceforge.net/
   Potential units: curdir, path normalization
 - Get rid of -g, add -O2.  Make it easy to set these for compilation.
-- Get rid of all scan_is_finished() calls?  Deprecate scan_is_finished.
+  Yes, have dev and prod modes.  dev would be -O0 and -g and include
+  unit tests.  Prod is -O2, stripped, and no unit tests (unless the
+  unit tests only add 12K or so, where might as well just leave em).
+- If there were failures, should highlight that in the test summary.
+	"%d FAILURES" or somesuch.
 
 0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.
@@ -59,6 +63,7 @@
   buffer.  If your stderr is more than 100K or so in size, just redirect
   it to a file, then cat the file at the end.  We truncate stderr if it
   gets too big.
+  - When done, verify that netknife's tests that freeze with -d now pass.
 - Is there any way to record memory and swap usage for each test?
   sure, it's in the rusage. prolly add a "tmtest -v" to print it for each test.
 - stdin is all buggered up.  why is it that "cat" with no args will print

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-03-07 01:26:53 UTC (rev 108)
+++ trunk/main.c	2006-03-07 21:36:44 UTC (rev 109)
@@ -16,6 +16,8 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
+#include <sys/time.h>
+#include <time.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <dirent.h>
@@ -73,7 +75,10 @@
 int g_statusfd;
 
 
+struct timeval test_start_time;
+struct timeval test_stop_time;
 
+
 // exit values:
 enum {
     no_error = 0,
@@ -885,6 +890,8 @@
 
 static void stop_tests()
 {
+	gettimeofday(&test_stop_time, NULL);
+
 	checkerr(close(g_outfd), "closing", g_outname);
 	checkerr(close(g_errfd), "closing", g_errname);
 	checkerr(close(g_statusfd), "closing", g_statusname);
@@ -944,6 +951,8 @@
 		fprintf(stderr, "Could not chdir 2 to %s: %s\n", cp, strerror(errno));
 		exit(initialization_error);
 	}
+
+	gettimeofday(&test_start_time, NULL);
 }
 
 
@@ -1213,7 +1222,7 @@
     stop_tests();
 
     if(outmode == outmode_test) {
-        print_test_summary();
+        print_test_summary(&test_start_time, &test_stop_time);
     }
 
 	free((char*)orig_cwd);

Modified: trunk/rusage.c
===================================================================
--- trunk/rusage.c	2006-03-07 01:26:53 UTC (rev 108)
+++ trunk/rusage.c	2006-03-07 21:36:44 UTC (rev 109)
@@ -18,7 +18,7 @@
 #include "rusage.h"
 
 
-void print_rusage()
+void print_rusage(struct timeval *start_tv, struct timeval *stop_tv)
 {
 	// struct rusage self;
 	struct rusage child;
@@ -36,11 +36,15 @@
 		return;
 	}
 
+	double start = start_tv->tv_sec + start_tv->tv_usec / 1000000.0;
+	double stop = stop_tv->tv_sec + stop_tv->tv_usec / 1000000.0;
+
 //	double uself = self.ru_utime.tv_sec + self.ru_utime.tv_usec / 1000000.0;
 	double uchild = child.ru_utime.tv_sec + child.ru_utime.tv_usec / 1000000.0;
 //	double sself = self.ru_stime.tv_sec + self.ru_stime.tv_usec / 1000000.0;
 	double schild = child.ru_stime.tv_sec + child.ru_stime.tv_usec / 1000000.0;
-	double total = uchild + schild;
+//	double total = uchild + schild;
+	double total = stop - start;
 
 	
 	/*
@@ -50,8 +54,9 @@
 			(int)(100.0*schild/total+0.5));
 			*/
 
-	printf("Tests took %.2fs (%02d%% sys)",
-			uchild+schild,
+	printf("%.2fs (%02d%% user, %02d%% sys)",
+			total,
+			(int)(100.0*uchild/total+0.5),
 			(int)(100.0*schild/total+0.5));
 }
 

Modified: trunk/rusage.h
===================================================================
--- trunk/rusage.h	2006-03-07 01:26:53 UTC (rev 108)
+++ trunk/rusage.h	2006-03-07 21:36:44 UTC (rev 109)
@@ -1 +1 @@
-void print_rusage(void);
+void print_rusage(struct timeval *start, struct timeval *stop);

Modified: trunk/test.c
===================================================================
--- trunk/test.c	2006-03-07 01:26:53 UTC (rev 108)
+++ trunk/test.c	2006-03-07 21:36:44 UTC (rev 109)
@@ -1044,19 +1044,20 @@
 }
 
 
-void print_test_summary()
+void print_test_summary(struct timeval *start, struct timeval *stop)
 {
     printf("\n");
     printf("%d test%s run, ", test_runs, (test_runs != 1 ? "s" : ""));
-    printf("%d success%s, ", test_successes, (test_successes != 1 ? "es" : ""));
-    printf("%d failure%s.", test_failures, (test_failures != 1 ? "s" : ""));
+    printf("%d success%s, ", test_successes,
+			(test_successes != 1 ? "es" : ""));
+    printf("%d failure%s", test_failures, (test_failures != 1 ? "s" : ""));
 
 	if(!quiet) {
-		printf("    ");
-		print_rusage();
+		printf(", in ");
+		print_rusage(start, stop);
 	}
 	
-	printf("\n");
+	printf(".\n");
 }
 
 

Modified: trunk/test.h
===================================================================
--- trunk/test.h	2006-03-07 01:26:53 UTC (rev 108)
+++ trunk/test.h	2006-03-07 21:36:44 UTC (rev 109)
@@ -87,7 +87,7 @@
 
 void test_results(struct test *test, const char *dispname);
 void dump_results(struct test *test);
-void print_test_summary();
+void print_test_summary(struct timeval *start, struct timeval *stop);
 
 void test_init(struct test *test);
 void test_free(struct test *test);





From tmtest-commits at berlios.de  Tue Mar  7 22:40:18 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 7 Mar 2006 22:40:18 +0100
Subject: [Tmtest-commits] [110] trunk: Fix format strings so test summary looks better, Get rid of
Message-ID: <200603072140.k27LeIj8007088@sheep.berlios.de>

Revision: 110
Author:   bronson
Date:     2006-03-07 22:40:08 +0100 (Tue, 07 Mar 2006)

Log Message:
-----------
Fix format strings so test summary looks better, Get rid of a spurios ;

Modified Paths:
--------------
    trunk/rusage.c
    trunk/tmtest.conf
Modified: trunk/rusage.c
===================================================================
--- trunk/rusage.c	2006-03-07 21:36:44 UTC (rev 109)
+++ trunk/rusage.c	2006-03-07 21:40:08 UTC (rev 110)
@@ -54,7 +54,7 @@
 			(int)(100.0*schild/total+0.5));
 			*/
 
-	printf("%.2fs (%02d%% user, %02d%% sys)",
+	printf("%.2fs (%d%% user, %d%% sys)",
 			total,
 			(int)(100.0*uchild/total+0.5),
 			(int)(100.0*schild/total+0.5));

Modified: trunk/tmtest.conf
===================================================================
--- trunk/tmtest.conf	2006-03-07 21:36:44 UTC (rev 109)
+++ trunk/tmtest.conf	2006-03-07 21:40:08 UTC (rev 110)
@@ -40,7 +40,7 @@
 # else (like /usr/bin or ~/bin).  This ensures that we lauch the unstable
 # copy of tmtest to handle each subtest.
 
-PATH="$MYDIR:$PATH";
+PATH="$MYDIR:$PATH"
 
 
 # All testfiles include $args in the arguments to the subexec.





From tmtest-commits at berlios.de  Tue Mar  7 23:09:12 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 7 Mar 2006 23:09:12 +0100
Subject: [Tmtest-commits] [111] trunk: Repair an 8-byte memory leak (well, depending on how many
Message-ID: <200603072209.k27M9CS3011910@sheep.berlios.de>

Revision: 111
Author:   bronson
Date:     2006-03-07 23:09:11 +0100 (Tue, 07 Mar 2006)

Log Message:
-----------
Repair an 8-byte memory leak (well, depending on how many args you pass)
and fix a spurious warning when you used an empty section in an -o or
a -d.  Unfortunately I don't see how to write a test for the second item.
Well, not without running tmtest under valgrind anyway.

Modified Paths:
--------------
    trunk/main.c
    trunk/test.c
    trunk/test.h
Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-03-07 21:40:08 UTC (rev 110)
+++ trunk/main.c	2006-03-07 22:09:11 UTC (rev 111)
@@ -288,7 +288,7 @@
 	test->diffname = buf;
 	fd = open_file(buf, DIFFNAME, 0);
 	assert(strlen(buf) == sizeof(TESTDIR)+sizeof(DIFFNAME)-1);
-	write_file(fd, 0);
+	write_file(fd, 0, NULL);
 	close(fd);
 
 	return fd;
@@ -1161,6 +1161,8 @@
 	for(i=0; i<n; i++) { normalize_path(argv[i], &ents[i]); }
 	process_ents(ents, 1);
 	for(i=0; i<n; i++) { normalize_free(argv[i], ents[i]); }
+
+	free(ents);
 }
 
 

Modified: trunk/test.c
===================================================================
--- trunk/test.c	2006-03-07 21:40:08 UTC (rev 110)
+++ trunk/test.c	2006-03-07 22:09:11 UTC (rev 111)
@@ -858,11 +858,19 @@
 }
 
 
-int write_file(int outfd, int infd)
+/**
+ * Reads all the data from infd and writes it onto outfd.
+ *
+ * @param endnl (optional) true if the data written ended with a newline,
+ *   false if not.  Pass NULL if you don't care.
+ * @returns the number of bytes written.
+ */
+
+size_t write_file(int outfd, int infd, int *endnl)
 {
     char buf[BUFSIZ];
-    int rcnt, wcnt;
-	int ending_newline;
+    size_t rcnt, wcnt;
+	size_t total = 0;
 
     // first rewind the input file
     if(lseek(infd, 0, SEEK_SET) < 0) {
@@ -876,7 +884,7 @@
             rcnt = read(infd, buf, sizeof(buf));
         } while(rcnt < 0 && errno == EINTR);
         if(rcnt > 0) {
-			ending_newline = (buf[rcnt-1] == '\n');
+			if(endnl) *endnl = (buf[rcnt-1] == '\n');
             do {
                 wcnt = write(outfd, buf, rcnt);
             } while(wcnt < 0 && errno == EINTR);
@@ -885,6 +893,7 @@
                 perror("writing in write_file");
                 break;
             }
+			total += rcnt;
         } else if (rcnt < 0) {
             // read error.  do something!
             perror("reading in write_file");
@@ -892,7 +901,7 @@
         }
     } while(rcnt);
 
-	return ending_newline;
+	return total;
 }
 
 
@@ -900,6 +909,7 @@
 		int fd, const char *name)
 {
     int marked_no_nl = 0;
+	size_t cnt;
 	int has_nl;
 
 	parse_section_args(datap, len,
@@ -907,7 +917,7 @@
 			start_output_section_argproc, &marked_no_nl);
 
 	write(test->rewritefd, datap, len);
-	has_nl = write_file(test->rewritefd, fd);
+	cnt = write_file(test->rewritefd, fd, &has_nl);
 
 	if(marked_no_nl) {
 		// if a section is marked with --no-trailing-newline, we need
@@ -924,7 +934,9 @@
 			printf("\n");
 		}
 
-		warn_section_newline(test, name);
+		if(cnt > 0) {
+			warn_section_newline(test, name);
+		}
 	}
 }
 
@@ -1035,11 +1047,11 @@
     }
     if(test->stderr_match == match_unknown && fd_has_data(test->errfd)) {
 		write_strconst(test->rewritefd, "STDERR:\n");
-        write_file(test->rewritefd, test->errfd);
+        write_file(test->rewritefd, test->errfd, NULL);
     }
     if(test->stdout_match == match_unknown && fd_has_data(test->outfd)) {
 		write_strconst(test->rewritefd, "STDOUT:\n");
-        write_file(test->rewritefd, test->outfd);
+        write_file(test->rewritefd, test->outfd, NULL);
     }
 }
 

Modified: trunk/test.h
===================================================================
--- trunk/test.h	2006-03-07 21:40:08 UTC (rev 110)
+++ trunk/test.h	2006-03-07 22:09:11 UTC (rev 111)
@@ -95,5 +95,5 @@
 
 // random utility function for start_diff.  Return value is true if the
 // file ends in a newline, false if not.
-int write_file(int outfd, int infd);
+size_t write_file(int outfd, int infd, int *ending_nl);
 





From tmtest-commits at berlios.de  Tue Mar  7 23:26:04 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 7 Mar 2006 23:26:04 +0100
Subject: [Tmtest-commits] [112] trunk: Rename --all-files to the much more understandable
Message-ID: <200603072226.k27MQ4cm015064@sheep.berlios.de>

Revision: 112
Author:   bronson
Date:     2006-03-07 23:26:02 +0100 (Tue, 07 Mar 2006)

Log Message:
-----------
Rename --all-files to the much more understandable --ignore-extension.

Modified Paths:
--------------
    trunk/TODO
    trunk/main.c
    trunk/test/01-testfile/21-TestVarsABS.test
    trunk/test/01-testfile/22-TestVarsRel.test
    trunk/test/01-testfile/24-TestVarsRoot.test
    trunk/test/03-results/30-Binary.test
    trunk/test/03-results/31-BinaryFail.test
    trunk/test/03-results/32-BinaryLarge.test
    trunk/test/03-results/33-BinaryHuge.test
    trunk/test/04-diff/02-MultiDiff.test
    trunk/test/04-diff/09-MultiLevelDiff.test
    trunk/test/04-diff/10-Patch.test
    trunk/test/04-diff/11-MultiPatch.test
    trunk/test/04-diff/12-MultiLevelPatch.test
    trunk/test/04-diff/13-MultiLevelPatch.test
    trunk/test/04-diff/21-PatchNoNL.test
    trunk/test/04-diff/22-PatchNoNL2.test
    trunk/test/04-diff/23-PatchNoNL3.test
    trunk/tmtest.pod
Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/TODO	2006-03-07 22:26:02 UTC (rev 112)
@@ -11,13 +11,15 @@
   That's probably the most agreeable.
   We will not read either config or test files from a world-writable directory.
   Ever.
-- Put $args into EVERY test we run.
+- Put $args into EVERY test we run.  NO!  This is not as useful.
+  Get rid of $args and turn every invocation of tmtest into $tmtest.
+  This allows us to run the entire suite under i.e. "valgrind tmtest"
+  - Figure out how to ensure that we run the binary in the project tree
+    when testing rather than the globally installed one.  What happened?
+	(this is how -- specify the executable and args using $tmtest).
 - Write a test to ensure we can run tests named "-.test"
-- Write tests to verify what FDs are still open when we run
-  config files, test files, and diff.
 - Add --diff and --shell to change the executables that get launched.
-- Get rid of MODIFY clauses.  It's unnecessary complexity.
-  And it's a LOT.  First remove it from the tests, then from the code.
+  No, that clutters the arguments up.  Take them from $DIFF and $SHELL.
 - Add the ability to specify test arguments on the command line.
   I'm picturing something where VAR=val on the command line would be
   inserted without change into the template.  That way you can use the
@@ -33,15 +35,12 @@
   abort the test.
   should get rid of a whole bunch in main.c as well.
   this should prevent us from dropping turds in /tmp all the time too.
-- Rename --all-files to --ignore-extension.
-- Move newline suppressing out of compare.c.  If it can't be moved out,
-  at least clean it up!   (maybe?)
-- Figure out how to ensure that we run the binary in the project tree
-  when testing rather than the globally installed one.  What happened?
 - Ensure it compiles and runs on freebsd.
 - Add some unit tests.  http://kooditakomo.cs.tut.fi/projects/gunit/
   http://pvanhoof.be/blog/index.php/2006/03/03/tinymail-unit-testing-and-creating-messages     Actually, this looks better: http://cutest.sourceforge.net/
   Potential units: curdir, path normalization
+    Need to rewrite curdir before it's worth unit testing it.
+	Path normalization definitely deserves it.
 - Get rid of -g, add -O2.  Make it easy to set these for compilation.
   Yes, have dev and prod modes.  dev would be -O0 and -g and include
   unit tests.  Prod is -O2, stripped, and no unit tests (unless the

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/main.c	2006-03-07 22:26:02 UTC (rev 112)
@@ -1013,7 +1013,7 @@
 	optidx = 0;
 	static struct option longopts[] = {
 		// name, has_arg (1=reqd,2=opt), flag, val
-		{"all-files", 0, &allfiles, 1},
+		{"ignore-extension", 0, &allfiles, 1},
 		{"config", 1, 0, 'c'},
 		{"diff", 0, 0, 'd'},
 		{"dump-script", 0, &dumpscript, 1},

Modified: trunk/test/01-testfile/21-TestVarsABS.test
===================================================================
--- trunk/test/01-testfile/21-TestVarsABS.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/01-testfile/21-TestVarsABS.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -8,7 +8,7 @@
 	echo TESTFILE: "$TESTFILE"
 EOL
 
-tmtest $args --all-files -o -q "$tt" <<-EOL | REPLACE "$tt" /tmp/FILE | INDENT
+tmtest $args --ignore-extension -o -q "$tt" <<-EOL | REPLACE "$tt" /tmp/FILE | INDENT
 
 STDOUT:
     echo MYDIR:    "$MYDIR"

Modified: trunk/test/01-testfile/22-TestVarsRel.test
===================================================================
--- trunk/test/01-testfile/22-TestVarsRel.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/01-testfile/22-TestVarsRel.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -9,7 +9,7 @@
 EOL
 
 cd `dirname "$tt"`
-tmtest $args --all-files -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
+tmtest $args --ignore-extension -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
 
 STDOUT:
     echo MYDIR:    "$MYDIR"

Modified: trunk/test/01-testfile/24-TestVarsRoot.test
===================================================================
--- trunk/test/01-testfile/24-TestVarsRoot.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/01-testfile/24-TestVarsRoot.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -9,7 +9,7 @@
 EOL
 
 cd `dirname "$tt"`
-tmtest $args --all-files -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
+tmtest $args --ignore-extension -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
 
 STDOUT:
     echo MYDIR:    "$MYDIR"

Modified: trunk/test/03-results/30-Binary.test
===================================================================
--- trunk/test/03-results/30-Binary.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/03-results/30-Binary.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -14,7 +14,7 @@
 echo -e "\\0\\0\\0\\0" >> "$tt"
 
 # and run the test
-tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
+tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
 ok   /tmp/FILE 

Modified: trunk/test/03-results/31-BinaryFail.test
===================================================================
--- trunk/test/03-results/31-BinaryFail.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/03-results/31-BinaryFail.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -14,7 +14,7 @@
 echo -e "\\0\\0\\0" >> "$tt"
 
 # and run the test
-tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
+tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
 FAIL /tmp/FILE        O..  stdout differed

Modified: trunk/test/03-results/32-BinaryLarge.test
===================================================================
--- trunk/test/03-results/32-BinaryLarge.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/03-results/32-BinaryLarge.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -25,7 +25,7 @@
 done >> "$tt"
 
 # and run the test
-tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
+tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
 ok   /tmp/FILE 

Modified: trunk/test/03-results/33-BinaryHuge.test
===================================================================
--- trunk/test/03-results/33-BinaryHuge.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/03-results/33-BinaryHuge.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -19,7 +19,7 @@
 perl -e 'for(my $i=0; $i<256; $i++) { for(my $j=0; $j<256; $j++) { print pack("cc", $i, $j); }}; print "\n";' >> "$tt"
 
 # and run the test
-tmtest --all-files -q "$tt" | REPLACE "$tt" /tmp/FILE
+tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
 ok   /tmp/FILE 

Modified: trunk/test/04-diff/02-MultiDiff.test
===================================================================
--- trunk/test/04-diff/02-MultiDiff.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/04-diff/02-MultiDiff.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -18,7 +18,7 @@
 	test 2 wrong output
 EOF
 
-tmtest --all-files -d "$t1" "$t2" | FIX_DIFF
+tmtest --ignore-extension -d "$t1" "$t2" | FIX_DIFF
 
 
 STDOUT:

Modified: trunk/test/04-diff/09-MultiLevelDiff.test
===================================================================
--- trunk/test/04-diff/09-MultiLevelDiff.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/04-diff/09-MultiLevelDiff.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -51,7 +51,7 @@
 EOL
 
 
-tmtest --all-files -d | FIX_DIFF
+tmtest --ignore-extension -d | FIX_DIFF
 
 rm -rf t.test one two
 

Modified: trunk/test/04-diff/10-Patch.test
===================================================================
--- trunk/test/04-diff/10-Patch.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/04-diff/10-Patch.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -15,7 +15,7 @@
 # This is a little exotic...  Patch needs the CWD to be the directory
 # containing the file to patch.  "dirname $(tt.test)" gives that dir.
 
-tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
+tmtest --ignore-extension -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 echo
 INDENT "\t" < "$tt"

Modified: trunk/test/04-diff/11-MultiPatch.test
===================================================================
--- trunk/test/04-diff/11-MultiPatch.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/04-diff/11-MultiPatch.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -26,7 +26,7 @@
 
 # All tt* files must be in the same directory.
 
-tmtest --all-files -d "$tt1" "$tt2" "$tt3" | (cd `dirname "$tt1"` && patch | FIX_PATCH)
+tmtest --ignore-extension -d "$tt1" "$tt2" "$tt3" | (cd `dirname "$tt1"` && patch | FIX_PATCH)
 echo
 INDENT "\t" < "$tt1"
 echo

Modified: trunk/test/04-diff/12-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/12-MultiLevelPatch.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/04-diff/12-MultiLevelPatch.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -51,7 +51,7 @@
 EOL
 
 
-tmtest --all-files -d | patch -p0 | FIX_PATCH
+tmtest --ignore-extension -d | patch -p0 | FIX_PATCH
 echo
 INDENT "\t" < t.test
 echo

Modified: trunk/test/04-diff/13-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/13-MultiLevelPatch.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/04-diff/13-MultiLevelPatch.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -52,7 +52,7 @@
 
 cd two
 
-tmtest --all-files -d .. | patch -p0 | FIX_PATCH
+tmtest --ignore-extension -d .. | patch -p0 | FIX_PATCH
 echo
 INDENT "\t" < ../t.test
 echo

Modified: trunk/test/04-diff/21-PatchNoNL.test
===================================================================
--- trunk/test/04-diff/21-PatchNoNL.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/04-diff/21-PatchNoNL.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -20,7 +20,7 @@
 # Ignore stderr because we want to ignore the warning that tmtest prints
 # about the sections not having matching trailing newlines.
 
-tmtest --all-files -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
+tmtest --ignore-extension -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 INDENT < "$tt"
 echo "<<DONE>>"

Modified: trunk/test/04-diff/22-PatchNoNL2.test
===================================================================
--- trunk/test/04-diff/22-PatchNoNL2.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/04-diff/22-PatchNoNL2.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -27,7 +27,7 @@
 # Pipe STDERR to /dev/null because we want to ignore the warning that
 # tmtest prints (other tests ensure the warning works)
 
-tmtest --all-files -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
+tmtest --ignore-extension -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 INDENT < "$tt"
 echo "<<DONE>>"

Modified: trunk/test/04-diff/23-PatchNoNL3.test
===================================================================
--- trunk/test/04-diff/23-PatchNoNL3.test	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/test/04-diff/23-PatchNoNL3.test	2006-03-07 22:26:02 UTC (rev 112)
@@ -21,7 +21,7 @@
 # This is a little exotic...  Patch needs the CWD to be the directory
 # containing the file to patch.  "dirname $(tt.test)" gives that dir.
 
-tmtest --all-files -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
+tmtest --ignore-extension -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 INDENT < "$tt"
 echo "<<DONE>>"

Modified: trunk/tmtest.pod
===================================================================
--- trunk/tmtest.pod	2006-03-07 22:09:11 UTC (rev 111)
+++ trunk/tmtest.pod	2006-03-07 22:26:02 UTC (rev 112)
@@ -14,20 +14,6 @@
 
 =over 8
 
-=item B<--all-files>
-
-Causes tmtest to ignore the name of the testfile while running tests.
-
-Normally tmtest only runs files with names that end in ".test".
-While this is often a very good thing (you wouldn't want tmtest
-to try to run just any old random file as a test), sometimes it
-gets in the way.  For instance, MKFILE offers no control over the
-name of the file generated.  If you used MKFILE to create a
-testfile, run tmtest with --all-files and name the testfile explicitly
-on the command line.
-
-See 10-Patch.test for an example.  (TODO: cobble together a better example)
-
 =item B<-c> B<--config>
 
 Specifies the config file to be read before running the test file.
@@ -55,6 +41,12 @@
 into your test deck.  Make sure you know exactly what you
 changed, right down to the whitespace.
 
+=item B<--ignore-extension>
+
+Normally tmtest only runs files with names that end in ".test".
+This argument causes tmtest to ignore the name of the testfile
+and run every testfile it's told to.  Be careful!
+
 =item B<-q> B<--quiet>
 
 Tells tmtest to be quiet while running tests.  tmtest only prints the





From tmtest-commits at berlios.de  Tue Mar  7 23:41:15 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Tue, 7 Mar 2006 23:41:15 +0100
Subject: [Tmtest-commits] [113] trunk: Add two tests to check running files named - and -.test.
Message-ID: <200603072241.k27MfFul017502@sheep.berlios.de>

Revision: 113
Author:   bronson
Date:     2006-03-07 23:41:14 +0100 (Tue, 07 Mar 2006)

Log Message:
-----------
Add two tests to check running files named - and -.test.

Modified Paths:
--------------
    trunk/CHANGES
    trunk/TODO

Added Paths:
-----------
    trunk/test/02-running/60-TestDash.test
    trunk/test/02-running/61-TestDash.test
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-03-07 22:26:02 UTC (rev 112)
+++ trunk/CHANGES	2006-03-07 22:41:14 UTC (rev 113)
@@ -1,3 +1,4 @@
+- Changed --all-files to be the much more understandable --ignore-extension.
 - If an output section is marked -n but ends with multiple newlines, we print
   a warning and fail it automatically.  We used to let this nonsense pass.
 - Added the Cutest unit test framework.  Refactored compare.c.

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-07 22:26:02 UTC (rev 112)
+++ trunk/TODO	2006-03-07 22:41:14 UTC (rev 113)
@@ -17,15 +17,22 @@
   - Figure out how to ensure that we run the binary in the project tree
     when testing rather than the globally installed one.  What happened?
 	(this is how -- specify the executable and args using $tmtest).
-- Write a test to ensure we can run tests named "-.test"
 - Add --diff and --shell to change the executables that get launched.
   No, that clutters the arguments up.  Take them from $DIFF and $SHELL.
+  No, obviously that's a bad idea.  That prevents people using tcsh
+  from running tmtest.  It *has* to be --shell.  $DIFF is fine.
+  And we need to make sure that we ignore the SHELL envar.
+  	(write a test for this)
 - Add the ability to specify test arguments on the command line.
   I'm picturing something where VAR=val on the command line would be
   inserted without change into the template.  That way you can use the
   command line to override default settings in the testfile.
   - This would allow us to test almost every test to ensure it
     supports the --config argument (make them DISABLED or something).
+  - How it will work: we insert each value at the start of the testscript.
+    That way the config files can pick up on them.  We ALSO insert them
+	just before we run the test.  That way we can override the config files.
+	True, we can't override what's in the test script, but that's OK.
 - write tests for nesting testfiles with --config.
         // If the user specifies a config file, we only check directories
         // not above the given config file.  i.e. if user specifies
@@ -84,6 +91,9 @@
   see if any of your tests have intermittent failures.
 - Reomve as many TODOs as possible.
 - Make zutest take the names of tests to run on stdin?
+- Make MKFILE take a path as the first argument too.  If the first arg
+  is [0-9a-zA-Z_] then it's an identifier and we'll make a tempfile.
+  Otherwise, we'll use the arg as a filename.  ER, IS THIS A GOOD IDEA?
 
 1.0!
 

Added: trunk/test/02-running/60-TestDash.test
===================================================================
--- trunk/test/02-running/60-TestDash.test	2006-03-07 22:26:02 UTC (rev 112)
+++ trunk/test/02-running/60-TestDash.test	2006-03-07 22:41:14 UTC (rev 113)
@@ -0,0 +1,20 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is aborted.
+
+MKDIR dir
+
+MKFILE file "$dir/-.test" <<-EOL
+	echo Howdy pardner.
+	STDOUT:
+	Howdy pardner.
+EOL
+
+tmtest -q "$file" | REPLACE "$dir" /tmp/DIR
+
+
+STDOUT:
+ok   /tmp/DIR/-.test 
+
+1 test run, 1 success, 0 failures.

Added: trunk/test/02-running/61-TestDash.test
===================================================================
--- trunk/test/02-running/61-TestDash.test	2006-03-07 22:26:02 UTC (rev 112)
+++ trunk/test/02-running/61-TestDash.test	2006-03-07 22:41:14 UTC (rev 113)
@@ -0,0 +1,20 @@
+# author: Scott Bronson
+# date:   14 Nov 2004
+
+# Verifies what happens when a test is aborted.
+
+MKDIR dir
+
+MKFILE file "$dir/-" <<-EOL
+	echo Howdy pardner.
+	STDOUT:
+	Howdy pardner.
+EOL
+
+tmtest -q --ignore-extension "$file" | REPLACE "$dir" /tmp/DIR
+
+
+STDOUT:
+ok   /tmp/DIR/- 
+
+1 test run, 1 success, 0 failures.





From tmtest-commits at berlios.de  Wed Mar  8 00:24:47 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Wed, 8 Mar 2006 00:24:47 +0100
Subject: [Tmtest-commits] [114] trunk: Fix $PATH handling, change how tmlib is included.
Message-ID: <200603072324.k27NOlOW023166@sheep.berlios.de>

Revision: 114
Author:   bronson
Date:     2006-03-08 00:24:44 +0100 (Wed, 08 Mar 2006)

Log Message:
-----------
Fix $PATH handling, change how tmlib is included.  Every test now needs
to invoke tmtest as $tmtest.

Modified Paths:
--------------
    trunk/TODO
    trunk/test/00-cmdline/01-UnknownSwitch.test
    trunk/test/00-cmdline/02-UnknownSwitch.test
    trunk/test/00-cmdline/10-CfgDir.test
    trunk/test/00-cmdline/11-CfgMissing.test
    trunk/test/00-cmdline/12-CfgEmpty.test
    trunk/test/01-testfile/01-ExitGarbageWarn.test
    trunk/test/01-testfile/02-StdOutNK.test
    trunk/test/01-testfile/03-StdErrNK.test
    trunk/test/01-testfile/05-MultipleStdout.test
    trunk/test/01-testfile/06-MultipleStderr.test
    trunk/test/01-testfile/08-GarbageInStdout.test
    trunk/test/01-testfile/09-GarbageInStderr.test
    trunk/test/01-testfile/11-InnerConfig.test
    trunk/test/01-testfile/20-TestVars.test
    trunk/test/01-testfile/21-TestVarsABS.test
    trunk/test/01-testfile/22-TestVarsRel.test
    trunk/test/01-testfile/23-TestVarsDeep.test
    trunk/test/01-testfile/24-TestVarsRoot.test
    trunk/test/01-testfile/dumpscript/10-Stdout.test
    trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test
    trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test
    trunk/test/01-testfile/dumpscript/13-BareParentDir.test
    trunk/test/01-testfile/dumpscript/14-DeepDir.test
    trunk/test/01-testfile/dumpscript/15-PathOps.test
    trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test
    trunk/test/02-running/00-Empty.test
    trunk/test/02-running/01-Empty.test
    trunk/test/02-running/02-Empty.test
    trunk/test/02-running/04-Pwd.test
    trunk/test/02-running/05-Abort.test
    trunk/test/02-running/05-Disable.test
    trunk/test/02-running/05-Running.test
    trunk/test/02-running/06-Abort2.test
    trunk/test/02-running/06-Disable2.test
    trunk/test/02-running/06-Hidden.test
    trunk/test/02-running/07-Abort3.test
    trunk/test/02-running/07-Disable3.test
    trunk/test/02-running/08-Abort4.test
    trunk/test/02-running/08-Disable4.test
    trunk/test/02-running/10-Assert.test
    trunk/test/02-running/11-Assert.test
    trunk/test/02-running/12-Disabled.test
    trunk/test/02-running/13-DisabledDir.test
    trunk/test/02-running/14-AbortConf.test
    trunk/test/02-running/15-DisabledDir.test
    trunk/test/02-running/16-ConfigError.test
    trunk/test/02-running/17-ConfigError.test
    trunk/test/02-running/18-TestError.test
    trunk/test/02-running/20-Atexit.test
    trunk/test/02-running/21-QuoteFile.test
    trunk/test/02-running/22-Signal.test
    trunk/test/02-running/30-Mkfile.test
    trunk/test/02-running/31-Mkfile.test
    trunk/test/02-running/32-Mkdir.test
    trunk/test/02-running/33-Mkdir.test
    trunk/test/02-running/34-Mkdir.test
    trunk/test/02-running/40-Replace.test
    trunk/test/02-running/41-Indent.test
    trunk/test/02-running/50-OpenFDsTest.test
    trunk/test/02-running/51-OpenFDsConfig.tst
    trunk/test/02-running/60-TestDash.test
    trunk/test/02-running/61-TestDash.test
    trunk/test/03-results/01-Ystderr.test
    trunk/test/03-results/01-YstderrOut.test
    trunk/test/03-results/01-Ystdout.test
    trunk/test/03-results/01-YstdoutOut.test
    trunk/test/03-results/02-Nstderr.test
    trunk/test/03-results/02-Nstdout.test
    trunk/test/03-results/03-Nstderr.test
    trunk/test/03-results/03-Nstdout.test
    trunk/test/03-results/04-Nstderr.test
    trunk/test/03-results/04-Nstdout.test
    trunk/test/03-results/09-NoNL.test
    trunk/test/03-results/09-NoNLStderr.test
    trunk/test/03-results/10-NoNLErrFail.test
    trunk/test/03-results/10-NoNLFFail.test
    trunk/test/03-results/10-NoNLFail.test
    trunk/test/03-results/11-NoNLOutput.test
    trunk/test/03-results/11-NoNLOutput2.test
    trunk/test/03-results/12-NoNLTwice.test
    trunk/test/03-results/13-MultiNL.test
    trunk/test/03-results/13-MultiNL2.test
    trunk/test/03-results/13-MultiNL2Err.test
    trunk/test/03-results/13-MultiNLErr.test
    trunk/test/03-results/14-NoNLWarn.test
    trunk/test/03-results/15-EmptyWithErr.test
    trunk/test/03-results/15-EmptyWithOut.test
    trunk/test/03-results/16-EmptyWithErrNoNL.test
    trunk/test/03-results/16-EmptyWithOutNoNL.test
    trunk/test/03-results/17-NoStderr.test
    trunk/test/03-results/18-NoNLWarnOut.test
    trunk/test/03-results/30-Binary.test
    trunk/test/03-results/31-BinaryFail.test
    trunk/test/03-results/32-BinaryLarge.test
    trunk/test/03-results/33-BinaryHuge.test
    trunk/test/04-diff/00-NoDiff.test
    trunk/test/04-diff/01-Diff.test
    trunk/test/04-diff/02-MultiDiff.test
    trunk/test/04-diff/05-AbortDiff.test
    trunk/test/04-diff/05-DisableDiff.test
    trunk/test/04-diff/06-AbortDiff2.test
    trunk/test/04-diff/06-DisableDiff2.test
    trunk/test/04-diff/07-AbortDiff3.test
    trunk/test/04-diff/07-DisableDiff3.test
    trunk/test/04-diff/08-AbortDiff4.test
    trunk/test/04-diff/08-DisableDiff4.test
    trunk/test/04-diff/09-MultiLevelDiff.test
    trunk/test/04-diff/10-Patch.test
    trunk/test/04-diff/11-MultiPatch.test
    trunk/test/04-diff/12-MultiLevelPatch.test
    trunk/test/04-diff/13-MultiLevelPatch.test
    trunk/test/04-diff/17-ConfigError.test
    trunk/test/04-diff/18-NeedNLWarn.test
    trunk/test/04-diff/20-DiffNoNL.test
    trunk/test/04-diff/21-PatchNoNL.test
    trunk/test/04-diff/22-PatchNoNL2.test
    trunk/test/04-diff/23-PatchNoNL3.test
    trunk/tmtest.conf
Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/TODO	2006-03-07 23:24:44 UTC (rev 114)
@@ -11,12 +11,6 @@
   That's probably the most agreeable.
   We will not read either config or test files from a world-writable directory.
   Ever.
-- Put $args into EVERY test we run.  NO!  This is not as useful.
-  Get rid of $args and turn every invocation of tmtest into $tmtest.
-  This allows us to run the entire suite under i.e. "valgrind tmtest"
-  - Figure out how to ensure that we run the binary in the project tree
-    when testing rather than the globally installed one.  What happened?
-	(this is how -- specify the executable and args using $tmtest).
 - Add --diff and --shell to change the executables that get launched.
   No, that clutters the arguments up.  Take them from $DIFF and $SHELL.
   No, obviously that's a bad idea.  That prevents people using tcsh
@@ -54,6 +48,11 @@
   unit tests only add 12K or so, where might as well just leave em).
 - If there were failures, should highlight that in the test summary.
 	"%d FAILURES" or somesuch.
+- Well, piping the result of a command to a function destroys the the
+  exit code.  I don't know of any good way around this!  Maybe this
+  is a good argument to have rewriting performed by tmtest itself...
+  I think it is.  So, we can add, "STDOUT: --pipe 'sed -e /.../'"
+  or something.  I don't like that.  Ick. it all sucks.
 
 0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.
@@ -142,6 +141,11 @@
   DISABLED DISABLED:  Hopefully that will clean up 05-08-Disable/Abort.test
 - Add a timeout that will terminate stalled tests.  You can set the timeout
   in the config file or the test itself.
+- I don't like that $tmtest expands to "$tmtest --config=...".  That's
+  not what one would normally expect.  However, since it also potentially
+  expands to "valgrind tmtest --config..." it's not THAT bad -- it's
+  never just a filename.  Maybe change $tmtest to $tmtest_cmd?  In every
+  test... arg.  or something!
 
 maybe never:
 - Add STDOUT: trimws and STDERR: trimws - to trim whitespace from

Modified: trunk/test/00-cmdline/01-UnknownSwitch.test
===================================================================
--- trunk/test/00-cmdline/01-UnknownSwitch.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/00-cmdline/01-UnknownSwitch.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,11 +1,13 @@
 # Verifies that we correctly report unknown short switches
 
-tmtest $args -z - <<-EOL
+# TODO: we pipe stderr to stdout for rewriting.  that needs to be
+# changed during 0.98.  Also, the exit code is lost -- tmtest returns 1.
+
+$tmtest -z - <<-EOL 2>&1 | REPLACE "$tmtest_file" tmtest
 	echo Howdy
 	STDOUT:
 	Howdy
 EOL
 
-RESULT: 1
-STDERR:
+STDOUT:
 tmtest: invalid option -- z

Modified: trunk/test/00-cmdline/02-UnknownSwitch.test
===================================================================
--- trunk/test/00-cmdline/02-UnknownSwitch.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/00-cmdline/02-UnknownSwitch.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,11 +1,14 @@
 # Verifies that we correctly report unknown short switches
 
-tmtest $args --huh - <<-EOL
+# TODO: this sends stderr to stdout for rewriting.  This sucks
+# and needs to be fixed.  The exit code is also lost.
+
+
+$tmtest --huh - <<-EOL 2>&1 | REPLACE "$tmtest_file" tmtest
 	echo Howdy
 	STDOUT:
 	Howdy
 EOL
 
-RESULT: 1
-STDERR:
+STDOUT:
 tmtest: unrecognized option `--huh'

Modified: trunk/test/00-cmdline/10-CfgDir.test
===================================================================
--- trunk/test/00-cmdline/10-CfgDir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/00-cmdline/10-CfgDir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,4 +1,4 @@
-tmtest $args --config=/tmp - <<-EOL
+$tmtest --config=/tmp - <<-EOL
 	echo Test!
 EOL
 

Modified: trunk/test/00-cmdline/11-CfgMissing.test
===================================================================
--- trunk/test/00-cmdline/11-CfgMissing.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/00-cmdline/11-CfgMissing.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -9,7 +9,7 @@
 	sed -e 's/Could not locate .*zzyzx: No such file or directory/Could not locate ...zzyzx: No such file or directory/'
 }
 
-tmtest $args --config="$MYDIR/zzyzx" - <<-EOL 2>&1 | SANIFY
+$tmtest --config="$MYDIR/zzyzx" - <<-EOL 2>&1 | SANIFY
 	echo Howdy
 	STDOUT:
 	Howdy

Modified: trunk/test/00-cmdline/12-CfgEmpty.test
===================================================================
--- trunk/test/00-cmdline/12-CfgEmpty.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/00-cmdline/12-CfgEmpty.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,4 +1,4 @@
-tmtest $args --config= - <<-EOL
+$tmtest --config= - <<-EOL
 	echo Howdy
 	STDOUT:
 	Howdy

Modified: trunk/test/01-testfile/01-ExitGarbageWarn.test
===================================================================
--- trunk/test/01-testfile/01-ExitGarbageWarn.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/01-ExitGarbageWarn.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # Ensure we emit a warning if the user includes garbage in his
 # exit value section.
 
-tmtest $args -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 	RESULT: 0
 	junque

Modified: trunk/test/01-testfile/02-StdOutNK.test
===================================================================
--- trunk/test/01-testfile/02-StdOutNK.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/02-StdOutNK.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # following char isn't a delimiter ("STDOUT ", "STDOUT:" and "STDOUT\n"
 # are all keywords, "STDOUTx" is not).
 
-tmtest $args -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo STDOUTx
 	STDOUT:
 	STDOUTx

Modified: trunk/test/01-testfile/03-StdErrNK.test
===================================================================
--- trunk/test/01-testfile/03-StdErrNK.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/03-StdErrNK.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -5,7 +5,7 @@
 # Same as 02, but works on STDERR not STDOUT.
 
 
-tmtest $args -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo STDERR. 1>&2
 	STDERR:
 	STDERR.

Modified: trunk/test/01-testfile/05-MultipleStdout.test
===================================================================
--- trunk/test/01-testfile/05-MultipleStdout.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/05-MultipleStdout.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # Ensure we emit a warning if we notice multiple STDOUT sections.
 
 
-tmtest $args -q - <<-EOL
+$tmtest -q - <<-EOL
 	# tmtest will use the empty section which comes first.
 	# Therefore, since the test actually does produce output,
 	# this test is expected to fail.

Modified: trunk/test/01-testfile/06-MultipleStderr.test
===================================================================
--- trunk/test/01-testfile/06-MultipleStderr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/06-MultipleStderr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # Ensure we emit a warning if the user includes multiple stderr sections.
 # This test succeeds because the second stderr section is ignored.
 
-tmtest $args -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 	STDOUT :
 	Howdy

Modified: trunk/test/01-testfile/08-GarbageInStdout.test
===================================================================
--- trunk/test/01-testfile/08-GarbageInStdout.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/08-GarbageInStdout.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -3,7 +3,7 @@
 #
 # Ensures that we recognize when the stdout clause contains garbage.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
     echo crapola
 	STDOUT: crapola
     crapola

Modified: trunk/test/01-testfile/09-GarbageInStderr.test
===================================================================
--- trunk/test/01-testfile/09-GarbageInStderr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/09-GarbageInStderr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -3,7 +3,7 @@
 #
 # Ensures that we recognize when the stdout clause contains garbage.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
     echo crapola
     echo crapola
     echo crapola

Modified: trunk/test/01-testfile/11-InnerConfig.test
===================================================================
--- trunk/test/01-testfile/11-InnerConfig.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/11-InnerConfig.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # test directory.  (seems like there's got to be a better way of doing
 # this but this works for now).
 
-tmtest $args -q - <<-'EOL'
+$tmtest $args -q - <<-'EOL'
 	if [ $OUTER_CONFIG_FILE ]; then
 		# this is what happens when inner tests don't have $args
 		ABORT "inner test read outer config file!"

Modified: trunk/test/01-testfile/20-TestVars.test
===================================================================
--- trunk/test/01-testfile/20-TestVars.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/20-TestVars.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # MYDIR=/tmp, MYFILE="(STDIN)", TESTDIR=/tmp, TESTFILE="(STDIN)"
 
 
-tmtest $args -o -q - <<-'EOL' | INDENT
+$tmtest $args -o -q - <<-'EOL' | INDENT
 	echo MYDIR:    "$MYDIR"
 	echo MYFILE:   "$MYFILE"
 	echo TESTDIR:  "$TESTDIR"

Modified: trunk/test/01-testfile/21-TestVarsABS.test
===================================================================
--- trunk/test/01-testfile/21-TestVarsABS.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/21-TestVarsABS.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -8,7 +8,7 @@
 	echo TESTFILE: "$TESTFILE"
 EOL
 
-tmtest $args --ignore-extension -o -q "$tt" <<-EOL | REPLACE "$tt" /tmp/FILE | INDENT
+$tmtest $args --ignore-extension -o -q "$tt" <<-EOL | REPLACE "$tt" /tmp/FILE | INDENT
 
 STDOUT:
     echo MYDIR:    "$MYDIR"

Modified: trunk/test/01-testfile/22-TestVarsRel.test
===================================================================
--- trunk/test/01-testfile/22-TestVarsRel.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/22-TestVarsRel.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -9,7 +9,7 @@
 EOL
 
 cd `dirname "$tt"`
-tmtest $args --ignore-extension -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
+$tmtest $args --ignore-extension -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
 
 STDOUT:
     echo MYDIR:    "$MYDIR"

Modified: trunk/test/01-testfile/23-TestVarsDeep.test
===================================================================
--- trunk/test/01-testfile/23-TestVarsDeep.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/23-TestVarsDeep.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -13,7 +13,7 @@
 EOL
 
 cd "$do"
-tmtest $config -o -q "di/tt.test" <<-EOL | REPLACE $do /tmp/DIR | INDENT
+$tmtest $config -o -q "di/tt.test" <<-EOL | REPLACE $do /tmp/DIR | INDENT
 
 STDOUT:
     echo MYDIR:    "$MYDIR"

Modified: trunk/test/01-testfile/24-TestVarsRoot.test
===================================================================
--- trunk/test/01-testfile/24-TestVarsRoot.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/24-TestVarsRoot.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -9,7 +9,7 @@
 EOL
 
 cd `dirname "$tt"`
-tmtest $args --ignore-extension -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
+$tmtest $args --ignore-extension -o -q `basename "$tt"` <<-EOL | REPLACE $tt /tmp/FILE | INDENT
 
 STDOUT:
     echo MYDIR:    "$MYDIR"

Modified: trunk/test/01-testfile/dumpscript/10-Stdout.test
===================================================================
--- trunk/test/01-testfile/dumpscript/10-Stdout.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/dumpscript/10-Stdout.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -5,7 +5,7 @@
 # The --config directive disables reading config files from the directory
 # containing the named config file and all its parent directories.
 
-tmtest $args --dump-script - <<-EOL | FIX_SCRIPT
+$tmtest --dump-script - <<-EOL | FIX_SCRIPT
 	this test is never run but we do need to specify a file so tmtest
 	knows what config files to include.
 EOL

Modified: trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/dumpscript/11-AbsoluteDir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -17,7 +17,7 @@
 	echo "$config"
 EOL
 
-tmtest $args --dump-script "$dd/" | REPLACE "$dd" /tmp/DIR | FIX_SCRIPT
+$tmtest --dump-script "$dd/" | REPLACE "$dd" /tmp/DIR | FIX_SCRIPT
 
 STDOUT:
 	

Modified: trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/dumpscript/12-TrailingParentDir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -26,7 +26,7 @@
 EOL
 
 
-tmtest $args --dump-script "$di/.." | REPLACE "$do" /tmp/DIR | FIX_SCRIPT
+$tmtest --dump-script "$di/.." | REPLACE "$do" /tmp/DIR | FIX_SCRIPT
 
 
 STDOUT:

Modified: trunk/test/01-testfile/dumpscript/13-BareParentDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/13-BareParentDir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/dumpscript/13-BareParentDir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -25,7 +25,7 @@
 
 
 cd "$di"
-tmtest $args --dump-script ".." | REPLACE "$do" /tmp/DIR | FIX_SCRIPT
+$tmtest --dump-script ".." | REPLACE "$do" /tmp/DIR | FIX_SCRIPT
 
 
 STDOUT:

Modified: trunk/test/01-testfile/dumpscript/14-DeepDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/14-DeepDir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/dumpscript/14-DeepDir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -29,7 +29,7 @@
 
 
 cd `dirname "$do"`
-tmtest $args --dump-script "$(basename $do)/di" | REPLACE "$(basename $do)" DIR | FIX_SCRIPT
+$tmtest --dump-script "$(basename $do)/di" | REPLACE "$(basename $do)" DIR | FIX_SCRIPT
 
 
 STDOUT:

Modified: trunk/test/01-testfile/dumpscript/15-PathOps.test
===================================================================
--- trunk/test/01-testfile/dumpscript/15-PathOps.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/dumpscript/15-PathOps.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -12,7 +12,7 @@
 	echo "$config"
 EOL
 
-tmtest $args --dump-script "$dd//abc/./..//def/ghi//./../../" | REPLACE "$dd" /tmp/DIR | FIX_SCRIPT
+$tmtest --dump-script "$dd//abc/./..//def/ghi//./../../" | REPLACE "$dd" /tmp/DIR | FIX_SCRIPT
 
 STDOUT:
 	

Modified: trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test
===================================================================
--- trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/01-testfile/dumpscript/16-AbsoluteDir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -28,7 +28,7 @@
 EOL
 
 
-tmtest $args --dump-script "$do/di//../di" | REPLACE "$do" DIR | FIX_SCRIPT
+$tmtest --dump-script "$do/di//../di" | REPLACE "$do" DIR | FIX_SCRIPT
 
 
 STDOUT:

Modified: trunk/test/02-running/00-Empty.test
===================================================================
--- trunk/test/02-running/00-Empty.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/00-Empty.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # no stderr, and an exit code of 0.
 
 
-tmtest $CFG -q - <<-EOL
+$tmtest -q - <<-EOL
 EOL
 
 

Modified: trunk/test/02-running/01-Empty.test
===================================================================
--- trunk/test/02-running/01-Empty.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/01-Empty.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,6 +1,6 @@
 # What happens when we output an empty test file?
 # Should just produce nothing.
 
-tmtest $CFG -o - <<-EOL
+$tmtest -o - <<-EOL
 EOL
 

Modified: trunk/test/02-running/02-Empty.test
===================================================================
--- trunk/test/02-running/02-Empty.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/02-Empty.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,6 +2,6 @@
 
 # Diff should produce no data since nothing differs from the default.
 
-tmtest $CFG -d - <<-EOL
+$tmtest -d - <<-EOL
 EOL
 

Modified: trunk/test/02-running/04-Pwd.test
===================================================================
--- trunk/test/02-running/04-Pwd.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/04-Pwd.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -5,7 +5,7 @@
 # TMPFILE environment variable, or if TMPFILE='/tmp'.  If you have
 # some other value in TMPFILE, you will have to modify this test.
 
-tmtest $CFG -q - <<-EOL
+$tmtest -q - <<-EOL
 	pwd
 	STDOUT:
 	/tmp

Modified: trunk/test/02-running/05-Abort.test
===================================================================
--- trunk/test/02-running/05-Abort.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/05-Abort.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -5,7 +5,7 @@
 
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	ABORT
 	echo "right output"
 	STDOUT:

Modified: trunk/test/02-running/05-Disable.test
===================================================================
--- trunk/test/02-running/05-Disable.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/05-Disable.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -5,7 +5,7 @@
 
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	DISABLED
 	echo "right output"
 	STDOUT:

Modified: trunk/test/02-running/05-Running.test
===================================================================
--- trunk/test/02-running/05-Running.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/05-Running.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -38,7 +38,7 @@
 	skip
 EOL
 
-tmtest $CFG -q mid.test sub/sub.test ../sup.test sub . ..
+$tmtest -q mid.test sub/sub.test ../sup.test sub . ..
 
 # clean up after ourselves
 rm -rf ../sup.test ../mid

Modified: trunk/test/02-running/06-Abort2.test
===================================================================
--- trunk/test/02-running/06-Abort2.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/06-Abort2.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # Verifies what happens when a test is aborted and gives a reason.
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	ABORT: This is the reason
 	echo "right output"
 	STDOUT:

Modified: trunk/test/02-running/06-Disable2.test
===================================================================
--- trunk/test/02-running/06-Disable2.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/06-Disable2.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # Verifies what happens when a test is disabled and gives a reason.
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	DISABLED: This is the reason
 	echo "right output"
 	STDOUT:

Modified: trunk/test/02-running/06-Hidden.test
===================================================================
--- trunk/test/02-running/06-Hidden.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/06-Hidden.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -10,7 +10,7 @@
 	hidden
 EOL
 
-tmtest $CFG -q
+$tmtest -q
 rm .hidden.test
 
 

Modified: trunk/test/02-running/07-Abort3.test
===================================================================
--- trunk/test/02-running/07-Abort3.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/07-Abort3.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # Verifies what happens when a test is aborted but output is selected.
 
 
-tmtest -q -o - <<-EOL
+$tmtest -q -o - <<-EOL
 	ABORT This is the reason
 	echo "right output"
 	STDOUT:

Modified: trunk/test/02-running/07-Disable3.test
===================================================================
--- trunk/test/02-running/07-Disable3.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/07-Disable3.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # Verifies what happens when a test is disabled but output is selected.
 
 
-tmtest -q -o - <<-EOL
+$tmtest -q -o - <<-EOL
 	DISABLED This is the reason
 	echo "right output"
 	STDOUT:

Modified: trunk/test/02-running/08-Abort4.test
===================================================================
--- trunk/test/02-running/08-Abort4.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/08-Abort4.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -10,7 +10,7 @@
 # dis  (STDIN)                   :    
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	ABORT: "   "
 	echo "right output"
 	STDOUT:

Modified: trunk/test/02-running/08-Disable4.test
===================================================================
--- trunk/test/02-running/08-Disable4.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/08-Disable4.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -10,7 +10,7 @@
 # dis  (STDIN)                   :    
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	DISABLED: "   "
 	echo "right output"
 	STDOUT:

Modified: trunk/test/02-running/10-Assert.test
===================================================================
--- trunk/test/02-running/10-Assert.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/10-Assert.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -6,7 +6,7 @@
 # will read the config files.
 cd "$TESTDIR"
 
-tmtest $CFG -q - <<-EOL
+$tmtest -q - <<-EOL
 	ASSERT 1 -eq 1
 	echo it ran
 	STDOUT:

Modified: trunk/test/02-running/11-Assert.test
===================================================================
--- trunk/test/02-running/11-Assert.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/11-Assert.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -8,7 +8,7 @@
 
 
 cd "$TESTDIR"
-tmtest $CFG -q - <<-EOL | sed -re "s/ on.*line [0-9]+/ on line LL/"
+$tmtest -q - <<-EOL | sed -re "s/ on.*line [0-9]+/ on line LL/"
 	ASSERT -1 -eq 1
 	echo it ran
 	STDOUT:

Modified: trunk/test/02-running/12-Disabled.test
===================================================================
--- trunk/test/02-running/12-Disabled.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/12-Disabled.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # Ensures that a disabled test doesn't run.
 
 
-tmtest $CFG -q - <<-EOL
+$tmtest -q - <<-EOL
 	DISABLED
 	echo it ran
 	STDOUT:

Modified: trunk/test/02-running/13-DisabledDir.test
===================================================================
--- trunk/test/02-running/13-DisabledDir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/13-DisabledDir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -19,7 +19,7 @@
 	he
 EOs
 
-tmtest $CFG -q | REPLACE "$dir" /tmp/DIR
+$tmtest -q | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 

Modified: trunk/test/02-running/14-AbortConf.test
===================================================================
--- trunk/test/02-running/14-AbortConf.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/14-AbortConf.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -22,7 +22,7 @@
 	he
 EOs
 
-tmtest $CFG -q | REPLACE "$dir" /tmp/DIR
+$tmtest -q | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 

Modified: trunk/test/02-running/15-DisabledDir.test
===================================================================
--- trunk/test/02-running/15-DisabledDir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/15-DisabledDir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -20,7 +20,7 @@
 	he
 EOs
 
-tmtest $CFG -q | REPLACE "$dir" /tmp/DIR
+$tmtest -q | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 

Modified: trunk/test/02-running/16-ConfigError.test
===================================================================
--- trunk/test/02-running/16-ConfigError.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/16-ConfigError.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -3,7 +3,7 @@
 
 # TODO: figure out how to rewrite stderr.  That may require some
 # assistance from tmtest...  After 0.98's streaming changes though.
-# 	tmtest $CFG -q 2> >( REPLACE "$dir" /tmp/DIR >&2 )
+# 	tmtest -q 2> >( REPLACE "$dir" /tmp/DIR >&2 )
 
 MKDIR dir
 cd "$dir"
@@ -25,7 +25,7 @@
 	he
 EOs
 
-tmtest $CFG -q 2>&1 | REPLACE "$dir" /tmp/DIR
+$tmtest -q 2>&1 | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 
@@ -34,8 +34,8 @@
 /tmp/DIR/tmtest.conf: line 2: dotheyspeakbocceonwhat: command not found
 
 Processing .
-ok   t1.test 
-ok   t2.test 
+ERR  t1.test                   error in /tmp/DIR/tmtest.conf
+ERR  t2.test                   error in /tmp/DIR/tmtest.conf
 
-2 tests run, 2 successes, 0 failures.
+2 tests run, 0 successes, 2 failures.
 STDERR:

Modified: trunk/test/02-running/17-ConfigError.test
===================================================================
--- trunk/test/02-running/17-ConfigError.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/17-ConfigError.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -27,7 +27,7 @@
 	he
 EOs
 
-tmtest $CFG -q 2>&1 | REPLACE "$dir" /tmp/DIR
+$tmtest -q 2>&1 | REPLACE "$dir" /tmp/DIR
 rm tmtest.conf t1.test t2.test
 
 

Modified: trunk/test/02-running/18-TestError.test
===================================================================
--- trunk/test/02-running/18-TestError.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/18-TestError.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # Sees what happens when we're in pedantic mode and there's an error
 # in the test file.
 
-tmtest $args -o - <<-EOL | sed -re "s/: line [0-9]+:/: line BLAH:/" | INDENT "  "
+$tmtest $args -o - <<-EOL | sed -re "s/: line [0-9]+:/: line BLAH:/" | INDENT "  "
 	set -e
 	iusedtobullseyewompratsinmypants
 	echo it ran

Modified: trunk/test/02-running/20-Atexit.test
===================================================================
--- trunk/test/02-running/20-Atexit.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/20-Atexit.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # Ensures that the atexit function does what it is supposed to.
 
 cd "$TESTDIR"
-tmtest $CFG -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo begin
 	ATEXIT echo 1
 	ATEXIT echo 2

Modified: trunk/test/02-running/21-QuoteFile.test
===================================================================
--- trunk/test/02-running/21-QuoteFile.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/21-QuoteFile.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -16,7 +16,7 @@
 	hi
 EOs
 
-tmtest $CFG -q | REPLACE "$dir" /tmp/DIR
+$tmtest -q | REPLACE "$dir" /tmp/DIR
 rm "vl'hurg.test" '12".test'
 
 

Modified: trunk/test/02-running/22-Signal.test
===================================================================
--- trunk/test/02-running/22-Signal.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/22-Signal.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -5,7 +5,7 @@
 # be expanded to be the pid of the parent, not the pid of the child process
 # that we want to kill!
 
-tmtest $CFG -q - <<'EOL'
+$tmtest -q - <<'EOL'
     kill -9 $$
 EOL
 

Modified: trunk/test/02-running/30-Mkfile.test
===================================================================
--- trunk/test/02-running/30-Mkfile.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/30-Mkfile.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -12,7 +12,7 @@
 # fill it with data (technically, the empty file was created by the
 # mktemp(1) call above)
 cd "$TESTDIR"
-tmtest $CFG -q - <<-EOL
+$tmtest -q - <<-EOL
 	MKFILE sfn '$fn' <<-EOS
 		FileContents
 	EOS

Modified: trunk/test/02-running/31-Mkfile.test
===================================================================
--- trunk/test/02-running/31-Mkfile.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/31-Mkfile.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 
 
 cd "$TESTDIR"
-tmtest $CFG -q - <<-EOL
+$tmtest -q - <<-EOL
 	MKFILE sfn <<-EOS
 		FileContents
 	EOS

Modified: trunk/test/02-running/32-Mkdir.test
===================================================================
--- trunk/test/02-running/32-Mkdir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/32-Mkdir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -12,7 +12,7 @@
 # fill it with data (technically, the empty file was created by the
 # mktemp(1) call above)
 cd "$TESTDIR"
-tmtest $CFG -q - <<-EOL
+$tmtest -q - <<-EOL
 	MKFILE sfn '$fn' <<-EOS
 		FileContents
 	EOS

Modified: trunk/test/02-running/33-Mkdir.test
===================================================================
--- trunk/test/02-running/33-Mkdir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/33-Mkdir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 dn=`mktemp -d -t`
 
 cd "$TESTDIR"
-tmtest $cfg -q - <<-EOL
+$tmtest $cfg -q - <<-EOL
 	MKDIR sdn '$dn'
 
 	echo start

Modified: trunk/test/02-running/34-Mkdir.test
===================================================================
--- trunk/test/02-running/34-Mkdir.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/34-Mkdir.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -6,7 +6,7 @@
 dn=`mktemp -d -t`
 
 cd "$TESTDIR"
-tmtest $cfg -q - <<-EOL
+$tmtest $cfg -q - <<-EOL
 
 	# normally we run tests in pedantic mode, where any single error
 	# will cause the test to bail and return a nonzero result code.

Modified: trunk/test/02-running/40-Replace.test
===================================================================
--- trunk/test/02-running/40-Replace.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/40-Replace.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # regular expression metachars are correctly interpreted as
 # regular characters.
 
-tmtest $CFG -o - <<'EOL' | INDENT
+$tmtest -o - <<'EOL' | INDENT
 	echo $'Abc  : '   $'abc'       | REPLACE abc def
 	echo $'A\'b  : '  $'a\'b'      | REPLACE $'a\'b' def
 	echo $'A\"b  : '  $'a\"b'      | REPLACE $'a\"b' def

Modified: trunk/test/02-running/41-Indent.test
===================================================================
--- trunk/test/02-running/41-Indent.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/41-Indent.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # Ensures that INDENT works.  Also tests that we can exec to a process
 # group to cause all further output from the script to be indented.
 
-tmtest $CFG -o - <<-EOL | INDENT "| "
+$tmtest -o - <<-EOL | INDENT "| "
 	# this technique doesn't work.  Fixes scheduled for 0.98 should
 	# fix it.  Put it into its own test when that happens.
 	# exec > >(INDENT)

Modified: trunk/test/02-running/50-OpenFDsTest.test
===================================================================
--- trunk/test/02-running/50-OpenFDsTest.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/50-OpenFDsTest.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # Ensure we don't leak fds to the running test.
 # Ideally, there would be NO open FDs.  This will be the case for tmtest 0.98.
 
-tmtest -o $CFG -q - <<-'EOL' | INDENT
+$tmtest -o -q - <<-'EOL' | INDENT
 	for i in `seq 3 255`; do
 		exec 2>/dev/null
 		echo -n >&$i && echo open: $i

Modified: trunk/test/02-running/51-OpenFDsConfig.tst
===================================================================
--- trunk/test/02-running/51-OpenFDsConfig.tst	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/51-OpenFDsConfig.tst	2006-03-07 23:24:44 UTC (rev 114)
@@ -25,7 +25,7 @@
 
 while [ -f /tmp/s ]; do sleep 1; done
 
-tmtest $args -o "$dd" | INDENT
+$tmtest $args -o "$dd" | INDENT
 
 
 STDOUT:

Modified: trunk/test/02-running/60-TestDash.test
===================================================================
--- trunk/test/02-running/60-TestDash.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/60-TestDash.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -11,7 +11,7 @@
 	Howdy pardner.
 EOL
 
-tmtest -q "$file" | REPLACE "$dir" /tmp/DIR
+$tmtest -q "$file" | REPLACE "$dir" /tmp/DIR
 
 
 STDOUT:

Modified: trunk/test/02-running/61-TestDash.test
===================================================================
--- trunk/test/02-running/61-TestDash.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/02-running/61-TestDash.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -11,7 +11,7 @@
 	Howdy pardner.
 EOL
 
-tmtest -q --ignore-extension "$file" | REPLACE "$dir" /tmp/DIR
+$tmtest -q --ignore-extension "$file" | REPLACE "$dir" /tmp/DIR
 
 
 STDOUT:

Modified: trunk/test/03-results/01-Ystderr.test
===================================================================
--- trunk/test/03-results/01-Ystderr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/01-Ystderr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,4 +1,4 @@
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy 1>&2
 	STDERR :
 	Howdy

Modified: trunk/test/03-results/01-YstderrOut.test
===================================================================
--- trunk/test/03-results/01-YstderrOut.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/01-YstderrOut.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,6 +1,6 @@
 # Ensures an empty STDOUT clause won't affect the test results.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy 1>&2
 	STDERR:
 	Howdy

Modified: trunk/test/03-results/01-Ystdout.test
===================================================================
--- trunk/test/03-results/01-Ystdout.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/01-Ystdout.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,4 +1,4 @@
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 	STDOUT :
 	Howdy

Modified: trunk/test/03-results/01-YstdoutOut.test
===================================================================
--- trunk/test/03-results/01-YstdoutOut.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/01-YstdoutOut.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,6 +1,6 @@
 # Ensures an empty stderr section won't affect the test results.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 	STDOUT :
 	Howdy

Modified: trunk/test/03-results/02-Nstderr.test
===================================================================
--- trunk/test/03-results/02-Nstderr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/02-Nstderr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # (Howdy vs. howdy).
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy 1>&2
 	STDERR:
 	howdy

Modified: trunk/test/03-results/02-Nstdout.test
===================================================================
--- trunk/test/03-results/02-Nstdout.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/02-Nstdout.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # (Howdy vs. howdy).
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 	STDOUT:
 	howdy

Modified: trunk/test/03-results/03-Nstderr.test
===================================================================
--- trunk/test/03-results/03-Nstderr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/03-Nstderr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # there's an extra space after the Howdy in the stderr.
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy 1>&2
 	STDERR:
 	Howdy 

Modified: trunk/test/03-results/03-Nstdout.test
===================================================================
--- trunk/test/03-results/03-Nstdout.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/03-Nstdout.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # there's an extra space after the Howdy in the stdout.
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 
 	STDOUT:

Modified: trunk/test/03-results/04-Nstderr.test
===================================================================
--- trunk/test/03-results/04-Nstderr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/04-Nstderr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # there's an extra newline in the expected stdout.
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy 1>&2
 	STDERR:
 	Howdy

Modified: trunk/test/03-results/04-Nstdout.test
===================================================================
--- trunk/test/03-results/04-Nstdout.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/04-Nstdout.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # there's an extra newline in the expected stdout.
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 
 	STDOUT:

Modified: trunk/test/03-results/09-NoNL.test
===================================================================
--- trunk/test/03-results/09-NoNL.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/09-NoNL.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -9,7 +9,7 @@
 # (back when we were parsing tests using re2c, lines needed to be
 # less than BUFSIZ and the results always had to end in a newline).
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo -n Howdy
 	STDOUT: -n
 	Howdy

Modified: trunk/test/03-results/09-NoNLStderr.test
===================================================================
--- trunk/test/03-results/09-NoNLStderr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/09-NoNLStderr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -9,7 +9,7 @@
 # less than BUFSIZ and the results always had to end in a newline).
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo -n Howdy 1>&2
 	STDERR: --no-trailing-newline
 	Howdy

Modified: trunk/test/03-results/10-NoNLErrFail.test
===================================================================
--- trunk/test/03-results/10-NoNLErrFail.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/10-NoNLErrFail.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -6,7 +6,7 @@
 #
 # Also see: 09-NoNL.test
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy 1>&2
 	STDERR: -n
 	Howdy

Modified: trunk/test/03-results/10-NoNLFFail.test
===================================================================
--- trunk/test/03-results/10-NoNLFFail.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/10-NoNLFFail.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # Howdy.  The test clearly only produces one.  However, because we
 # suppress one, the test succeeds.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 	STDOUT: -n
 	Howdy

Modified: trunk/test/03-results/10-NoNLFail.test
===================================================================
--- trunk/test/03-results/10-NoNLFail.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/10-NoNLFail.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -10,7 +10,7 @@
 # less than BUFSIZ and the results always had to end in a newline).
 
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 	STDOUT: -n
 	Howdy

Modified: trunk/test/03-results/11-NoNLOutput.test
===================================================================
--- trunk/test/03-results/11-NoNLOutput.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/11-NoNLOutput.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -9,7 +9,7 @@
 # (back when we were parsing tests using re2c, lines needed to be
 # less than BUFSIZ and the results always had to end in a newline).
 
-tmtest -o -q - <<-EOL | INDENT "   "
+$tmtest -o -q - <<-EOL | INDENT "   "
 	echo -n Howdy
 	STDOUT: -n
 	Howdy

Modified: trunk/test/03-results/11-NoNLOutput2.test
===================================================================
--- trunk/test/03-results/11-NoNLOutput2.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/11-NoNLOutput2.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -9,7 +9,7 @@
 # (back when we were parsing tests using re2c, lines needed to be
 # less than BUFSIZ and the results always had to end in a newline).
 
-tmtest -o -q - <<-EOL | INDENT "   "
+$tmtest -o -q - <<-EOL | INDENT "   "
 	echo -n Howdy
 	STDOUT: --no-trailing-newline
 	Howdy

Modified: trunk/test/03-results/12-NoNLTwice.test
===================================================================
--- trunk/test/03-results/12-NoNLTwice.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/12-NoNLTwice.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -11,7 +11,7 @@
 
 DISABLED
 
-head -c -1 <<-EOL | tmtest -d -q -
+head -c -1 <<-EOL | $tmtest -d -q -
     echo -n Howdy
     STDOUT:
     Howdy

Modified: trunk/test/03-results/13-MultiNL.test
===================================================================
--- trunk/test/03-results/13-MultiNL.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/13-MultiNL.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # test produces one newline, and the expected results end in two newlines,
 # one of the two newlines will match and the test will succeed.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 	STDOUT: -n
 	Howdy

Modified: trunk/test/03-results/13-MultiNL2.test
===================================================================
--- trunk/test/03-results/13-MultiNL2.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/13-MultiNL2.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # Since the test is only expecting a single newline, and only
 # one will be suppressed, this test will fail.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy
 	STDOUT: -n
 	Howdy

Modified: trunk/test/03-results/13-MultiNL2Err.test
===================================================================
--- trunk/test/03-results/13-MultiNL2Err.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/13-MultiNL2Err.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # Since the test is only expecting a single newline, and only
 # one will be suppressed, this test will fail.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy 1>&2
 	STDERR: -n
 	Howdy

Modified: trunk/test/03-results/13-MultiNLErr.test
===================================================================
--- trunk/test/03-results/13-MultiNLErr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/13-MultiNLErr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # test produces one newline, and the expected results end in two newlines,
 # one of the two newlines will match and the test will succeed.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy 1>&2
 	STDERR: -n
 	Howdy

Modified: trunk/test/03-results/14-NoNLWarn.test
===================================================================
--- trunk/test/03-results/14-NoNLWarn.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/14-NoNLWarn.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -8,7 +8,7 @@
 
 # See also 18-NoNLWarnOut.test and 04-diff/22-PatchNoNL2.test
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo -n Howdy
 	STDOUT:
 	Howdy

Modified: trunk/test/03-results/15-EmptyWithErr.test
===================================================================
--- trunk/test/03-results/15-EmptyWithErr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/15-EmptyWithErr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # A blank test with an empty stderr clause should succeed because
 # the stdout clause doesn't contain anything -- not even a newline.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	STDERR:
 EOL
 STDOUT:

Modified: trunk/test/03-results/15-EmptyWithOut.test
===================================================================
--- trunk/test/03-results/15-EmptyWithOut.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/15-EmptyWithOut.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,7 +1,7 @@
 # A blank test with an empty stdout clause should succeed because
 # the stdout clause doesn't contain anything -- not even a newline.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	STDOUT:
 EOL
 STDOUT:

Modified: trunk/test/03-results/16-EmptyWithErrNoNL.test
===================================================================
--- trunk/test/03-results/16-EmptyWithErrNoNL.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/16-EmptyWithErrNoNL.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # 15-BlankWithErr.test), so adding -n should not change the
 # results at all.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	STDERR: -n
 EOL
 STDOUT:

Modified: trunk/test/03-results/16-EmptyWithOutNoNL.test
===================================================================
--- trunk/test/03-results/16-EmptyWithOutNoNL.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/16-EmptyWithOutNoNL.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -2,7 +2,7 @@
 # 15-BlankWithOut.test), so adding -n should not change the
 # results at all.
 
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	STDOUT: -n
 EOL
 STDOUT:

Modified: trunk/test/03-results/17-NoStderr.test
===================================================================
--- trunk/test/03-results/17-NoStderr.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/17-NoStderr.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -1,4 +1,4 @@
-tmtest -q - <<-EOL
+$tmtest -q - <<-EOL
 	echo Howdy 1>&2
 	STDERR :
 	Howdy

Modified: trunk/test/03-results/18-NoNLWarnOut.test
===================================================================
--- trunk/test/03-results/18-NoNLWarnOut.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/18-NoNLWarnOut.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -8,7 +8,7 @@
 
 # See also 14-NoNLWarn.test and 04-diff/18-NeedNLWarn.test
 
-tmtest -o -q - <<-EOL | INDENT
+$tmtest -o -q - <<-EOL | INDENT
 	echo -n "right output"
 	echo -n "stderr text" 1>&2
 	STDOUT:

Modified: trunk/test/03-results/30-Binary.test
===================================================================
--- trunk/test/03-results/30-Binary.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/30-Binary.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -14,7 +14,7 @@
 echo -e "\\0\\0\\0\\0" >> "$tt"
 
 # and run the test
-tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
+$tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
 ok   /tmp/FILE 

Modified: trunk/test/03-results/31-BinaryFail.test
===================================================================
--- trunk/test/03-results/31-BinaryFail.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/31-BinaryFail.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -14,7 +14,7 @@
 echo -e "\\0\\0\\0" >> "$tt"
 
 # and run the test
-tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
+$tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
 FAIL /tmp/FILE        O..  stdout differed

Modified: trunk/test/03-results/32-BinaryLarge.test
===================================================================
--- trunk/test/03-results/32-BinaryLarge.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/32-BinaryLarge.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -25,7 +25,7 @@
 done >> "$tt"
 
 # and run the test
-tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
+$tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
 ok   /tmp/FILE 

Modified: trunk/test/03-results/33-BinaryHuge.test
===================================================================
--- trunk/test/03-results/33-BinaryHuge.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/03-results/33-BinaryHuge.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -19,7 +19,7 @@
 perl -e 'for(my $i=0; $i<256; $i++) { for(my $j=0; $j<256; $j++) { print pack("cc", $i, $j); }}; print "\n";' >> "$tt"
 
 # and run the test
-tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
+$tmtest --ignore-extension -q "$tt" | REPLACE "$tt" /tmp/FILE
 
 STDOUT:
 ok   /tmp/FILE 

Modified: trunk/test/04-diff/00-NoDiff.test
===================================================================
--- trunk/test/04-diff/00-NoDiff.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/00-NoDiff.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -6,7 +6,7 @@
 # no differences.
 
 
-tmtest -d - <<-EOL
+$tmtest -d - <<-EOL
 	echo "right output"
 	STDOUT:
 	right output

Modified: trunk/test/04-diff/01-Diff.test
===================================================================
--- trunk/test/04-diff/01-Diff.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/01-Diff.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -7,7 +7,7 @@
 # updated for 2.0 on 27 Jan 2005
 
 
-tmtest --diff - <<-EOL | FIX_DIFF
+$tmtest --diff - <<-EOL | FIX_DIFF
     echo "right output"
     STDOUT:
     wrong output

Modified: trunk/test/04-diff/02-MultiDiff.test
===================================================================
--- trunk/test/04-diff/02-MultiDiff.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/02-MultiDiff.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -18,7 +18,7 @@
 	test 2 wrong output
 EOF
 
-tmtest --ignore-extension -d "$t1" "$t2" | FIX_DIFF
+$tmtest --ignore-extension -d "$t1" "$t2" | FIX_DIFF
 
 
 STDOUT:

Modified: trunk/test/04-diff/05-AbortDiff.test
===================================================================
--- trunk/test/04-diff/05-AbortDiff.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/05-AbortDiff.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -5,7 +5,7 @@
 
 
 
-tmtest --diff - <<-EOL | FIX_DIFF
+$tmtest --diff - <<-EOL | FIX_DIFF
 	ABORT
 	echo "right output"
 	STDOUT:

Modified: trunk/test/04-diff/05-DisableDiff.test
===================================================================
--- trunk/test/04-diff/05-DisableDiff.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/05-DisableDiff.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -5,7 +5,7 @@
 
 
 
-tmtest -d - <<-EOL | FIX_DIFF
+$tmtest -d - <<-EOL | FIX_DIFF
 	DISABLED
 	echo "right output"
 	STDOUT:

Modified: trunk/test/04-diff/06-AbortDiff2.test
===================================================================
--- trunk/test/04-diff/06-AbortDiff2.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/06-AbortDiff2.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # Verifies what happens when a diff is aborted and gives a reason.
 
 
-tmtest -d - <<-EOL | FIX_DIFF
+$tmtest -d - <<-EOL | FIX_DIFF
 	ABORT: This is the reason
 	echo "right output"
 	STDOUT:

Modified: trunk/test/04-diff/06-DisableDiff2.test
===================================================================
--- trunk/test/04-diff/06-DisableDiff2.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/06-DisableDiff2.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -4,7 +4,7 @@
 # Verifies what happens when a diff is disabled and gives a reason.
 
 
-tmtest -d - <<-EOL | FIX_DIFF
+$tmtest -d - <<-EOL | FIX_DIFF
 	DISABLED: This is the reason
 	echo "right output"
 	STDOUT:

Modified: trunk/test/04-diff/07-AbortDiff3.test
===================================================================
--- trunk/test/04-diff/07-AbortDiff3.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/07-AbortDiff3.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -6,7 +6,7 @@
 
 
 
-tmtest -d - <<-EOL | FIX_DIFF
+$tmtest -d - <<-EOL | FIX_DIFF
 	ABORT This is the reason
 	echo "right output"
 	STDOUT:

Modified: trunk/test/04-diff/07-DisableDiff3.test
===================================================================
--- trunk/test/04-diff/07-DisableDiff3.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/07-DisableDiff3.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -6,7 +6,7 @@
 
 
 
-tmtest -d - <<-EOL | FIX_DIFF
+$tmtest -d - <<-EOL | FIX_DIFF
 	DISABLED This is the reason
 	echo "right output"
 	STDOUT:

Modified: trunk/test/04-diff/08-AbortDiff4.test
===================================================================
--- trunk/test/04-diff/08-AbortDiff4.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/08-AbortDiff4.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -8,7 +8,7 @@
 # printed after the "ERROR Test was aborted".  TODO.
 
 
-tmtest -d - <<-EOL | FIX_DIFF
+$tmtest -d - <<-EOL | FIX_DIFF
 	ABORT: "   "
 	echo "right output"
 	STDOUT:

Modified: trunk/test/04-diff/08-DisableDiff4.test
===================================================================
--- trunk/test/04-diff/08-DisableDiff4.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/08-DisableDiff4.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -8,7 +8,7 @@
 # printed after the "ERROR Test is disabled".  TODO.
 
 
-tmtest -d - <<-EOL | FIX_DIFF
+$tmtest -d - <<-EOL | FIX_DIFF
 	DISABLED: "   "
 	echo "right output"
 	STDOUT:

Modified: trunk/test/04-diff/09-MultiLevelDiff.test
===================================================================
--- trunk/test/04-diff/09-MultiLevelDiff.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/09-MultiLevelDiff.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -51,7 +51,7 @@
 EOL
 
 
-tmtest --ignore-extension -d | FIX_DIFF
+$tmtest --ignore-extension -d | FIX_DIFF
 
 rm -rf t.test one two
 

Modified: trunk/test/04-diff/10-Patch.test
===================================================================
--- trunk/test/04-diff/10-Patch.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/10-Patch.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -15,7 +15,7 @@
 # This is a little exotic...  Patch needs the CWD to be the directory
 # containing the file to patch.  "dirname $(tt.test)" gives that dir.
 
-tmtest --ignore-extension -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
+$tmtest --ignore-extension -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 echo
 INDENT "\t" < "$tt"

Modified: trunk/test/04-diff/11-MultiPatch.test
===================================================================
--- trunk/test/04-diff/11-MultiPatch.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/11-MultiPatch.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -26,7 +26,7 @@
 
 # All tt* files must be in the same directory.
 
-tmtest --ignore-extension -d "$tt1" "$tt2" "$tt3" | (cd `dirname "$tt1"` && patch | FIX_PATCH)
+$tmtest --ignore-extension -d "$tt1" "$tt2" "$tt3" | (cd `dirname "$tt1"` && patch | FIX_PATCH)
 echo
 INDENT "\t" < "$tt1"
 echo

Modified: trunk/test/04-diff/12-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/12-MultiLevelPatch.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/12-MultiLevelPatch.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -51,7 +51,7 @@
 EOL
 
 
-tmtest --ignore-extension -d | patch -p0 | FIX_PATCH
+$tmtest --ignore-extension -d | patch -p0 | FIX_PATCH
 echo
 INDENT "\t" < t.test
 echo

Modified: trunk/test/04-diff/13-MultiLevelPatch.test
===================================================================
--- trunk/test/04-diff/13-MultiLevelPatch.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/13-MultiLevelPatch.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -52,7 +52,7 @@
 
 cd two
 
-tmtest --ignore-extension -d .. | patch -p0 | FIX_PATCH
+$tmtest --ignore-extension -d .. | patch -p0 | FIX_PATCH
 echo
 INDENT "\t" < ../t.test
 echo

Modified: trunk/test/04-diff/17-ConfigError.test
===================================================================
--- trunk/test/04-diff/17-ConfigError.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/17-ConfigError.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -33,7 +33,7 @@
 	he
 EOs
 
-tmtest -d 2>&1 | REPLACE "$dir" /tmp/DIR | FIX_DIFF
+$tmtest -d 2>&1 | REPLACE "$dir" /tmp/DIR | FIX_DIFF
 rm tmtest.conf t1.test t2.test
 
 

Modified: trunk/test/04-diff/18-NeedNLWarn.test
===================================================================
--- trunk/test/04-diff/18-NeedNLWarn.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/18-NeedNLWarn.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -11,7 +11,7 @@
 # See also the corresponding test in 03-Running/18-NeedNLWarn.test
 
 
-tmtest --diff -q - <<-EOL | FIX_DIFF
+$tmtest --diff -q - <<-EOL | FIX_DIFF
 	echo -n "right output"
 	echo -n "stderr text" 1>&2
 	STDOUT:

Modified: trunk/test/04-diff/20-DiffNoNL.test
===================================================================
--- trunk/test/04-diff/20-DiffNoNL.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/20-DiffNoNL.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -12,7 +12,7 @@
 # buggy and you should probably update them.
 
 
-tmtest -d - <<-EOL | FIX_DIFF
+$tmtest -d - <<-EOL | FIX_DIFF
     echo -n "right output"
     STDOUT:
     right output

Modified: trunk/test/04-diff/21-PatchNoNL.test
===================================================================
--- trunk/test/04-diff/21-PatchNoNL.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/21-PatchNoNL.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -20,7 +20,7 @@
 # Ignore stderr because we want to ignore the warning that tmtest prints
 # about the sections not having matching trailing newlines.
 
-tmtest --ignore-extension -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
+$tmtest --ignore-extension -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 INDENT < "$tt"
 echo "<<DONE>>"

Modified: trunk/test/04-diff/22-PatchNoNL2.test
===================================================================
--- trunk/test/04-diff/22-PatchNoNL2.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/22-PatchNoNL2.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -27,7 +27,7 @@
 # Pipe STDERR to /dev/null because we want to ignore the warning that
 # tmtest prints (other tests ensure the warning works)
 
-tmtest --ignore-extension -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
+$tmtest --ignore-extension -d "$tt" 2>/dev/null | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 INDENT < "$tt"
 echo "<<DONE>>"

Modified: trunk/test/04-diff/23-PatchNoNL3.test
===================================================================
--- trunk/test/04-diff/23-PatchNoNL3.test	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/test/04-diff/23-PatchNoNL3.test	2006-03-07 23:24:44 UTC (rev 114)
@@ -21,7 +21,7 @@
 # This is a little exotic...  Patch needs the CWD to be the directory
 # containing the file to patch.  "dirname $(tt.test)" gives that dir.
 
-tmtest --ignore-extension -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
+$tmtest --ignore-extension -d "$tt" | (cd `dirname "$tt"` && patch | FIX_PATCH)
 echo "And the patched file:"
 INDENT < "$tt"
 echo "<<DONE>>"

Modified: trunk/tmtest.conf
===================================================================
--- trunk/tmtest.conf	2006-03-07 22:41:14 UTC (rev 113)
+++ trunk/tmtest.conf	2006-03-07 23:24:44 UTC (rev 114)
@@ -33,37 +33,27 @@
 set -e
 
 
+# Every test executes tmtest vi the $tmtest variable so that we can
+# force which binary gets run.  We also provide $tmtest_file to tell
+# the file that contains the executable since $tmtest itself may end
+# up looking like "valgrind tmtest --config..."
+# TODO: split --config into $config so it's more obvious that some
+# shenanigans are going on here?  Then each test would start with
+# "$tmtest $config..."
 
-# Add the current directory at the front of the PATH environment variable.
-# This means that while the test is running, any executables in this
-# directory will take priority over similarly-named executables anywhere
-# else (like /usr/bin or ~/bin).  This ensures that we lauch the unstable
-# copy of tmtest to handle each subtest.
+tmtest_file="$MYDIR/tmtest"
+tmtest="$tmtest_file --config=$MYDIR/test/tmtest.sub.conf"
 
-PATH="$MYDIR:$PATH"
 
+# Including tmlib here allows us to run the tests without installing
+# tmtest first.  Make sure we don't include the potentially buggy
+# development tmlib if the globally-installed tmlib has already
+# defined the functions (type MKDIR sees if the MKDIR function
+# exists).
 
-# All testfiles include $args in the arguments to the subexec.
-# (if they don't, it's a bug in the test).
-#
-# This allows us to specify default commands for all tests being run.
-# For instance, forcing the config file ensures that no config files
-# outside the test directory will be read.  This way we can be sure
-# that the tests are not succeeding due to some local configuration;
-# their environment is as clean as we can possibly make it.
+type MKDIR > /dev/null 2>&1 || . "$MYDIR/tmlib.sh"
 
-args="--config=$MYDIR/test/tmtest.sub.conf"
 
-
-# This allows us to run tests without installing tmtest first.
-# This is generally a good thing but it will cause problems if
-# this tmlib has problems...  Maybe we should check to see if
-# a particular function has been defined and include tmlib only
-# if it hasn't.
-
-. "$MYDIR/tmlib.sh"
-
-
 # We set OUTER_CONFIG_FILE so that we can check later that this file
 # has or has not been read.  We need to ensure that subtests have NOT
 # read this file (we need to restrict the config files that they read





From tmtest-commits at berlios.de  Wed Mar  8 23:03:37 2006
From: tmtest-commits at berlios.de (tmtest-commits at berlios.de)
Date: Wed, 8 Mar 2006 23:03:37 +0100
Subject: [Tmtest-commits] [115] trunk: Get rid of CuTest, and zutest.
Message-ID: <200603082203.k28M3bcb003956@sheep.berlios.de>

Revision: 115
Author:   bronson
Date:     2006-03-08 23:03:36 +0100 (Wed, 08 Mar 2006)

Log Message:
-----------
Get rid of CuTest, and zutest.  Much simpler, and better diagnostics too!

Modified Paths:
--------------
    trunk/CHANGES
    trunk/Makefile
    trunk/TODO
    trunk/compare.c
    trunk/main.c

Added Paths:
-----------
    trunk/units.c
    trunk/units.h
    trunk/zutest-tests.c
    trunk/zutest.c
    trunk/zutest.h

Removed Paths:
-------------
    trunk/cutest.c
    trunk/cutest.h
Modified: trunk/CHANGES
===================================================================
--- trunk/CHANGES	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/CHANGES	2006-03-08 22:03:36 UTC (rev 115)
@@ -1,3 +1,4 @@
+- Got rid of Cutest since it was very non-cute.  Wrote zutest instead.
 - Changed --all-files to be the much more understandable --ignore-extension.
 - If an output section is marked -n but ends with multiple newlines, we print
   a warning and fail it automatically.  We used to let this nonsense pass.

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/Makefile	2006-03-08 22:03:36 UTC (rev 115)
@@ -40,8 +40,8 @@
 CSRC+=vars.c test.c compare.c rusage.c tfscan.c stscan.o main.c template.c
 CHDR+=vars.h test.h compare.h rusage.h tfscan.h stscan.h
 # unit test files
-CSRC+=cutest.c
-CHDR+=cutest.h
+CSRC+=units.c zutest.c
+CHDR+=units.h zutest.h
 
 # It makes it rather hard to debug when Make deletes the intermediate files.
 INTERMED=stscan.c
@@ -62,8 +62,12 @@
 
 .PHONY: test
 test: tmtest
-	./tmtest --run-tests
+	./tmtest --run-unit-tests
+	tmtest test
 
+unit: tmtest
+	./tmtest --run-unit-tests
+
 install: tmtest
 	install -d -m755 $(bindir)
 	install tmtest $(bindir)
@@ -93,7 +97,7 @@
 endif
 
 clean:
-	rm -f tmtest template.c tags
+	rm -f tmtest template.c tags zutest
 
 distclean: clean
 	rm -f stscan.[co]
@@ -117,3 +121,6 @@
 	
 reupdate:
 	ls re2c/*.[ch] | (ODIR=`pwd`; cd ../oe; xargs cp --target-directory $$ODIR/re2c)
+
+zutest: zutest.c zutest-tests.c zutest.h
+	gcc -Wall -Werror -g zutest.c zutest-tests.c -o zutest

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/TODO	2006-03-08 22:03:36 UTC (rev 115)
@@ -1,5 +1,5 @@
 0.96:
-- Rewrite the goddamn unit testing.
+- Write unit tests for path normalization.
 - Make tmtest only execute config files owned by either the user or root.
   Print a big fat warning when the config file is skipped.  This prevents
   a malicious user from putting a config file in /tmp and having it
@@ -11,12 +11,16 @@
   That's probably the most agreeable.
   We will not read either config or test files from a world-writable directory.
   Ever.
+  	If you are below a world-writable directory, then we only execute
+	config files owned by you.  If not, we execute them as normal.
 - Add --diff and --shell to change the executables that get launched.
   No, that clutters the arguments up.  Take them from $DIFF and $SHELL.
   No, obviously that's a bad idea.  That prevents people using tcsh
   from running tmtest.  It *has* to be --shell.  $DIFF is fine.
   And we need to make sure that we ignore the SHELL envar.
   	(write a test for this)
+	OK, I think it should be TM_DIFF and TM_SHELL.  Easy enough.
+	The trick will be writing the tests.
 - Add the ability to specify test arguments on the command line.
   I'm picturing something where VAR=val on the command line would be
   inserted without change into the template.  That way you can use the
@@ -37,22 +41,12 @@
   should get rid of a whole bunch in main.c as well.
   this should prevent us from dropping turds in /tmp all the time too.
 - Ensure it compiles and runs on freebsd.
-- Add some unit tests.  http://kooditakomo.cs.tut.fi/projects/gunit/
-  http://pvanhoof.be/blog/index.php/2006/03/03/tinymail-unit-testing-and-creating-messages     Actually, this looks better: http://cutest.sourceforge.net/
-  Potential units: curdir, path normalization
-    Need to rewrite curdir before it's worth unit testing it.
-	Path normalization definitely deserves it.
 - Get rid of -g, add -O2.  Make it easy to set these for compilation.
   Yes, have dev and prod modes.  dev would be -O0 and -g and include
   unit tests.  Prod is -O2, stripped, and no unit tests (unless the
   unit tests only add 12K or so, where might as well just leave em).
 - If there were failures, should highlight that in the test summary.
 	"%d FAILURES" or somesuch.
-- Well, piping the result of a command to a function destroys the the
-  exit code.  I don't know of any good way around this!  Maybe this
-  is a good argument to have rewriting performed by tmtest itself...
-  I think it is.  So, we can add, "STDOUT: --pipe 'sed -e /.../'"
-  or something.  I don't like that.  Ick. it all sucks.
 
 0.98:
 - Change the I/O scheme to be event based.  Get rid of the tempfiles.
@@ -71,6 +65,11 @@
   - When done, verify that netknife's tests that freeze with -d now pass.
 - Is there any way to record memory and swap usage for each test?
   sure, it's in the rusage. prolly add a "tmtest -v" to print it for each test.
+- Well, piping the result of a command to a function destroys the the
+  exit code.  I don't know of any good way around this!  Maybe this
+  is a good argument to have rewriting performed by tmtest itself...
+  I think it is.  So, we can add, "STDOUT: --pipe 'sed -e /.../'"
+  or something.  I don't like that.  Ick. it all sucks.
 - stdin is all buggered up.  why is it that "cat" with no args will print
   the rest of the test script?  And why is it that if you fork, diff freezes?
   They're related problems I suspect.

Modified: trunk/compare.c
===================================================================
--- trunk/compare.c	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/compare.c	2006-03-08 22:03:36 UTC (rev 115)
@@ -188,12 +188,12 @@
 }
 
 
-#include "cutest.h"
+#include "zutest.h"
 #include "re2c/read-mem.h"
 #include "re2c/read-rand.h"
 #include <stdlib.h>
 
-static void test_empty(cutest *ct)
+static void test_empty()
 {
 	scanstate ssrec, *ss=&ssrec;
 
@@ -208,7 +208,7 @@
 }
 
 
-static void test_standard(cutest *ct)
+static void test_standard()
 {
 	scanstate ssrec, *ss=&ssrec;
 
@@ -220,7 +220,7 @@
 }
 
 
-static void test_large(cutest *ct)
+static void test_large()
 {
 	char buf[BUFSIZ];
 	scanstate ssrec, *ss=&ssrec;
@@ -257,7 +257,7 @@
 }
 
 
-static void test_newlines(cutest *ct)
+static void test_newlines()
 {
 	AssertEq(check_newlines("Unix\n",   "Unix\n"  ), cmp_full_match);
 	AssertEq(check_newlines("Unix",     "Unix\n"  ), cmp_ptr_has_extra_nl);
@@ -274,7 +274,7 @@
 	AssertEq(check_newlines("",     "\n\n" ), cmp_no_match);
 }
 
-static void test_inc(cutest *ct)
+static void test_inc()
 {
 	// Tries to ensure that packetization won't mess us up.
 
@@ -296,7 +296,7 @@
 }
 
 
-static void test_inc_newlines(cutest *ct)
+static void test_inc_newlines()
 {
 	// Tries to ensure packetization won't mess up the newline checking.
 
@@ -335,18 +335,13 @@
 }
 */
 
+zutest_proc compare_tests[] = {
+	test_empty,
+	test_standard,
+	test_large,
+	test_newlines,
+	test_inc,
+	test_inc_newlines,
+	NULL
+};
 
-cusuite* compare_suite()
-{
-	cusuite* suite = CuSuiteNew();
-
-	suite_add(suite, test_empty);
-	suite_add(suite, test_standard);
-	suite_add(suite, test_large);
-	suite_add(suite, test_newlines);
-	suite_add(suite, test_inc);
-	suite_add(suite, test_inc_newlines);
-
-	return suite;
-}
-

Deleted: trunk/cutest.c
===================================================================
--- trunk/cutest.c	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/cutest.c	2006-03-08 22:03:36 UTC (rev 115)
@@ -1,353 +0,0 @@
-/* 	http://cutest.sf.net
-
-NOTE
-
-The license is based on the zlib/libpng license. For more details see
-http://www.opensource.org/licenses/zlib-license.html. The intent of the
-license is to: 
-
-- keep the license as simple as possible
-- encourage the use of CuTest in both free and commercial applications
-  and libraries
-- keep the source code together 
-- give credit to the CuTest contributors for their work
-
-If you ship CuTest in source form with your source distribution, the
-following license document must be included with it in unaltered form.
-If you find CuTest useful we would like to hear about it. 
-
-LICENSE
-
-Copyright (c) 2003 Asim Jalis
-
-This software is provided 'as-is', without any express or implied
-warranty. In no event will the authors be held liable for any damages
-arising from the use of this software.
-
-Permission is granted to anyone to use this software for any purpose,
-including commercial applications, and to alter it and redistribute it
-freely, subject to the following restrictions:
-
-1. The origin of this software must not be misrepresented; you must not
-claim that you wrote the original software. If you use this software in
-a product, an acknowledgment in the product documentation would be
-appreciated but is not required.
-
-2. Altered source versions must be plainly marked as such, and must not
-be misrepresented as being the original software.
-
-3. This notice may not be removed or altered from any source
-distribution.
-
-*/
-
-
-#include <assert.h>
-#include <setjmp.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-
-#include "cutest.h"
-
-/*-------------------------------------------------------------------------*
- * CuStr
- *-------------------------------------------------------------------------*/
-
-char* CuStrAlloc(int size)
-{
-	char* newStr = (char*) malloc( sizeof(char) * (size) );
-	return newStr;
-}
-
-char* CuStrCopy(const char* old)
-{
-	int len = strlen(old);
-	char* newStr = CuStrAlloc(len + 1);
-	strcpy(newStr, old);
-	return newStr;
-}
-
-/*-------------------------------------------------------------------------*
- * CuString
- *-------------------------------------------------------------------------*/
-
-void CuStringInit(CuString* str)
-{
-	str->length = 0;
-	str->size = STRING_MAX;
-	str->buffer = (char*) malloc(sizeof(char) * str->size);
-	str->buffer[0] = '\0';
-}
-
-CuString* CuStringNew(void)
-{
-	CuString* str = (CuString*) malloc(sizeof(CuString));
-	str->length = 0;
-	str->size = STRING_MAX;
-	str->buffer = (char*) malloc(sizeof(char) * str->size);
-	str->buffer[0] = '\0';
-	return str;
-}
-
-void CuStringResize(CuString* str, int newSize)
-{
-	str->buffer = (char*) realloc(str->buffer, sizeof(char) * newSize);
-	str->size = newSize;
-}
-
-void CuStringAppend(CuString* str, const char* text)
-{
-	int length;
-
-	if (text == NULL) {
-		text = "NULL";
-	}
-
-	length = strlen(text);
-	if (str->length + length + 1 >= str->size)
-		CuStringResize(str, str->length + length + 1 + STRING_INC);
-	str->length += length;
-	strcat(str->buffer, text);
-}
-
-void CuStringAppendChar(CuString* str, char ch)
-{
-	char text[2];
-	text[0] = ch;
-	text[1] = '\0';
-	CuStringAppend(str, text);
-}
-
-void CuStringAppendFormat(CuString* str, const char* format, ...)
-{
-	va_list argp;
-	char buf[HUGE_STRING_LEN];
-	va_start(argp, format);
-	vsprintf(buf, format, argp);
-	va_end(argp);
-	CuStringAppend(str, buf);
-}
-
-void CuStringInsert(CuString* str, const char* text, int pos)
-{
-	int length = strlen(text);
-	if (pos > str->length)
-		pos = str->length;
-	if (str->length + length + 1 >= str->size)
-		CuStringResize(str, str->length + length + 1 + STRING_INC);
-	memmove(str->buffer + pos + length, str->buffer + pos, (str->length - pos) + 1);
-	str->length += length;
-	memcpy(str->buffer + pos, text, length);
-}
-
-/*-------------------------------------------------------------------------*
- * CuTest
- *-------------------------------------------------------------------------*/
-
-void CuTestInit(CuTest* t, const char* name, TestFunction function)
-{
-	t->name = CuStrCopy(name);
-	t->failed = 0;
-	t->ran = 0;
-	t->message = NULL;
-	t->function = function;
-	t->jumpBuf = NULL;
-}
-
-CuTest* CuTestNew(const char* name, TestFunction function)
-{
-	CuTest* tc = CU_ALLOC(CuTest);
-	CuTestInit(tc, name, function);
-	return tc;
-}
-
-void CuTestRun(CuTest* tc)
-{
-	jmp_buf buf;
-	tc->jumpBuf = &buf;
-	if (setjmp(buf) == 0)
-	{
-		tc->ran = 1;
-		(tc->function)(tc);
-	}
-	tc->jumpBuf = 0;
-}
-
-static void CuFailInternal(CuTest* tc, const char* file, int line, CuString* string)
-{
-	char buf[HUGE_STRING_LEN];
-
-	sprintf(buf, "%s:%d: ", file, line);
-	CuStringInsert(string, buf, 0);
-
-	tc->failed = 1;
-	tc->message = string->buffer;
-	if (tc->jumpBuf != 0) longjmp(*(tc->jumpBuf), 0);
-}
-
-void CuFail_Line(CuTest* tc, const char* file, int line, const char* message2, const char* message)
-{
-	CuString string;
-
-	CuStringInit(&string);
-	if (message2 != NULL) 
-	{
-		CuStringAppend(&string, message2);
-		CuStringAppend(&string, ": ");
-	}
-	CuStringAppend(&string, message);
-	CuFailInternal(tc, file, line, &string);
-}
-
-void CuAssert_Line(CuTest* tc, const char* file, int line, const char* message, int condition)
-{
-	if (condition) return;
-	CuFail_Line(tc, file, line, NULL, message);
-}
-
-void CuAssertStrEquals_LineMsg(CuTest* tc, const char* file, int line, const char* message, 
-	const char* expected, const char* actual)
-{
-	CuString string;
-	if ((expected == NULL && actual == NULL) ||
-	    (expected != NULL && actual != NULL &&
-	     strcmp(expected, actual) == 0))
-	{
-		return;
-	}
-
-	CuStringInit(&string);
-	if (message != NULL) 
-	{
-		CuStringAppend(&string, message);
-		CuStringAppend(&string, ": ");
-	}
-	CuStringAppend(&string, "expected <");
-	CuStringAppend(&string, expected);
-	CuStringAppend(&string, "> but was <");
-	CuStringAppend(&string, actual);
-	CuStringAppend(&string, ">");
-	CuFailInternal(tc, file, line, &string);
-}
-
-void CuAssertIntEquals_LineMsg(CuTest* tc, const char* file, int line, const char* message, 
-	int expected, int actual)
-{
-	char buf[STRING_MAX];
-	if (expected == actual) return;
-	sprintf(buf, "expected <%d> but was <%d>", expected, actual);
-	CuFail_Line(tc, file, line, message, buf);
-}
-
-void CuAssertDblEquals_LineMsg(CuTest* tc, const char* file, int line, const char* message, 
-	double expected, double actual, double delta)
-{
-	char buf[STRING_MAX];
-	if (fabs(expected - actual) <= delta) return;
-	sprintf(buf, "expected <%lf> but was <%lf>", expected, actual);
-	CuFail_Line(tc, file, line, message, buf);
-}
-
-void CuAssertPtrEquals_LineMsg(CuTest* tc, const char* file, int line, const char* message, 
-	void* expected, void* actual)
-{
-	char buf[STRING_MAX];
-	if (expected == actual) return;
-	sprintf(buf, "expected pointer <0x%p> but was <0x%p>", expected, actual);
-	CuFail_Line(tc, file, line, message, buf);
-}
-
-
-/*-------------------------------------------------------------------------*
- * CuSuite
- *-------------------------------------------------------------------------*/
-
-void CuSuiteInit(CuSuite* testSuite)
-{
-	testSuite->count = 0;
-	testSuite->failCount = 0;
-}
-
-CuSuite* CuSuiteNew(void)
-{
-	CuSuite* testSuite = CU_ALLOC(CuSuite);
-	CuSuiteInit(testSuite);
-	return testSuite;
-}
-
-void CuSuiteAdd(CuSuite* testSuite, CuTest *testCase)
-{
-	assert(testSuite->count < MAX_TEST_CASES);
-	testSuite->list[testSuite->count] = testCase;
-	testSuite->count++;
-}
-
-void CuSuiteAddSuite(CuSuite* testSuite, CuSuite* testSuite2)
-{
-	int i;
-	for (i = 0 ; i < testSuite2->count ; ++i)
-	{
-		CuTest* testCase = testSuite2->list[i];
-		CuSuiteAdd(testSuite, testCase);
-	}
-}
-
-void CuSuiteRun(CuSuite* testSuite)
-{
-	int i;
-	for (i = 0 ; i < testSuite->count ; ++i)
-	{
-		CuTest* testCase = testSuite->list[i];
-		CuTestRun(testCase);
-		if (testCase->failed) { testSuite->failCount += 1; }
-	}
-}
-
-void CuSuiteSummary(CuSuite* testSuite, CuString* summary)
-{
-	int i;
-	for (i = 0 ; i < testSuite->count ; ++i)
-	{
-		CuTest* testCase = testSuite->list[i];
-		CuStringAppend(summary, testCase->failed ? "F" : ".");
-	}
-	CuStringAppend(summary, "\n\n");
-}
-
-void CuSuiteDetails(CuSuite* testSuite, CuString* details)
-{
-	int i;
-	int failCount = 0;
-
-	if (testSuite->failCount == 0)
-	{
-		int passCount = testSuite->count - testSuite->failCount;
-		const char* testWord = passCount == 1 ? "test" : "tests";
-		CuStringAppendFormat(details, "OK (%d %s)\n", passCount, testWord);
-	}
-	else
-	{
-		if (testSuite->failCount == 1)
-			CuStringAppend(details, "There was 1 failure:\n");
-		else
-			CuStringAppendFormat(details, "There were %d failures:\n", testSuite->failCount);
-
-		for (i = 0 ; i < testSuite->count ; ++i)
-		{
-			CuTest* testCase = testSuite->list[i];
-			if (testCase->failed)
-			{
-				failCount++;
-				CuStringAppendFormat(details, "%d) %s: %s\n",
-					failCount, testCase->name, testCase->message);
-			}
-		}
-		CuStringAppend(details, "\n!!!FAILURES!!!\n");
-
-		CuStringAppendFormat(details, "Runs: %d ",   testSuite->count);
-		CuStringAppendFormat(details, "Passes: %d ", testSuite->count - testSuite->failCount);
-		CuStringAppendFormat(details, "Fails: %d\n",  testSuite->failCount);
-	}
-}

Deleted: trunk/cutest.h
===================================================================
--- trunk/cutest.h	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/cutest.h	2006-03-08 22:03:36 UTC (rev 115)
@@ -1,124 +0,0 @@
-#ifndef CU_TEST_H
-#define CU_TEST_H
-
-#include <setjmp.h>
-#include <stdarg.h>
-
-/* CuString */
-
-char* CuStrAlloc(int size);
-char* CuStrCopy(const char* old);
-
-#define CU_ALLOC(TYPE)		((TYPE*) malloc(sizeof(TYPE)))
-
-#define HUGE_STRING_LEN	8192
-#define STRING_MAX		256
-#define STRING_INC		256
-
-typedef struct
-{
-	int length;
-	int size;
-	char* buffer;
-} CuString;
-
-void CuStringInit(CuString* str);
-CuString* CuStringNew(void);
-void CuStringRead(CuString* str, const char* path);
-void CuStringAppend(CuString* str, const char* text);
-void CuStringAppendChar(CuString* str, char ch);
-void CuStringAppendFormat(CuString* str, const char* format, ...);
-void CuStringInsert(CuString* str, const char* text, int pos);
-void CuStringResize(CuString* str, int newSize);
-
-/* CuTest */
-
-typedef struct CuTest CuTest;
-
-typedef void (*TestFunction)(CuTest *);
-
-struct CuTest
-{
-	const char* name;
-	TestFunction function;
-	int failed;
-	int ran;
-	const char* message;
-	jmp_buf *jumpBuf;
-};
-
-void CuTestInit(CuTest* t, const char* name, TestFunction function);
-CuTest* CuTestNew(const char* name, TestFunction function);
-void CuTestRun(CuTest* tc);
-
-/* Internal versions of assert functions -- use the public versions */
-void CuFail_Line(CuTest* tc, const char* file, int line, const char* message2, const char* message);
-void CuAssert_Line(CuTest* tc, const char* file, int line, const char* message, int condition);
-void CuAssertStrEquals_LineMsg(CuTest* tc, 
-	const char* file, int line, const char* message, 
-	const char* expected, const char* actual);
-void CuAssertIntEquals_LineMsg(CuTest* tc, 
-	const char* file, int line, const char* message, 
-	int expected, int actual);
-void CuAssertDblEquals_LineMsg(CuTest* tc, 
-	const char* file, int line, const char* message, 
-	double expected, double actual, double delta);
-void CuAssertPtrEquals_LineMsg(CuTest* tc, 
-	const char* file, int line, const char* message, 
-	void* expected, void* actual);
-
-/* public assert functions */
-
-#define CuFail(tc, ms)                        CuFail_Line(  (tc), __FILE__, __LINE__, NULL, (ms))
-#define CuAssert(tc, ms, cond)                CuAssert_Line((tc), __FILE__, __LINE__, (ms), (cond))
-#define CuAssertTrue(tc, cond)                CuAssert_Line((tc), __FILE__, __LINE__, "assert failed", (cond))
-
-#define CuAssertStrEquals(tc,ex,ac)           CuAssertStrEquals_LineMsg((tc),__FILE__,__LINE__,NULL,(ex),(ac))
-#define CuAssertStrEquals_Msg(tc,ms,ex,ac)    CuAssertStrEquals_LineMsg((tc),__FILE__,__LINE__,(ms),(ex),(ac))
-#define CuAssertIntEquals(tc,ex,ac)           CuAssertIntEquals_LineMsg((tc),__FILE__,__LINE__,NULL,(ex),(ac))
-#define CuAssertIntEquals_Msg(tc,ms,ex,ac)    CuAssertIntEquals_LineMsg((tc),__FILE__,__LINE__,(ms),(ex),(ac))
-#define CuAssertDblEquals(tc,ex,ac,dl)        CuAssertDblEquals_LineMsg((tc),__FILE__,__LINE__,NULL,(ex),(ac),(dl))
-#define CuAssertDblEquals_Msg(tc,ms,ex,ac,dl) CuAssertDblEquals_LineMsg((tc),__FILE__,__LINE__,(ms),(ex),(ac),(dl))
-#define CuAssertPtrEquals(tc,ex,ac)           CuAssertPtrEquals_LineMsg((tc),__FILE__,__LINE__,NULL,(ex),(ac))
-#define CuAssertPtrEquals_Msg(tc,ms,ex,ac)    CuAssertPtrEquals_LineMsg((tc),__FILE__,__LINE__,(ms),(ex),(ac))
-
-#define CuAssertPtrNotNull(tc,p)        CuAssert_Line((tc),__FILE__,__LINE__,"null pointer unexpected",(p != NULL))
-#define CuAssertPtrNotNullMsg(tc,msg,p) CuAssert_Line((tc),__FILE__,__LINE__,(msg),(p != NULL))
-
-/* CuSuite */
-
-#define MAX_TEST_CASES	1024
-
-#define SUITE_ADD_TEST(SUITE,TEST)	CuSuiteAdd(SUITE, CuTestNew(#TEST, TEST))
-
-typedef struct
-{
-	int count;
-	CuTest* list[MAX_TEST_CASES];
-	int failCount;
-
-} CuSuite;
-
-
-void CuSuiteInit(CuSuite* testSuite);
-CuSuite* CuSuiteNew(void);
-void CuSuiteAdd(CuSuite* testSuite, CuTest *testCase);
-void CuSuiteAddSuite(CuSuite* testSuite, CuSuite* testSuite2);
-void CuSuiteRun(CuSuite* testSuite);
-void CuSuiteSummary(CuSuite* testSuite, CuString* summary);
-void CuSuiteDetails(CuSuite* testSuite, CuString* details);
-
-
-#define cusuite CuSuite
-#define cutest CuTest
-#define suite_add(s,t) SUITE_ADD_TEST(s,t)
-#define Assert(cond) CuAssert(ct, #cond, cond)
-
-#define AssertEq(c1,c2) Assert(c1 == c2)
-#define AssertNe(c1,c2) Assert(c1 != c2)
-#define AssertGt(c1,c2) Assert(c1 > c2)
-#define AssertGe(c1,c2) Assert(c1 >= c2)
-#define AssertLt(c1,c2) Assert(c1 < c2)
-#define AssertLe(c1,c2) Assert(c1 <= c2)
-
-#endif /* CU_TEST_H */

Modified: trunk/main.c
===================================================================
--- trunk/main.c	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/main.c	2006-03-08 22:03:36 UTC (rev 115)
@@ -32,6 +32,7 @@
 #include "vars.h"
 #include "tfscan.h"
 #include "pathconv.h"
+#include "units.h"
 
 
 #define DIFFPROG "/usr/bin/diff"
@@ -48,7 +49,6 @@
 int allfiles = 0;
 int dumpscript = 0;
 int quiet = 0;
-int run_unit_tests = 0;
 const char *orig_cwd;		// tmtest runs with the cwd pointed to /tmp
 char *config_file;	// absolute path to the user-specified config file
 					// null if user didn't specify a config file.
@@ -1020,7 +1020,7 @@
 		{"help", 0, 0, 'h'},
 		{"output", 0, 0, 'o'},
 		{"quiet", 0, 0, 'q'},
-		{"run-tests", 0, 0, 'U'},
+		{"run-unit-tests", 0, 0, 'U'},
 		{"version", 0, 0, 'V'},
 		{0, 0, 0, 0},
 	};
@@ -1062,10 +1062,6 @@
 				quiet++;
 				break;
 
-			case 'U':
-				run_unit_tests++;
-				break;
-
 			case 'V':
 				printf("tmtest version %s\n", stringify(VERSION));
 				exit(0);
@@ -1183,35 +1179,13 @@
 }
 
 
-#include "cutest.h"
-
-static int cumain(int argc, char **argv)
-{
-	extern cusuite* compare_suite();
-
-	CuString *output = CuStringNew();
-
-	CuSuite *suite = CuSuiteNew();
-	CuSuiteAddSuite(suite, compare_suite());
-
-	CuSuiteRun(suite);
-	CuSuiteSummary(suite, output);
-	CuSuiteDetails(suite, output);
-	printf("%s\n", output->buffer);
-
-	return 0;
-}
-
-
 int main(int argc, char **argv)
 {
+	unit_test_check(argc, argv, all_unit_tests);
+
 	orig_cwd = dup_cwd();
 	process_args(argc, argv);
 
-	if(run_unit_tests) {
-		return cumain(argc, argv);
-	}
-
     start_tests();
     if(optind < argc) {
 		process_argv(argv+optind);

Added: trunk/units.c
===================================================================
--- trunk/units.c	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/units.c	2006-03-08 22:03:36 UTC (rev 115)
@@ -0,0 +1,10 @@
+#include "units.h"
+#include "compare.h"
+#include <stddef.h>
+
+
+zutest_suite all_unit_tests[] = {
+	compare_tests,
+	NULL
+};
+

Added: trunk/units.h
===================================================================
--- trunk/units.h	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/units.h	2006-03-08 22:03:36 UTC (rev 115)
@@ -0,0 +1,6 @@
+#include "zutest.h"
+
+extern zutest_proc compare_tests[];
+
+extern zutest_suite all_unit_tests[];
+

Added: trunk/zutest-tests.c
===================================================================
--- trunk/zutest-tests.c	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/zutest-tests.c	2006-03-08 22:03:36 UTC (rev 115)
@@ -0,0 +1,242 @@
+/* zutest.c
+ * Scott Bronson
+ * 6 Mar 2006
+ *
+ * Runs a bunch of unit tests.  Ensures each macro expands without error
+ * and passes a simple test.  Does not test each macro for all failure
+ * modes because that would be a hell of a lot of code.
+ *
+ * A certain number of tests are expected to fail.  If the name of a
+ * failing test does not end in "_fail" then it is NOT expected to fail.
+ */
+
+#include "zutest.h"
+#include <string.h>
+
+
+void test_fail()
+{
+	Fail("Gone!");
+	Fail("Won't be printed");
+}
+
+
+void test_assert_int()
+{
+	int a=4, b=3, c=4;
+
+	// These should all pass
+	AssertEq(a,c);
+	AssertNe(a,b);
+	AssertGt(a,b);
+	AssertGe(a,b);
+	AssertGe(a,c);
+	AssertLt(b,a);
+	AssertLe(b,a);
+	AssertLe(c,a);
+	AssertIntEq(a,c);
+	AssertIntNe(a,b);
+	AssertIntGt(a,b);
+	AssertIntGe(a,b);
+	AssertIntGe(a,c);
+	AssertIntLt(b,a);
+	AssertIntLe(b,a);
+	AssertIntLe(c,a);
+	AssertEqHex(a,c);
+	AssertNeHex(a,b);
+	AssertGtHex(a,b);
+	AssertGeHex(a,b);
+	AssertGeHex(a,c);
+	AssertLtHex(b,a);
+	AssertLeHex(b,a);
+	AssertLeHex(c,a);
+}
+
+void test_assert_int_eq_fail()
+{
+	int a=4, b=3;
+	AssertEq(a,b);
+}
+void test_assert_int_ne_fail()
+{
+	int a=4, b=3;
+	AssertNe(a,b);
+}
+void test_assert_int_gt_fail()
+{
+	int a=4, b=3;
+	AssertGt(a,b);
+}
+void test_assert_int_ge_fail()
+{
+	int a=4, b=3;
+	AssertGe(a,b);
+}
+void test_assert_int_lt_fail()
+{
+	int a=4, b=3;
+	AssertLt(a,b);
+}
+void test_assert_int_le_fail()
+{
+	int a=4, b=3;
+	AssertLe(a,b);
+}
+
+void test_assert_ptr()
+{
+	int a, b;
+	int *ap = &a;
+	int *bp = &b;
+	int *cp = &a;
+	int *n = NULL;
+
+	// These should all pass
+	AssertPtr(ap);
+	AssertNull(n);
+	AssertPtrEq(ap,cp);
+	AssertPtrNe(ap,bp);
+	AssertPtrGt(ap,bp);
+	AssertPtrGe(ap,bp);
+	AssertPtrGe(ap,cp);
+	AssertPtrLt(bp,ap);
+	AssertPtrLe(bp,ap);
+	AssertPtrLe(cp,ap);
+}
+
+void test_assert_ptr_fail()
+{
+	AssertPtr(NULL);
+}
+
+void test_assert_ptr_null_fail()
+{
+	void (*p)() = &test_assert_ptr_null_fail;
+	AssertPtrNull(p);
+}
+
+void test_assert_int_hex_eq_fail()
+{
+	int a=431, b=577;
+	AssertEqHex(a,b);
+}
+
+void test_assert_float()
+{
+	float a=0.0004, b=0.0003, c=0.0004;
+
+	// These should all pass
+	AssertFloatEq(a,c);
+	AssertFloatNe(a,b);
+	AssertFloatGt(a,b);
+	AssertFloatGe(a,b);
+	AssertFloatGe(a,c);
+	AssertFloatLt(b,a);
+	AssertFloatLe(b,a);
+	AssertFloatLe(c,a);
+	AssertDblEq(a,c);
+	AssertDblNe(a,b);
+	AssertDblGt(a,b);
+	AssertDblGe(a,b);
+	AssertDblGe(a,c);
+	AssertDblLt(b,a);
+	AssertDblLe(b,a);
+	AssertDblLe(c,a);
+	AssertDoubleEq(a,c);
+	AssertDoubleNe(a,b);
+	AssertDoubleGt(a,b);
+	AssertDoubleGe(a,b);
+	AssertDoubleGe(a,c);
+	AssertDoubleLt(b,a);
+	AssertDoubleLe(b,a);
+	AssertDoubleLe(c,a);
+}
+
+
+void test_assert_float_eq_fail()
+{
+	double a=1.0/3.0, b=0.4;
+	AssertFloatEq(a,b);
+}
+
+void test_assert_strings()
+{
+	const char *a = "Bogozity";
+	const char *b = "Arclamp";
+	const char *c = "Bogozity";
+
+	// These should all pass
+	AssertStrEq(a,c);
+	AssertStrNe(a,b);
+	AssertStrGt(a,b);
+	AssertStrGe(a,b);
+	AssertStrGe(a,c);
+	AssertStrLt(b,a);
+	AssertStrLe(b,a);
+	AssertStrLe(c,a);
+}
+
+void test_assert_string_eq_fail()
+{
+	const char *a = "A";
+	const char *b = "a";
+
+	AssertStrEq(a,b);
+}
+
+
+void test_assert_string_ne_fail()
+{
+	const char *a = "A";
+	const char *b = "A";
+
+	AssertStrNe(a,b);
+}
+
+void test_assert_string_gt_fail()
+{
+	const char *a = "A";
+	const char *b = "A";
+
+	AssertStrGt(a,b);
+}
+
+zutest_proc zutest_tests[] = {
+	test_assert_int,
+	test_assert_ptr,
+	test_assert_float,
+	test_assert_strings,
+	NULL
+};
+
+zutest_proc zutest_empty_suite[] = {
+	NULL
+};
+
+zutest_proc zutest_failures[] = {
+	test_fail,
+	test_assert_int_eq_fail,
+	test_assert_ptr_fail,
+	test_assert_ptr_null_fail,
+	test_assert_int_hex_eq_fail,
+	test_assert_float_eq_fail,
+	test_assert_string_eq_fail,
+	test_assert_string_ne_fail,
+	test_assert_string_gt_fail,
+	NULL
+};
+
+zutest_suite all_zutests[] = {
+	zutest_tests,
+	zutest_empty_suite,
+	zutest_failures,
+	NULL
+};
+
+
+int main(int argc, char **argv)
+{
+	run_unit_tests(all_zutests);
+	return 0;
+}
+

Added: trunk/zutest.c
===================================================================
--- trunk/zutest.c	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/zutest.c	2006-03-08 22:03:36 UTC (rev 115)
@@ -0,0 +1,110 @@
+/* zutest.c
+ * Scott Bronson
+ * 6 Mar 2006
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <setjmp.h>
+#include "zutest.h"
+
+
+/**
+ * A single procedure is called a test.  If any of the asserts fail
+ * within a test, the test itself is stopped but all other tests will
+ * be run.
+ *
+ * Most files will contain a number of tests.  These tests are organized
+ * into a suite.  A test suite contains one or more tests.
+ *
+ * Test suites are organized into a test battery.  You don't need to
+ * know this except when specifying all the suites that will be tested.
+ */
+
+
+static jmp_buf test_bail;
+static int tests_run;
+static int successes;
+static int failures;
+
+
+void zutest_fail(const char *file, int line, const char *func, 
+		const char *msg, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "FAIL %s at %s line %d:\n\t", func, file, line);
+	va_start(ap, msg);
+	vfprintf(stderr, msg, ap);
+	va_end(ap);
+	fputc('\n', stderr);
+
+	longjmp(test_bail, 1);
+}
+
+
+void run_zutest_suite(const zutest_suite suite)
+{
+	const zutest_proc *test;
+
+	for(test=suite; *test; test++) {
+		tests_run += 1;
+		if(!setjmp(test_bail)) {
+			(*test)();
+			successes += 1;
+		} else {
+			failures += 1;
+		}
+	}
+}
+
+
+void run_zutest_battery(const zutest_battery battery)
+{
+	zutest_suite *suite;
+
+	for(suite=battery; *suite; suite++) {
+		run_zutest_suite(*suite);
+	}
+}
+
+
+void print_zutest_results()
+{
+	if(failures == 0) {
+		printf("%d tests run, %d successes.\n", successes, successes);
+		return;
+	}
+
+	printf("%d failures of %d tests run!\n", failures, tests_run);
+}
+
+
+void run_unit_tests(const zutest_battery battery)
+{
+	run_zutest_battery(battery);
+	print_zutest_results();
+	exit(failures < 100 ? failures : 100);
+}
+
+
+/**
+ * Examines the command-line arguments.  If "--run-unit-tests" is
+ * the first argument, then it runs the unit tests (further arguments
+ * may affect how the tests are processed).  This routine exits with
+ * a nonzero result code if any test fails; otherwise it exits with 0.
+ * It never returns.
+ *
+ * If --run-unit-tests is not on the command line, this routine returns
+ * without doing anything.
+ */
+
+void unit_test_check(int argc, char **argv, const zutest_battery battery)
+{
+	if(argc > 1 && strcmp(argv[1],"--run-unit-tests") == 0) {
+		run_unit_tests(battery);
+	}
+}
+

Added: trunk/zutest.h
===================================================================
--- trunk/zutest.h	2006-03-07 23:24:44 UTC (rev 114)
+++ trunk/zutest.h	2006-03-08 22:03:36 UTC (rev 115)
@@ -0,0 +1,116 @@
+/* zutest.h
+ * Scott Bronson
+ * 6 Mar 2006
+ *
+ * This is a ground-up rewrite of Asim Jalis's "CuTest" library.
+ * It is released under the MIT License.
+ */
+
+
+// If your compiler doesn't provide __func__, compile with -D__func__='"test"'
+#define Fail(...) zutest_fail(__FILE__, __LINE__, __func__, __VA_ARGS__)
+// If the expression returns false, it is printed in the failure message.
+#define Assert(x) do { if(!(x)) { Fail(#x); } } while(0)
+// If the expression returns false, the given format string is printed.
+#define AssertFmt(x,...) do { if(!(x)) { Fail(__VA_ARGS__); } } while(0)
+// On failure the expression is printed followed by the format string.
+#define AssertExp(ex,...) AssertFmt(ex,#ex __VA_ARGS__)
+
+#define AssertExpType(x,y,op,type,fmt) \
+	AssertExp(x op y," but "#x"=="fmt" and "#y"=="fmt"!",(type)x,(type)y)
+
+// get ready...
+// These only work with integer and pointer values!
+#define AssertEq(x,y) AssertOp(x,y,==)
+#define AssertNe(x,y) AssertOp(x,y,!=)
+#define AssertGt(x,y) AssertOp(x,y,>)
+#define AssertGe(x,y) AssertOp(x,y,>=)
+#define AssertLt(x,y) AssertOp(x,y,<)
+#define AssertLe(x,y) AssertOp(x,y,<=)
+#define AssertIntEq(x,y) AssertOp(x,y,==)
+#define AssertIntNe(x,y) AssertOp(x,y,!=)
+#define AssertIntGt(x,y) AssertOp(x,y,>)
+#define AssertIntGe(x,y) AssertOp(x,y,>=)
+#define AssertIntLt(x,y) AssertOp(x,y,<)
+#define AssertIntLe(x,y) AssertOp(x,y,<=)
+#define AssertOp(x,y,op) AssertExpType(x,y,op,long,"%ld")
+// Same as above but the values are printed in hex rather than decimal.
+#define AssertEqHex(x,y) AssertHexOp(x,y,==)
+#define AssertNeHex(x,y) AssertHexOp(x,y,!=)
+#define AssertGtHex(x,y) AssertHexOp(x,y,>)
+#define AssertGeHex(x,y) AssertHexOp(x,y,>=)
+#define AssertLtHex(x,y) AssertHexOp(x,y,<)
+#define AssertLeHex(x,y) AssertHexOp(x,y,<=)
+// Same as above but all 8 digits are printed
+// If you give me a 64 bit computer, I will give you 16 digits!
+#define AssertHexOp(x,y,op) AssertExpType(x,y,op,long,"0x%lX")
+#define AssertPtr(p)  AssertFmt(p != NULL, \
+		#p" != NULL but "#p"==0x%08lX!", (unsigned long)p)
+#define AssertNull(p) AssertFmt(p == NULL, \
+		#p" == NULL but "#p"==0x%08lX!", (unsigned long)p)
+#define AssertPtrNull(p) AssertNull(p)
+#define AssertPtrEq(x,y) AssertPtrOp(x,y,==)
+#define AssertPtrNe(x,y) AssertPtrOp(x,y,!=)
+#define AssertPtrGt(x,y) AssertPtrOp(x,y,>)
+#define AssertPtrGe(x,y) AssertPtrOp(x,y,>=)
+#define AssertPtrLt(x,y) AssertPtrOp(x,y,<)
+#define AssertPtrLe(x,y) AssertPtrOp(x,y,<=)
+#define AssertPtrOp(x,y,op) AssertExpType(x,y,op,unsigned long,"0x%lX")
+// These work with floats and doubles
+#define AssertFloatEq(x,y) AssertFloatOp(x,y,==)
+#define AssertFloatNe(x,y) AssertFloatOp(x,y,!=)
+#define AssertFloatGt(x,y) AssertFloatOp(x,y,>)
+#define AssertFloatGe(x,y) AssertFloatOp(x,y,>=)
+#define AssertFloatLt(x,y) AssertFloatOp(x,y,<)
+#define AssertFloatLe(x,y) AssertFloatOp(x,y,<=)
+// Dbl is implemented the same as Float internally.
+// We just provide a Dbl and Double names so that the programmer can
+// use whatever name she prefers and the macro can exactly equal the type.
+#define AssertDblEq(x,y) AssertFloatOp(x,y,==)
+#define AssertDblNe(x,y) AssertFloatOp(x,y,!=)
+#define AssertDblGt(x,y) AssertFloatOp(x,y,>)
+#define AssertDblGe(x,y) AssertFloatOp(x,y,>=)
+#define AssertDblLt(x,y) AssertFloatOp(x,y,<)
+#define AssertDblLe(x,y) AssertFloatOp(x,y,<=)
+#define AssertDoubleEq(x,y) AssertFloatOp(x,y,==)
+#define AssertDoubleNe(x,y) AssertFloatOp(x,y,!=)
+#define AssertDoubleGt(x,y) AssertFloatOp(x,y,>)
+#define AssertDoubleGe(x,y) AssertFloatOp(x,y,>=)
+#define AssertDoubleLt(x,y) AssertFloatOp(x,y,<)
+#define AssertDoubleLe(x,y) AssertFloatOp(x,y,<=)
+#define AssertFloatOp(x,y,op) AssertExpType(x,y,op,double,"%lf")
+// These work with strings
+#define AssertStrEq(x,y) AssertStrOp(x,y,EQ,==)
+#define AssertStrNe(x,y) AssertStrOp(x,y,NE,!=)
+#define AssertStrGt(x,y) AssertStrOp(x,y,GT,>)
+#define AssertStrGe(x,y) AssertStrOp(x,y,GE,>=)
+#define AssertStrLt(x,y) AssertStrOp(x,y,LT,<)
+#define AssertStrLe(x,y) AssertStrOp(x,y,LE,<=)
+#define AssertStrOp(x,y,opn,op) AssertFmt(strcmp(x,y) op 0, \
+	#x" "#opn" "#y" but "#x" is \"%s\" and "#y" is \"%s\"!",x,y)
+
+// if none of those macros above fit your fancy, call fail directly.
+void zutest_fail(const char *file, int line, const char *func,
+		const char *msg, ...);
+
+
+
+typedef void (*zutest_proc)();
+typedef zutest_proc *zutest_suite;
+typedef zutest_suite *zutest_battery;
+
+void run_zutest_suite(const zutest_suite suite);
+void run_zutest_battery(const zutest_battery battery);
+void print_zutest_results();
+
+// Call this on the very first line of your application.  If the user
+// ran your program with the first arg of "--run-unit-tests", this will
+// run the tests and exit.  Otherwise your program will run as normal.
+// If you would rather create a dedicated executable, just call
+// run_zutest_battery() directly.
+void unit_test_check(int argc, char **argv, const zutest_battery battery);
+
+// This runs all the unit tests supplied and then exits.  Use this
+// if you want to handle the arguments yourself.
+void run_unit_tests(const zutest_battery battery);
+





